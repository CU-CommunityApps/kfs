Index: test/unit/src/org/kuali/kfs/sys/context/SpringAOPUsageTest.java
===================================================================
--- test/unit/src/org/kuali/kfs/sys/context/SpringAOPUsageTest.java	(revision 32083)
+++ test/unit/src/org/kuali/kfs/sys/context/SpringAOPUsageTest.java	(revision 32084)
@@ -1,127 +0,0 @@
-/*
- * Copyright 2007 The Kuali Foundation
- * 
- * Licensed under the Educational Community License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl2.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.kfs.sys.context;
-
-import java.lang.reflect.Method;
-
-import org.kuali.kfs.coa.service.BalanceTypeService;
-import org.kuali.kfs.coa.service.PriorYearAccountService;
-import org.kuali.kfs.coa.service.impl.BalanceTypeServiceImpl;
-import org.kuali.kfs.sys.ConfigureContext;
-import org.kuali.kfs.sys.suite.AnnotationTestSuite;
-import org.kuali.kfs.sys.suite.PreCommitSuite;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.service.DocumentService;
-import org.kuali.rice.kns.service.impl.AbstractStaticConfigurationServiceImpl;
-import org.kuali.rice.kns.service.impl.DocumentServiceImpl;
-import org.kuali.rice.kns.service.impl.PersistenceStructureServiceImpl;
-import org.kuali.rice.kns.util.cache.MethodCacheInterceptor;
-import org.kuali.rice.kns.util.cache.MethodCacheNoCopyInterceptor;
-import org.kuali.rice.kns.util.spring.CacheNoCopy;
-import org.kuali.rice.kns.util.spring.Cached;
-import org.kuali.rice.kns.util.spring.ClassOrMethodAnnotationFilter;
-import org.springframework.aop.Advisor;
-import org.springframework.aop.support.AopUtils;
-import org.springframework.transaction.TransactionDefinition;
-import org.springframework.transaction.annotation.Transactional;
-import org.springframework.transaction.interceptor.TransactionAttribute;
-import org.springframework.transaction.interceptor.TransactionAttributeSource;
-
-@AnnotationTestSuite(PreCommitSuite.class)
-@ConfigureContext
-public class SpringAOPUsageTest extends KualiTestBase {
-    public void testCaching() throws Exception {
-        ClassOrMethodAnnotationFilter classOrMethodAnnotationFilter = new ClassOrMethodAnnotationFilter(Cached.class);
-        ClassOrMethodAnnotationFilter classOrMethodAnnotationNoCopyFilter = new ClassOrMethodAnnotationFilter(CacheNoCopy.class);
-        assertTrue(AbstractStaticConfigurationServiceImpl.class.isAnnotationPresent(Cached.class));
-        assertFalse(BalanceTypeServiceImpl.class.isAnnotationPresent(Cached.class));
-        assertTrue(classOrMethodAnnotationFilter.matches(AbstractStaticConfigurationServiceImpl.class));
-        assertTrue(classOrMethodAnnotationNoCopyFilter.matches(BalanceTypeServiceImpl.class));
-        // should be cached cause of method annotation
-        SpringContext.getBean(BalanceTypeService.class).getCurrentYearCostShareEncumbranceBalanceType();
-        assertTrue("BalanceTypService.getCurrentYearCostShareEncumbranceBalanceType() is not cached.", methodIsCached(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {}));
-        // should not be cached cause no method annotation and no class annotation
-        SpringContext.getBean(BalanceTypeService.class).getAllBalanceTypes();
-        assertFalse(methodIsCached(BalanceTypeService.class.getMethod("getAllBalanceTypes", new Class[] {}), new Object[] {}));
-        // should not be cached, cause no annotations on the class or its methods
-        SpringContext.getBean(PriorYearAccountService.class).getByPrimaryKey("BL", "1031490");
-        assertFalse(methodIsCached(PriorYearAccountService.class.getMethod("getByPrimaryKey", new Class[] { String.class, String.class }), new Object[] { "BL", "1031490" }));
-    }
-    
-    /**
-     * Assures the removeCacheKey method of methodCacheInterceptor is actually removing the method cache.
-     * Depends on method implementations for BalanceTypService.getAllBalanceTyps() and PersistenceStructureService.getPrimaryKeys(Class clazz) 
-     * having the @Cached annotation.
-     */
-    public void testClearMethodCache() throws Exception {
-        SpringContext.getBean(BalanceTypeService.class).getCurrentYearCostShareEncumbranceBalanceType();
-        assertTrue("BalanceTypService.getCurrentYearCostShareEncumbranceBalanceType() is not cached.", methodIsCached(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {}));
-        removeCachedMethod(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {});
-        assertFalse(methodIsCached(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {}));
-    }
-
-    @Transactional
-    public void testTransactions() throws Exception {
-//        ClassOrMethodAnnotationFilter classOrMethodAnnotationFilter = new ClassOrMethodAnnotationFilter(Transactional.class);
-//        Exception exception = null;
-//        try {
-//            classOrMethodAnnotationFilter.matches(getClass());
-//        } catch (Exception e) {
-//            exception = e;
-//        }
-//        assertNotNull(exception);
-//        assertEquals("The @Transactional annotation should be specified at the class level and overriden at the method level, if need be.", exception.getMessage());
-        Advisor transactionAdvisor = SpringContext.getBean(Advisor.class);
-        // should be transaction applicable because the class has the annotation
-        assertTrue(AopUtils.canApply(transactionAdvisor, DocumentServiceImpl.class));
-        // should not be transaction applicable since there's no annotation in the class hierarchy
-        assertFalse(AopUtils.canApply(transactionAdvisor, PersistenceStructureServiceImpl.class));
-        TransactionAttributeSource transactionAttributeSource = SpringContext.getBean(TransactionAttributeSource.class);
-        // should be transactionalized because the class that defines it has the transactional annotation
-        TransactionAttribute documentServiceSaveDocumentAttribute = transactionAttributeSource.getTransactionAttribute(DocumentService.class.getMethod("saveDocument", new Class[] { Document.class }), DocumentServiceImpl.class);
-        assertNotNull(documentServiceSaveDocumentAttribute);
-        TransactionAttribute documentServiceSaveDocumentWithEventAttribute = transactionAttributeSource.getTransactionAttribute(DocumentService.class.getMethod("saveDocument", new Class[] { Document.class, Class.class }), DocumentServiceImpl.class);
-        assertNotNull(documentServiceSaveDocumentWithEventAttribute);
-        assertTrue(TransactionDefinition.PROPAGATION_REQUIRED == documentServiceSaveDocumentWithEventAttribute.getPropagationBehavior());
-    }
-
-    private void removeCachedMethod(Method method, Object[] arguments) {
-        MethodCacheInterceptor methodCacheInterceptor = SpringContext.getBean(MethodCacheInterceptor.class);
-        if (methodCacheInterceptor.containsCacheKey(methodCacheInterceptor.buildCacheKey(method.toString(), arguments))) {
-            String cacheKey = methodCacheInterceptor.buildCacheKey(method.toString(), arguments);
-            System.out.println(cacheKey);
-            methodCacheInterceptor.removeCacheKey(cacheKey);
-            assertFalse(methodCacheInterceptor.containsCacheKey(cacheKey));
-        }
-
-        MethodCacheNoCopyInterceptor methodCacheNoCopyInterceptor = SpringContext.getBean(MethodCacheNoCopyInterceptor.class);
-        if (methodCacheNoCopyInterceptor.containsCacheKey(methodCacheInterceptor.buildCacheKey(method.toString(), arguments))) {
-            String cacheKey = methodCacheNoCopyInterceptor.buildCacheKey(method.toString(), arguments);
-            System.out.println(cacheKey);
-            methodCacheNoCopyInterceptor.removeCacheKey(cacheKey);
-            assertFalse(methodCacheNoCopyInterceptor.containsCacheKey(cacheKey));
-        }
-    }
-    
-    private boolean methodIsCached(Method method, Object[] arguments) {
-        MethodCacheInterceptor methodCacheInterceptor = SpringContext.getBean(MethodCacheInterceptor.class);
-        MethodCacheNoCopyInterceptor methodCacheNoCopyInterceptor = SpringContext.getBean(MethodCacheNoCopyInterceptor.class);
-
-        String cacheKey = methodCacheInterceptor.buildCacheKey(method.toString(), arguments);
-        
-        return methodCacheInterceptor.containsCacheKey( cacheKey ) || methodCacheNoCopyInterceptor.containsCacheKey(cacheKey);
-    }
-}
Index: work/src/org/kuali/rice/devtools/generators/dd/MaintDocDDCreator.java
===================================================================
--- work/src/org/kuali/rice/devtools/generators/dd/MaintDocDDCreator.java	(revision 0)
+++ work/src/org/kuali/rice/devtools/generators/dd/MaintDocDDCreator.java	(revision 32084)
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2008 The Regents of the University of California
+ * 
+ */
+package org.kuali.rice.devtools.generators.dd;
+
+import org.apache.commons.beanutils.PropertyUtils;
+import org.kuali.rice.krad.bo.BusinessObject;
+
+import java.beans.PropertyDescriptor;
+
+/**
+ * @deprecated this is for the legacy kns.
+ */
+@Deprecated
+public class MaintDocDDCreator {
+
+    public static void main( String[] args ) throws Exception {
+        String className = args[0];
+        Class boClass = Class.forName( className );
+        PropertyDescriptor[] props = PropertyUtils.getPropertyDescriptors( boClass );
+
+        StringBuffer sb = new StringBuffer( 4000 );
+        sb.append( "<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n" + 
+                "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n" + 
+                "    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n" + 
+                "    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n" + 
+                "        http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\">\r\n" + 
+                "\r\n" + 
+                "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument\" parent=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-parentBean\" />\r\n" + 
+                "\r\n" + 
+                "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-parentBean\" abstract=\"true\" parent=\"MaintenanceDocumentEntry\"\r\n" + 
+                "        p:businessObjectClass=\"" );
+        sb.append( boClass.getName() );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:maintainableClass=\"" ); 
+        sb.append( "org.kuali.core.maintenance.KualiMaintainableImpl" );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:label=\"" ); 
+        sb.append( BeanDDCreator.camelCaseToString( boClass.getSimpleName() ) );
+        sb.append( " Maintenance Document\"\r\n" );
+        sb.append( "        p:shortLabel=\"" ); 
+        sb.append( BeanDDCreator.camelCaseToString( boClass.getSimpleName() ) );
+        sb.append( " Maint. Doc.\"\r\n" );
+        sb.append( "        p:documentTypeName=\"" ); 
+        sb.append( boClass.getSimpleName() + "MaintenanceDocument" );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:documentTypeCode=\"" ); 
+        sb.append( "FILLMEIN" );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:businessRulesClass=\"" ); 
+        sb.append( "org.kuali.core.maintenance.rules.MaintenanceDocumentRuleBase" );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:preRulesCheckClass=\"" ); 
+        sb.append( "FILLMEIN" );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:documentAuthorizerClass=\"" ); 
+        sb.append( "org.kuali.kfs.sys.document.authorization.FinancialSystemMaintenanceDocumentAuthorizerBase" );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:workflowProperties-ref=\"" ); 
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-workflowProperties\" >\r\n" );
+        sb.append( "\r\n" );
+
+        sb.append( "    <property name=\"authorizations\" >\r\n" + 
+        		"      <list>\r\n" + 
+        		"        <bean parent=\"AuthorizationDefinition\">\r\n" + 
+        		"          <property name=\"action\" value=\"initiate\" />\r\n" + 
+        		"          <property name=\"authorizedGroups\" >\r\n" + 
+        		"            <set>\r\n" + 
+        		"              <value>SY_MAINTENANCE_USERS</value>\r\n" + 
+        		"            </set>\r\n" + 
+        		"          </property>\r\n" + 
+        		"        </bean>\r\n" + 
+        		"      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"" );
+        sb.append( "    <property name=\"lockingKeys\" >\r\n" + 
+        		"      <list>\r\n" + 
+        		"        <value>FILLMEIN</value>\r\n" + 
+        		"      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"");
+        sb.append( "    <property name=\"helpDefinition\" >\r\n" + 
+        		"      <bean parent=\"HelpDefinition\" p:parameterClass=\"" );
+        sb.append( boClass.getName() );
+        sb.append( "\" p:parameterName=\"" );
+        sb.append( camelCaseToHelpParm( boClass.getSimpleName() ) );
+        sb.append( "\" />\r\n" + 
+        		"    </property>\r\n" + 
+        		"" );
+        sb.append( "    <property name=\"defaultExistenceChecks\" >\r\n" + 
+        		"      <list>\r\n" + 
+        		"" );
+        for ( PropertyDescriptor pd : props ) {
+            if ( isReferenceBoProperty(pd)) {
+                sb.append( "        <bean parent=\"ReferenceDefinition\"\r\n" + 
+                		"              p:attributeName=\"" );
+                sb.append( pd.getName() );
+                sb.append( "\"\r\n" + 
+                		"              p:activeIndicatorAttributeName=\"active\"\r\n" + 
+                		"              p:attributeToHighlightOnFail=\"FILLMEIN\" />\r\n" + 
+                		"" );
+            }
+        }
+        sb.append( "      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"" );
+        
+        sb.append( "    <property name=\"maintainableSections\" >\r\n" + 
+        		"      <list>\r\n" + 
+        		"        <ref bean=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-MainSection\" />\r\n" + 
+        		"      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"  </bean>\r\n\r\n");
+        
+        sb.append( "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-MainSection\" parent=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-MainSection-parentBean\" />\r\n" + 
+                "\r\n" + 
+                "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-MainSection-parentBean\" abstract=\"true\" parent=\"MaintainableSectionDefinition\"\r\n" + 
+                "        p:title=\"" );
+        sb.append( BeanDDCreator.camelCaseToString( boClass.getSimpleName() ) );
+        sb.append( " Maintenance\" >\r\n" +
+        		"    <property name=\"maintainableItems\" >\r\n" + 
+        		"      <list>\r\n" + 
+        		"" );
+        for ( PropertyDescriptor pd : props ) {
+            if ( BeanDDCreator.isNormalProperty(pd) && !pd.getName().endsWith("codeAndDescription" ) ) {
+                
+                sb.append( "        <bean parent=\"MaintainableFieldDefinition\"\r\n" + 
+                		"              p:name=\"" );
+                sb.append( pd.getName() );
+                if ( pd.getName().endsWith("active" ) ) {
+                    sb.append( "\"\r\n" + 
+                            "              p:defaultValue=\"true\" />\r\n" );
+                } else if ( pd.getName().equals("versionNumber" ) ) {
+                    sb.append( "\" />\r\n" );
+                } else {
+                    sb.append( "\"\r\n" + 
+                    "              p:required=\"true\" />\r\n" );
+                }
+            }
+        }
+        sb.append( "      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"  </bean>\r\n" + 
+        		"" );
+        sb.append( "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-workflowProperties\" parent=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-workflowProperties-parentBean\" />\r\n" + 
+        		"\r\n" + 
+        		"  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "MaintenanceDocument-workflowProperties-parentBean\" abstract=\"true\" parent=\"CommonWorkflow-MaintenanceDocument\" />\r\n" + 
+//        		"    <property name=\"workflowPropertyGroups\" >\r\n" + 
+//        		"      <list>\r\n" + 
+//        		"        <bean parent=\"WorkflowPropertyGroup\">\r\n" + 
+//        		"          <property name=\"workflowProperties\" >\r\n" + 
+//        		"            <list>\r\n" + 
+//        		"              <bean parent=\"WorkflowProperty\" p:path=\"newMaintainableObject.businessObject\" />\r\n" + 
+//        		"              <bean parent=\"WorkflowProperty\" p:path=\"oldMaintainableObject.businessObject\" />\r\n" + 
+//        		"            </list>\r\n" + 
+//        		"          </property>\r\n" + 
+//        		"        </bean>\r\n" + 
+//        		"      </list>\r\n" + 
+//        		"    </property>\r\n" + 
+//        		"  </bean>\r\n" + 
+        		"</beans>" );
+        System.out.println( sb.toString() );
+    }
+    
+    public static String camelCaseToHelpParm( String className ) {
+        StringBuffer newName = new StringBuffer( className );
+        // lower case the 1st letter
+        newName.replace(0, 1, newName.substring(0, 1).toLowerCase());
+        // loop through, inserting spaces when cap
+        for ( int i = 0; i < newName.length(); i++ ) {
+            if ( Character.isUpperCase(newName.charAt(i)) ) {
+                newName.insert(i, '_');
+                i++;
+            }
+        }
+        return newName.toString().toUpperCase().trim();
+    }
+    
+    public static boolean isReferenceBoProperty( PropertyDescriptor p ) {
+        return p.getPropertyType()!= null 
+                && BusinessObject.class.isAssignableFrom( p.getPropertyType() )
+                && !p.getName().startsWith( "boNote" )
+                && !p.getName().startsWith( "extension" )
+                && !p.getName().equals( "newCollectionRecord" );
+    }
+    
+}

Property changes on: work/src/org/kuali/rice/devtools/generators/dd/MaintDocDDCreator.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/devtools/generators/dd/BeanDDCreator.java
===================================================================
--- work/src/org/kuali/rice/devtools/generators/dd/BeanDDCreator.java	(revision 0)
+++ work/src/org/kuali/rice/devtools/generators/dd/BeanDDCreator.java	(revision 32084)
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.devtools.generators.dd;
+
+import org.apache.commons.beanutils.PropertyUtils;
+import org.kuali.rice.krad.bo.BusinessObject;
+
+import java.beans.PropertyDescriptor;
+
+/**
+ * @deprecated this is for the legacy kns.
+ */
+@Deprecated
+public class BeanDDCreator {
+
+    /**
+     * This method...
+     * @param args
+     */
+    public static void main(String[] args) throws Exception {
+        String className = args[0];
+        Class<? extends BusinessObject> boClass = (Class<? extends BusinessObject>)Class.forName( className );
+        PropertyDescriptor[] props = PropertyUtils.getPropertyDescriptors( boClass );
+        
+        StringBuffer sb = new StringBuffer( 4000 );
+        sb.append( "<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n" + 
+        		"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n" + 
+        		"    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n" + 
+        		"    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n" + 
+        		"        http://www.springframework.org/schema/beans/spring-beans-2.0.xsd\">\r\n" + 
+        		"\r\n" + 
+        		"  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "\" parent=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "-parentBean\" />\r\n" + 
+        		"\r\n" + 
+        		"  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "-parentBean\" abstract=\"true\" parent=\"BusinessObjectEntry\"\r\n" + 
+        		"        p:businessObjectClass=\"" );
+        sb.append( boClass.getName() );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:titleAttribute=\"" ); 
+        sb.append( "FILL ME IN" );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:objectLabel=\"" ); 
+        sb.append(  camelCaseToString( boClass.getSimpleName() ) );
+        sb.append( "\"\r\n" );
+        sb.append( "        p:inquiryDefinition-ref=\"" ); 
+        sb.append( boClass.getSimpleName() );
+        sb.append( "-inquiryDefinition\"\r\n" );
+        sb.append( "        p:lookupDefinition-ref=\"" ); 
+        sb.append( boClass.getSimpleName() );
+        sb.append( "-lookupDefinition\" >\r\n" );
+        sb.append( "    <property name=\"attributes\" >\r\n" + 
+        		"      <list>\r\n" );
+        for ( PropertyDescriptor p : props ) {
+            if ( isNormalProperty(p) ) {
+                sb.append( "        <ref bean=\"" ).append( boClass.getSimpleName() ).append( '-' );
+                sb.append( p.getName() );
+                sb.append( "\" />\r\n" );
+            }
+        }
+        
+        sb.append( "      </list>\r\n" + 
+        		"    </property>\r\n" +
+        		"  </bean>\r\n" +
+        		"\r\n" );
+        for ( PropertyDescriptor p : props ) {
+            if ( isNormalProperty(p) ) {
+                
+                if ( p.getName().equals( "versionNumber" ) ) {
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    sb.append( getSimpleAbstractInheritanceBean(boClass, p.getName(), "GenericAttributes-versionNumber" ) );
+                    
+                } else if ( p.getName().endsWith("chartOfAccountsCode" ) ) {
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    sb.append( getSimpleAbstractInheritanceBean(boClass, p.getName(), "Chart-chartOfAccountsCode" ) );
+
+                } else if ( p.getName().endsWith("organizationCode" ) ) {
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    sb.append( getSimpleAbstractInheritanceBean(boClass, p.getName(), "Org-organizationCode" ) );
+
+                } else if ( p.getName().endsWith("accountNumber" ) ) {
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    sb.append( getSimpleAbstractInheritanceBean(boClass, p.getName(), "Account-accountNumber" ) );
+
+                } else if ( p.getName().equals("active" ) ) {
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    sb.append( getSimpleAbstractInheritanceBean(boClass, p.getName(), "GenericAttributes-activeIndicator" ) );
+
+                } else if ( p.getName().equals("codeAndDescription" ) ) {
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    sb.append( getSimpleAbstractInheritanceBeanWithLabel(boClass, p.getName(), "CommonField-CodeAndDescription", camelCaseToString(boClass.getSimpleName()) ) );
+
+                } else if ( p.getPropertyType() == Boolean.TYPE ) {
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    sb.append( getSimpleAbstractInheritanceBean(boClass, p.getName(), "GenericAttributes-genericBoolean" ) );
+
+                } else {
+                    // attribute bean
+                    sb.append( getSimpleParentBeanReference( boClass, p.getName() ) );
+                    // attribute parent bean
+                    sb.append( "  <bean id=\"" ).append( boClass.getSimpleName() ).append( '-' );
+                    sb.append( p.getName() ).append( "-parentBean\" parent=\"AttributeDefinition\" abstract=\"true\"\r\n" );
+                    sb.append( "        p:name=\"" ).append( p.getName() ).append( "\"\r\n" );
+                    sb.append( "        p:forceUppercase=\"false\"\r\n" );
+                    sb.append( "        p:label=\"" ).append( camelCaseToString(p.getName()) ).append( "\"\r\n" );
+                    sb.append( "        p:shortLabel=\"" ).append( camelCaseToString(p.getName()) ).append( "\"\r\n" );
+                    sb.append( "        p:maxLength=\"10\"\r\n" );
+                    sb.append( "        p:required=\"false\" >\r\n" );
+                    sb.append( "    <property name=\"validationPattern\" >\r\n" + 
+                            "      <bean parent=\"AnyCharacterValidationPattern\"\r\n" + 
+                            "            p:allowWhitespace=\"true\" />\r\n" + 
+                            "    </property>\r\n" + 
+                            "    <property name=\"control\" >\r\n" + 
+                            "      <bean parent=\"TextControlDefinition\"\r\n" + 
+                            "            p:size=\"10\" />\r\n" + 
+                            "    </property>\r\n" + 
+                            "  </bean>\r\n" );
+                    
+                }
+                sb.append( "\r\n" );
+            }
+        }
+        // inquiry definition
+        
+        sb.append( getSimpleParentBeanReference( boClass, "inquiryDefinition" ) );
+        sb.append( "\r\n" );
+        sb.append( "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "-inquiryDefinition-parentBean\" abstract=\"true\" parent=\"InquiryDefinition\"\r\n" + 
+        		"        p:title=\"" );
+        sb.append( camelCaseToString(boClass.getSimpleName() ) );
+        sb.append( " Inquiry\" >\r\n" + 
+        		"    <property name=\"inquirySections\" >\r\n" + 
+        		"      <list>\r\n" + 
+        		"        <bean parent=\"InquirySectionDefinition\"\r\n" + 
+        		"              p:title=\"" );
+        sb.append( camelCaseToString(boClass.getSimpleName() ) );
+        sb.append( " Attributes\"\r\n" + 
+        		"              p:numberOfColumns=\"1\" >\r\n" + 
+        		"          <property name=\"inquiryFields\" >\r\n" + 
+        		"            <list>\r\n" );
+        for ( PropertyDescriptor p : props ) {
+            if ( isNormalProperty(p) ) {
+                sb.append("              <bean parent=\"FieldDefinition\" p:attributeName=\"" );
+                sb.append( p.getName() ).append( "\" />\r\n" );
+            }
+        }
+        sb.append( "            </list>\r\n" + 
+        		"          </property>\r\n" + 
+        		"        </bean>\r\n" + 
+        		"      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"  </bean>\r\n" + 
+        		"\r\n" );
+
+        sb.append( getSimpleParentBeanReference( boClass, "lookupDefinition" ) );
+        sb.append( "\r\n" );
+        sb.append( "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );
+        sb.append( "-lookupDefinition-parentBean\" abstract=\"true\" parent=\"LookupDefinition\"\r\n" + 
+                "        p:title=\"" );
+        sb.append( camelCaseToString(boClass.getSimpleName() ) );
+        sb.append( " Lookup\" \r\n" );
+        //sb.append( "        p:instructions=\"Lookup a " );
+        //sb.append( camelCaseToString(boClass.getSimpleName() ) );
+        sb.append( "\" >\r\n" );
+        sb.append( "    <property name=\"defaultSort\" >\r\n" + 
+        		"      <bean parent=\"SortDefinition\">\r\n" + 
+        		"        <property name=\"attributeNames\" >\r\n" + 
+        		"          <list>\r\n" + 
+        		"            <value>FILL ME IN</value>\r\n" + 
+        		"          </list>\r\n" + 
+        		"        </property>\r\n" + 
+        		"        <property name=\"sortAscending\" value=\"true\" />\r\n" + 
+        		"      </bean>\r\n" + 
+        		"    </property>\r\n" + 
+        		"    <property name=\"lookupFields\" >\r\n" + 
+        		"      <list>\r\n" );
+        for ( PropertyDescriptor p : props ) {
+            if ( isNormalProperty(p) ) {
+                sb.append("        <bean parent=\"FieldDefinition\" p:attributeName=\"" );
+                sb.append( p.getName() ).append( "\" />\r\n" );
+            }
+        }
+        sb.append( "      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"    <property name=\"resultFields\" >\r\n" + 
+        		"      <list>\r\n" );
+        for ( PropertyDescriptor p : props ) {
+            if ( isNormalProperty(p) ) {
+                sb.append("        <bean parent=\"FieldDefinition\" p:attributeName=\"" );
+                sb.append( p.getName() ).append( "\" />\r\n" );
+            }
+        }
+        sb.append( "      </list>\r\n" + 
+        		"    </property>\r\n" + 
+        		"  </bean>\r\n" );
+        sb.append( "\r\n</beans>" );
+        System.out.println( sb.toString() );
+    }
+
+    public static String getSimpleAbstractInheritanceBean( Class<? extends BusinessObject> boClass, String propertyName, String parentBean ) {
+        StringBuffer sb = new StringBuffer( 100 );
+        sb.append( "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );                    
+        sb.append( "-" ).append( propertyName ).append( "-parentBean\" abstract=\"true\" parent=\"" );
+        sb.append( parentBean ).append( "\" \r\n" );        
+        sb.append( "        p:name=\"" ).append( propertyName ).append( "\"\r\n" );
+        sb.append( "        p:required=\"false\" />\r\n" );
+        return sb.toString();
+    }
+    
+    public static String getSimpleAbstractInheritanceBeanWithLabel( Class<? extends BusinessObject> boClass, String propertyName, String parentBean, String label ) {
+        StringBuffer sb = new StringBuffer( 100 );
+        sb.append( "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );                    
+        sb.append( "-" ).append( propertyName ).append( "-parentBean\" abstract=\"true\" parent=\"" );
+        sb.append( parentBean ).append( "\" \r\n" );        
+        sb.append( "        p:name=\"" ).append( propertyName ).append( "\"\r\n" );
+        sb.append( "        p:label=\"" ).append( label ).append( "\"\r\n" );
+        sb.append( "        p:required=\"false\" />\r\n" );
+        return sb.toString();
+    }
+    
+    public static String getSimpleParentBeanReference( Class<? extends BusinessObject> boClass, String propertyName ) {
+        StringBuffer sb = new StringBuffer( 100 );
+        sb.append( "  <bean id=\"" );
+        sb.append( boClass.getSimpleName() );                    
+        sb.append( "-" ).append( propertyName ).append( "\" parent=\"" );
+        sb.append( boClass.getSimpleName() );                    
+        sb.append( "-" ).append( propertyName ).append( "-parentBean\" />\r\n" );
+        return sb.toString();
+    }
+    
+    public static boolean isNormalProperty( PropertyDescriptor p ) {
+        return p.getPropertyType()!= null 
+                && !BusinessObject.class.isAssignableFrom( p.getPropertyType() )
+                && !p.getName().equals( "objectId" )
+                && !p.getName().equals( "class" )
+                && !p.getName().startsWith( "boNote" )
+                && !p.getName().startsWith( "autoIncrementSet" )
+                && !p.getName().equals( "newCollectionRecord" );
+    }
+    
+    public static String camelCaseToString( String className ) {
+        StringBuffer newName = new StringBuffer( className );
+        // upper case the 1st letter
+        newName.replace(0, 1, newName.substring(0, 1).toUpperCase());
+        // loop through, inserting spaces when cap
+        for ( int i = 0; i < newName.length(); i++ ) {
+            if ( Character.isUpperCase(newName.charAt(i)) ) {
+                newName.insert(i, ' ');
+                i++;
+            }
+        }
+
+        return newName.toString().trim().replace( "Uc", "UC" );
+    }
+}

Property changes on: work/src/org/kuali/rice/devtools/generators/dd/BeanDDCreator.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java	(revision 32084)
@@ -0,0 +1,415 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.service.impl;
+
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.apache.log4j.Logger;
+import org.kuali.rice.kim.api.common.delegate.DelegateMember;
+import org.kuali.rice.kim.api.common.delegate.DelegateType;
+import org.kuali.rice.kim.api.role.Role;
+import org.kuali.rice.kim.api.role.RoleManagementService;
+import org.kuali.rice.kim.api.role.RoleMember;
+import org.kuali.rice.kim.api.role.RoleMembership;
+import org.kuali.rice.kim.api.role.RoleResponsibility;
+import org.kuali.rice.kim.api.role.RoleResponsibilityAction;
+import org.kuali.rice.kim.api.role.RoleService;
+import org.kuali.rice.kim.api.role.RoleUpdateService;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+import java.sql.Date;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class RoleManagementServiceImpl implements RoleManagementService {
+    private static final Logger LOG = Logger.getLogger(RoleManagementServiceImpl.class);
+
+    private RoleService roleService;
+    private RoleUpdateService roleUpdateService;
+
+    @Override
+    public void flushRoleCaches() {
+        flushInternalRoleCache();
+        flushInternalRoleMemberCache();
+        flushInternalDelegationCache();
+        flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void flushRoleMemberCaches() {
+        flushInternalRoleMemberCache();
+    }
+
+    @Override
+    public void flushDelegationCaches() {
+        flushInternalDelegationCache();
+        flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void flushDelegationMemberCaches() {
+        flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void removeCacheEntries(String roleId, String principalId) {
+
+    }
+
+    @Override
+    public Collection<String> getRoleMemberPrincipalIds(String namespaceCode, String roleName, Map<String, String> qualification) {
+        return getRoleService().getRoleMemberPrincipalIds(namespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public Role getRole(String roleId) {
+        return getRoleService().getRole(roleId);
+    }
+
+    @Override
+    public Role getRoleByName(String namespaceCode, String roleName) {
+        return getRoleService().getRoleByName(namespaceCode, roleName);
+    }
+
+    @Override
+    public String getRoleIdByName(String namespaceCode, String roleName) {
+        Role role = getRoleByName(namespaceCode, roleName);
+        if (role == null) {
+            return null;
+        }
+        return role.getId();
+    }
+
+    @Override
+    public List<Role> getRoles(List<String> roleIds) {
+        return getRoleService().getRoles(roleIds);
+    }
+
+    @Override
+    public List<RoleMembership> getRoleMembers(List<String> roleIds, Map<String, String> qualification) {
+        return getRoleService().getRoleMembers(roleIds, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getRoleQualifiersForPrincipal(String principalId, List<String> roleIds, Map<String, String> qualification) {
+        return getRoleService().getRoleQualifiersForPrincipal(principalId, roleIds, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getRoleQualifiersForPrincipal(String principalId, String namespaceCode, String roleName, Map<String, String> qualification) {
+        return getRoleService().getRoleQualifiersForPrincipal(principalId, namespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public boolean isRoleActive(String roleId) {
+        Role role = getRole(roleId);
+        return role != null && role.isActive();
+    }
+
+    @Override
+    public boolean principalHasRole(String principalId, List<String> roleIds, Map<String, String> qualification) {
+        if (LOG.isDebugEnabled()) {
+            logPrincipalHasRoleCheck(principalId, roleIds, qualification);
+        }
+        boolean hasRole =  getRoleService().principalHasRole(principalId, roleIds, qualification);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Result: " + hasRole);
+            }
+        return hasRole;
+    }
+
+    @Override
+    public List<String> getPrincipalIdSubListWithRole(
+            List<String> principalIds, String roleNamespaceCode,
+            String roleName, Map<String, String> qualification) {
+        return getRoleService().getPrincipalIdSubListWithRole(principalIds,
+                roleNamespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getNestedRoleQualifiersForPrincipal(String principalId, List<String> roleIds, Map<String, String> qualification) {
+        return getRoleService().getNestedRoleQualifiersForPrincipal(principalId, roleIds, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getNestedRoleQualifiersForPrincipal(String principalId, String namespaceCode, String roleName, Map<String, String> qualification) {
+        return getRoleService().getNestedRoleQualifiersForPrincipal(principalId, namespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public void assignGroupToRole(String groupId, String namespaceCode, String roleName,
+                                  Map<String, String> qualifications) {
+        getRoleUpdateService().assignGroupToRole(groupId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public void assignPrincipalToRole(String principalId, String namespaceCode, String roleName,
+                                      Map<String, String> qualifications) {
+        Role role = getRoleByName(namespaceCode, roleName);
+        getRoleUpdateService().assignPrincipalToRole(principalId, namespaceCode, roleName, qualifications);
+        removeCacheEntries(role.getId(), principalId);
+    }
+
+    @Override
+    public void removeGroupFromRole(String groupId, String namespaceCode, String roleName,
+                                    Map<String, String> qualifications) {
+        getRoleUpdateService().removeGroupFromRole(groupId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public void removePrincipalFromRole(String principalId, String namespaceCode, String roleName,
+                                        Map<String, String> qualifications) {
+        Role role = getRoleByName(namespaceCode, roleName);
+        getRoleUpdateService().removePrincipalFromRole(principalId, namespaceCode, roleName, qualifications);
+        removeCacheEntries(role.getId(), principalId);
+    }
+
+    @Override
+    public List<Role> getRolesSearchResults(
+            Map<String, String> fieldValues) {
+        return getRoleService().getRolesSearchResults(fieldValues);
+    }
+
+    protected void logPrincipalHasRoleCheck(String principalId, List<String> roleIds, Map<String, String> roleQualifiers) {
+        StringBuilder sb = new StringBuilder();
+        sb.append('\n');
+        sb.append("Has Role     : ").append(roleIds).append('\n');
+        if (roleIds != null) {
+            for (String roleId : roleIds) {
+                Role role = getRole(roleId);
+                if (role != null) {
+                    sb.append("        Name : ").append(role.getNamespaceCode()).append('/').append(role.getName());
+                    sb.append(" (").append(roleId).append(')');
+                    sb.append('\n');
+                }
+            }
+        }
+        sb.append("   Principal : ").append(principalId);
+        sb.append('\n');
+        sb.append("     Details :\n");
+        if (roleQualifiers != null) {
+            sb.append(new HashMap<String, String>(roleQualifiers));
+        } else {
+            sb.append("               [null]\n");
+        }
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(sb.append(ExceptionUtils.getStackTrace(new Throwable())));
+        } else {
+            LOG.debug(sb.toString());
+        }
+    }
+
+    @Override
+    public void principalInactivated(String principalId) {
+        getRoleService().principalInactivated(principalId);
+        removeCacheEntries(null, principalId);
+    }
+
+    @Override
+    public void roleInactivated(String roleId) {
+        getRoleService().roleInactivated(roleId);
+        removeCacheEntries(roleId, null);
+    }
+
+    @Override
+    public void groupInactivated(String groupId) {
+        getRoleService().groupInactivated(groupId);
+    }
+
+    @Override
+    public List<RoleMembership> getFirstLevelRoleMembers(List<String> roleIds) {
+        return getRoleService().getFirstLevelRoleMembers(roleIds);
+    }
+
+    @Override
+    public List<RoleMember> findRoleMembers(Map<String, String> fieldValues) {
+        return getRoleService().findRoleMembers(fieldValues);
+    }
+
+    @Override
+    public List<RoleMembership> findRoleMemberships(Map<String, String> fieldValues) {
+        return getRoleService().findRoleMemberships(fieldValues);
+    }
+
+    @Override
+    public void assignRoleToRole(String roleId, String namespaceCode, String roleName,
+                                 Map<String, String> qualifications) {
+        getRoleUpdateService().assignRoleToRole(
+                roleId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public void saveDelegationMemberForRole(String delegationMemberId, String roleMemberId, String memberId, String memberTypeCode,
+                                            String delegationTypeCode, String roleId, Map<String, String> qualifications,
+                                            Date activeFromDate, Date activeToDate) throws UnsupportedOperationException {
+        getRoleUpdateService().saveDelegationMemberForRole(delegationMemberId, roleMemberId, memberId, memberTypeCode, delegationTypeCode, roleId, qualifications, activeFromDate, activeToDate);
+        Role role = getRole(roleId);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public RoleMember saveRoleMemberForRole(String roleMemberId, String memberId, String memberTypeCode,
+                                            String roleId, Map<String, String> qualifications, Date activeFromDate, Date activeToDate) throws UnsupportedOperationException {
+        Role role = getRole(roleId);
+        RoleMember roleMember = getRoleUpdateService().saveRoleMemberForRole(roleMemberId, memberId, memberTypeCode, roleId, qualifications, activeFromDate, activeToDate);
+        removeCacheEntries(role.getId(), memberId);
+        return roleMember;
+    }
+
+    @Override
+    public void removeRoleFromRole(String roleId, String namespaceCode, String roleName,
+                                   Map<String, String> qualifications) {
+        getRoleUpdateService().removeRoleFromRole(roleId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public List<DelegateMember> findDelegateMembers(Map<String, String> fieldValues) {
+        return getRoleService().findDelegateMembers(fieldValues);
+    }
+
+    @Override
+    public List<DelegateMember> getDelegationMembersByDelegationId(String delegationId) {
+        return getRoleService().getDelegationMembersByDelegationId(delegationId);
+    }
+
+    @Override
+    public DelegateMember getDelegationMemberByDelegationAndMemberId(String delegationId, String memberId) {
+        return getRoleService().getDelegationMemberByDelegationAndMemberId(delegationId, memberId);
+    }
+
+    @Override
+    public DelegateMember getDelegationMemberById(String delegationMemberId) {
+        return getRoleService().getDelegationMemberById(delegationMemberId);
+    }
+
+    @Override
+    public List<RoleResponsibilityAction> getRoleMemberResponsibilityActions(String roleMemberId) {
+        return getRoleService().getRoleMemberResponsibilityActions(roleMemberId);
+    }
+
+    @Override
+    public DelegateType getDelegateTypeInfo(String roleId, String delegationTypeCode) {
+        return getRoleService().getDelegateTypeInfo(roleId, delegationTypeCode);
+    }
+
+    @Override
+    public DelegateType getDelegateTypeInfoById(String delegationId) {
+        return getRoleService().getDelegateTypeInfoById(delegationId);
+    }
+
+    @Override
+    public void saveRoleRspActions(String roleResponsibilityActionId, String roleId, String roleResponsibilityId, String roleMemberId,
+                                   String actionTypeCode, String actionPolicyCode, Integer priorityNumber, Boolean forceAction) {
+        getRoleUpdateService().saveRoleRspActions(roleResponsibilityActionId, roleId, roleResponsibilityId, roleMemberId, actionTypeCode, actionPolicyCode, priorityNumber, forceAction);
+        removeCacheEntries(roleId, null);
+    }
+
+    @Override
+    public List<RoleResponsibility> getRoleResponsibilities(String roleId) {
+        return getRoleService().getRoleResponsibilities(roleId);
+    }
+
+    @Override
+    public void applicationRoleMembershipChanged(String roleId) {
+        removeCacheEntries(roleId, null);
+        getRoleService().applicationRoleMembershipChanged(roleId);
+    }
+
+    // Spring and injection methods
+
+    public RoleService getRoleService() {
+        if (roleService == null) {
+            roleService = KimApiServiceLocator.getRoleService();
+        }
+        return roleService;
+    }
+
+    public RoleUpdateService getRoleUpdateService() {
+        try {
+            if (roleUpdateService == null) {
+                roleUpdateService = KimApiServiceLocator.getRoleUpdateService();
+                if (roleUpdateService == null) {
+                    throw new UnsupportedOperationException("null returned for RoleUpdateService, unable to update role data");
+                }
+            }
+        } catch (Exception ex) {
+            throw new UnsupportedOperationException("unable to obtain a RoleUpdateService, unable to update role data", ex);
+        }
+        return roleUpdateService;
+    }
+
+    /**
+     * This overridden method looks up roles based on criteria.  If you want
+     * to return all roles pass in an empty map.
+     */
+    @Override
+    public List<Role> lookupRoles(Map<String, String> searchCriteria) {
+        return getRoleService().lookupRoles(searchCriteria);
+    }
+
+    @Override
+    public void flushInternalRoleCache() {
+        getRoleService().flushInternalRoleCache();
+    }
+
+    @Override
+    public void flushInternalRoleMemberCache() {
+        getRoleService().flushInternalRoleMemberCache();
+    }
+
+    @Override
+    public void flushInternalDelegationCache() {
+        getRoleService().flushInternalDelegationCache();
+    }
+
+    @Override
+    public void flushInternalDelegationMemberCache() {
+        getRoleService().flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void assignPermissionToRole(String permissionId, String roleId) throws UnsupportedOperationException {
+        getRoleUpdateService().assignPermissionToRole(permissionId, roleId);
+    }
+
+    @Override
+    public String getNextAvailableRoleId() throws UnsupportedOperationException {
+        return getRoleUpdateService().getNextAvailableRoleId();
+    }
+
+    @Override
+    public void saveRole(String roleId, String roleName, String roleDescription, boolean active, String kimTypeId, String namespaceCode) throws UnsupportedOperationException {
+        getRoleUpdateService().saveRole(roleId, roleName, roleDescription, active, kimTypeId, namespaceCode);
+    }
+
+    @Override
+    public List<String> getMemberParentRoleIds(String memberType,
+                                               String memberId) {
+        return getRoleService().getMemberParentRoleIds(memberType, memberId);
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java	(revision 32084)
@@ -0,0 +1,498 @@
+/*
+ * Copyright 2008-2009 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.service.impl;
+
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.apache.log4j.Logger;
+import org.kuali.rice.core.api.criteria.QueryByCriteria;
+import org.kuali.rice.kim.api.group.Group;
+import org.kuali.rice.kim.api.group.GroupService;
+import org.kuali.rice.kim.api.identity.IdentityService;
+import org.kuali.rice.kim.api.identity.Type;
+import org.kuali.rice.kim.api.identity.affiliation.EntityAffiliationType;
+import org.kuali.rice.kim.api.identity.entity.Entity;
+import org.kuali.rice.kim.api.identity.entity.EntityDefault;
+import org.kuali.rice.kim.api.identity.entity.EntityDefaultQueryResults;
+import org.kuali.rice.kim.api.identity.entity.EntityQueryResults;
+import org.kuali.rice.kim.api.identity.external.EntityExternalIdentifierType;
+import org.kuali.rice.kim.api.identity.principal.Principal;
+import org.kuali.rice.kim.api.permission.Permission;
+import org.kuali.rice.kim.api.responsibility.Responsibility;
+import org.kuali.rice.kim.api.responsibility.ResponsibilityAction;
+import org.kuali.rice.kim.api.responsibility.ResponsibilityService;
+import org.kuali.rice.kim.api.services.IdentityManagementService;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+import org.kuali.rice.kim.api.common.assignee.Assignee;
+import org.kuali.rice.kim.api.permission.PermissionService;
+import org.kuali.rice.kim.bo.role.dto.PermissionAssigneeInfo;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class IdentityManagementServiceImpl implements IdentityManagementService {
+	private static final Logger LOG = Logger.getLogger( IdentityManagementServiceImpl.class );
+
+	private PermissionService permissionService;
+	private ResponsibilityService responsibilityService;
+	private IdentityService identityService;
+	private GroupService groupService;
+
+    @Override
+	public void flushAllCaches() {
+	}
+
+    @Override
+	public void flushEntityPrincipalCaches() {
+	}
+
+    @Override
+	public void flushGroupCaches() {
+	}
+
+    @Override
+	public void flushPermissionCaches() {
+	}
+
+    @Override
+	public void flushResponsibilityCaches() {
+		// nothing currently being cached
+	}
+
+
+    // AUTHORIZATION SERVICE
+    @Override
+    public boolean hasPermission(String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails) {
+    	if ( LOG.isDebugEnabled() ) {
+    		logHasPermissionCheck("Permission", principalId, namespaceCode, permissionName, permissionDetails);
+    	}
+        boolean hasPerm = getPermissionService().hasPermission(principalId, namespaceCode, permissionName, permissionDetails);
+        if ( LOG.isDebugEnabled() ) {
+            LOG.debug( "Result: " + hasPerm );
+        }
+    	return hasPerm;
+    }
+
+    @Override
+    public boolean isAuthorized(String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification ) {
+    	if ( qualification == null || qualification.isEmpty() ) {
+    		return hasPermission( principalId, namespaceCode, permissionName, permissionDetails );
+    	}
+    	if ( LOG.isDebugEnabled() ) {
+    		logAuthorizationCheck("Permission", principalId, namespaceCode, permissionName, permissionDetails, qualification);
+    	}
+        boolean isAuthorized = getPermissionService().isAuthorized(principalId, namespaceCode, permissionName, permissionDetails, qualification);
+    	if ( LOG.isDebugEnabled() ) {
+    		LOG.debug( "Result: " + isAuthorized );
+    	}
+    	return isAuthorized;
+    }
+
+    @Override
+    public boolean hasPermissionByTemplateName(String principalId, String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails) {
+    	if ( LOG.isDebugEnabled() ) {
+    		logHasPermissionCheck("Perm Templ", principalId, namespaceCode, permissionTemplateName, permissionDetails);
+    	}
+
+		boolean hasPerm = getPermissionService().hasPermissionByTemplateName(principalId, namespaceCode, permissionTemplateName, permissionDetails);
+
+   		if ( LOG.isDebugEnabled() ) {
+   			LOG.debug( "Result: " + hasPerm );
+   		}
+    	return hasPerm;
+    }
+
+    @Override
+    public boolean isAuthorizedByTemplateName(String principalId, String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails, Map<String, String> qualification ) {
+    	if ( qualification == null || qualification.isEmpty() ) {
+    		return hasPermissionByTemplateName( principalId, namespaceCode, permissionTemplateName, new HashMap<String, String>(permissionDetails) );
+    	}
+    	if ( LOG.isDebugEnabled() ) {
+    		logAuthorizationCheck("Perm Templ", principalId, namespaceCode, permissionTemplateName, new HashMap<String, String>(permissionDetails), new HashMap<String, String>(qualification));
+    	}
+    	boolean isAuthorized = getPermissionService().isAuthorizedByTemplateName( principalId, namespaceCode, permissionTemplateName, new HashMap<String, String>(permissionDetails), new HashMap<String, String>(qualification) );
+   		if ( LOG.isDebugEnabled() ) {
+   			LOG.debug( "Result: " + isAuthorized );
+   		}
+    	return isAuthorized;
+    }
+
+    @Override
+    public List<Permission> getAuthorizedPermissions(String principalId,
+                                                     String namespaceCode, String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification) {
+    	return getPermissionService().getAuthorizedPermissions(principalId, namespaceCode, permissionName, permissionDetails, qualification);
+    }
+
+    @Override
+    public List<Permission> getAuthorizedPermissionsByTemplateName(String principalId,
+                                                                   String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails, Map<String, String> qualification) {
+    	return getPermissionService().getAuthorizedPermissionsByTemplateName(principalId, namespaceCode, permissionTemplateName, permissionDetails, qualification);
+    }
+
+    @Override
+    public boolean isPermissionDefinedForTemplateName(String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails) {
+        return getPermissionService().isPermissionDefinedForTemplateName(namespaceCode, permissionTemplateName, permissionDetails);
+    }
+
+    @Override
+	public List<Assignee> getPermissionAssignees(String namespaceCode,
+			String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification) {
+		return this.permissionService.getPermissionAssignees(namespaceCode, permissionName,
+                permissionDetails, qualification);
+	}
+
+    @Override
+	public List<Assignee> getPermissionAssigneesForTemplateName(String namespaceCode,
+			String permissionTemplateName, Map<String, String> permissionDetails,
+			Map<String, String> qualification) {
+		return this.permissionService.getPermissionAssigneesForTemplateName( namespaceCode,
+				permissionTemplateName, new HashMap<String, String>(permissionDetails), new HashMap<String, String>(qualification) );
+	}
+
+    // GROUP SERVICE
+    @Override
+	public boolean isMemberOfGroup(String principalId, String groupId) {
+		return getGroupService().isMemberOfGroup(principalId, groupId);
+	}
+    @Override
+	public boolean isMemberOfGroup(String principalId, String namespaceCode, String groupName) {
+		Group group = getGroupByName(namespaceCode, groupName);
+		return group == null ? false : isMemberOfGroup(principalId, group.getId());
+    }
+    @Override
+	public boolean isGroupMemberOfGroup(String potentialMemberId, String potentialParentId)
+	{
+	       return getGroupService()
+	                .isGroupMemberOfGroup(potentialMemberId, potentialParentId);
+	}
+    @Override
+	public List<String> getGroupMemberPrincipalIds(String groupId) {
+		return getGroupService().getMemberPrincipalIds(groupId);
+	}
+    @Override
+	public List<String> getDirectGroupMemberPrincipalIds(String groupId) {
+		return getGroupService().getDirectMemberPrincipalIds(groupId);
+	}
+    @Override
+    public List<String> getGroupIdsForPrincipal(String principalId) {
+		return getGroupService().getGroupIdsForPrincipal(principalId);
+	}
+    @Override
+    public List<String> getGroupIdsForPrincipal(String principalId, String namespaceCode ) {
+		return getGroupService().getGroupIdsForPrincipalByNamespace(principalId, namespaceCode );
+	}
+    @Override
+    public List<Group> getGroupsForPrincipal(String principalId) {
+		return getGroupService().getGroupsForPrincipal(principalId);
+	}
+    @Override
+    public List<Group> getGroupsForPrincipal(String principalId, String namespaceCode ) {
+		return getGroupService().getGroupsForPrincipalByNamespace(principalId, namespaceCode );
+	}
+    @Override
+    public List<String> getMemberGroupIds(String groupId) {
+		return getGroupService().getMemberGroupIds(groupId);
+	}
+    @Override
+    public List<String> getDirectMemberGroupIds(String groupId) {
+		return getGroupService().getDirectMemberGroupIds(groupId);
+	}
+    @Override
+    public Group getGroup(String groupId) {
+		return getGroupService().getGroup(groupId);
+	}
+    @Override
+    public Group getGroupByName(String namespaceCode, String groupName) {
+		return getGroupService().getGroupByName( namespaceCode, groupName );
+    }
+    @Override
+    public List<String> getParentGroupIds(String groupId) {
+		return getGroupService().getParentGroupIds(groupId);
+	}
+    @Override
+    public List<String> getDirectParentGroupIds(String groupId) {
+		return getGroupService().getDirectParentGroupIds( groupId );
+	}
+
+    @Override
+    public boolean addGroupToGroup(String childId, String parentId) {
+        return getGroupService().addGroupToGroup(childId, parentId);
+    }
+
+    @Override
+    public boolean addPrincipalToGroup(String principalId, String groupId) {
+        return getGroupService().addPrincipalToGroup(principalId, groupId);
+    }
+
+    @Override
+    public boolean removeGroupFromGroup(String childId, String parentId) {
+        return getGroupService().removeGroupFromGroup(childId, parentId);
+    }
+
+    @Override
+    public boolean removePrincipalFromGroup(String principalId, String groupId) {
+        return getGroupService().removePrincipalFromGroup(principalId, groupId);
+    }
+
+    @Override
+	public Group createGroup(Group group) {
+		return getGroupService().createGroup(group);
+	}
+
+    @Override
+	public void removeAllMembers(String groupId) {
+		getGroupService().removeAllMembers(groupId);
+	}
+
+    @Override
+	public Group updateGroup(String groupId, Group group) {
+		return getGroupService().updateGroup(groupId, group);
+	}
+
+
+    // IDENTITY SERVICE
+    @Override
+	public Principal getPrincipal(String principalId) {
+		return getIdentityService().getPrincipal(principalId);
+	}
+
+    @Override
+    public Principal getPrincipalByPrincipalName(String principalName) {
+		return getIdentityService().getPrincipalByPrincipalName(principalName);
+    }
+
+    @Override
+    public Principal getPrincipalByPrincipalNameAndPassword(String principalName, String password) {
+    	return getIdentityService().getPrincipalByPrincipalNameAndPassword(principalName, password);
+    }
+
+    @Override
+    public EntityDefault getEntityDefaultInfo(String entityId) {
+    		return getIdentityService().getEntityDefault(entityId);
+    }
+
+    @Override
+    public EntityDefault getEntityDefaultInfoByPrincipalId(
+    		String principalId) {
+	    	return getIdentityService().getEntityDefaultByPrincipalId(principalId);
+    }
+
+    @Override
+    public EntityDefault getEntityDefaultInfoByPrincipalName(
+    		String principalName) {
+	    	return getIdentityService().getEntityDefaultByPrincipalName(principalName);
+    }
+
+    @Override
+    public EntityDefaultQueryResults findEntityDefaults(QueryByCriteria queryByCriteria) {
+        return getIdentityService().findEntityDefaults(queryByCriteria);
+    }
+
+    @Override
+	public Entity getEntity(String entityId) {
+    		return getIdentityService().getEntity(entityId);
+	}
+
+    @Override
+    public Entity getEntityByPrincipalId(String principalId) {
+        return getIdentityService().getEntityByPrincipalId(principalId);
+    }
+
+    @Override
+    public Entity getEntityByPrincipalName(String principalName) {
+        return getIdentityService().getEntityByPrincipalName(principalName);
+    }
+
+    @Override
+    public EntityQueryResults findEntities(QueryByCriteria queryByCriteria) {
+        return getIdentityService().findEntities(queryByCriteria);
+    }
+
+    @Override
+	public Type getAddressType( String code ) {
+		return getIdentityService().getAddressType(code);
+	}
+
+    @Override
+    public Type getEmailType( String code ) {
+		return getIdentityService().getEmailType(code);
+	}
+
+    @Override
+	public EntityAffiliationType getAffiliationType( String code ) {
+			return getIdentityService().getAffiliationType(code);
+	}
+
+    @Override
+	public Type getCitizenshipStatus( String code ) {
+			return Type.Builder.create(getIdentityService().getCitizenshipStatus(code)).build();
+	}
+    @Override
+	public Type getEmploymentStatus( String code ) {
+			return getIdentityService().getEmploymentStatus(code);
+	}
+    @Override
+	public Type getEmploymentType( String code ) {
+			return getIdentityService().getEmploymentType(code);
+	}
+    @Override
+	public Type getEntityNameType( String code ) {
+			return getIdentityService().getNameType(code);
+	}
+    @Override
+	public Type getEntityType( String code ) {
+		return getIdentityService().getEntityType(code);
+	}
+    @Override
+	public EntityExternalIdentifierType getExternalIdentifierType( String code ) {
+			return getIdentityService().getExternalIdentifierType(code);
+	}
+    @Override
+	public Type getPhoneType( String code ) {
+			return getIdentityService().getPhoneType(code);
+	}
+
+    // ----------------------
+    // Responsibility Methods
+    // ----------------------
+
+    @Override
+	public Responsibility getResponsibility(String responsibilityId) {
+		return getResponsibilityService().getResponsibility( responsibilityId );
+	}
+
+    @Override
+	public boolean hasResponsibility(String principalId, String namespaceCode,
+			String responsibilityName, Map<String, String> qualification,
+			Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().hasResponsibility( principalId, namespaceCode, responsibilityName,
+                qualification, responsibilityDetails );
+	}
+
+    @Override
+	public Responsibility getResponsibilityByName( String namespaceCode, String responsibilityName) {
+		return getResponsibilityService().findRespByNamespaceCodeAndName(namespaceCode, responsibilityName);
+	}
+
+    @Override
+	public List<ResponsibilityAction> getResponsibilityActions( String namespaceCode, String responsibilityName,
+    		Map<String, String> qualification, Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().getResponsibilityActions( namespaceCode, responsibilityName, qualification,
+                responsibilityDetails );
+	}
+
+    @Override
+	public List<ResponsibilityAction> getResponsibilityActionsByTemplateName(
+			String namespaceCode, String responsibilityTemplateName,
+			Map<String, String> qualification, Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().getResponsibilityActionsByTemplateName(namespaceCode, responsibilityTemplateName,
+                qualification, responsibilityDetails);
+	}
+
+    @Override
+	public boolean hasResponsibilityByTemplateName(String principalId,
+			String namespaceCode, String responsibilityTemplateName,
+			Map<String, String> qualification, Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().hasResponsibilityByTemplateName(principalId, namespaceCode, responsibilityTemplateName,
+                qualification, responsibilityDetails);
+	}
+
+    protected void logAuthorizationCheck(String checkType, String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification ) {
+		StringBuilder sb = new StringBuilder();
+		sb.append(  '\n' );
+		sb.append( "Is AuthZ for " ).append( checkType ).append( ": " ).append( namespaceCode ).append( "/" ).append( permissionName ).append( '\n' );
+		sb.append( "             Principal:  " ).append( principalId );
+		if ( principalId != null ) {
+			Principal principal = getPrincipal( principalId );
+			if ( principal != null ) {
+				sb.append( " (" ).append( principal.getPrincipalName() ).append( ')' );
+			}
+		}
+		sb.append( '\n' );
+		sb.append( "             Details:\n" );
+		if ( permissionDetails != null ) {
+			sb.append( permissionDetails);
+		} else {
+			sb.append( "                         [null]\n" );
+		}
+		sb.append( "             Qualifiers:\n" );
+		if ( qualification != null && !qualification.isEmpty() ) {
+			sb.append( qualification);
+		} else {
+			sb.append( "                         [null]\n" );
+		}
+		if (LOG.isTraceEnabled()) {
+			LOG.trace( sb.append(ExceptionUtils.getStackTrace(new Throwable())));
+		} else {
+			LOG.debug(sb.toString());
+		}
+    }
+
+    protected void logHasPermissionCheck(String checkType, String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails ) {
+		StringBuilder sb = new StringBuilder();
+		sb.append(  '\n' );
+		sb.append( "Has Perm for " ).append( checkType ).append( ": " ).append( namespaceCode ).append( "/" ).append( permissionName ).append( '\n' );
+		sb.append( "             Principal:  " ).append( principalId );
+		if ( principalId != null ) {
+			Principal principal = getPrincipal( principalId );
+			if ( principal != null ) {
+				sb.append( " (" ).append( principal.getPrincipalName() ).append( ')' );
+			}
+		}
+		sb.append(  '\n' );
+		sb.append( "             Details:\n" );
+		if ( permissionDetails != null ) {
+			sb.append( permissionDetails);
+		} else {
+			sb.append( "                         [null]\n" );
+		}
+		if (LOG.isTraceEnabled()) {
+			LOG.trace( sb.append( ExceptionUtils.getStackTrace(new Throwable())) );
+		} else {
+			LOG.debug(sb.toString());
+		}
+    }
+
+    	// OTHER METHODS
+
+	public IdentityService getIdentityService() {
+		if ( identityService == null ) {
+			identityService = KimApiServiceLocator.getIdentityService();
+		}
+		return identityService;
+	}
+
+	public GroupService getGroupService() {
+		if ( groupService == null ) {
+			groupService = KimApiServiceLocator.getGroupService();
+		}
+		return groupService;
+	}
+
+	public PermissionService getPermissionService() {
+		if ( permissionService == null ) {
+			permissionService = KimApiServiceLocator.getPermissionService();
+		}
+		return permissionService;
+	}
+
+	public ResponsibilityService getResponsibilityService() {
+		if ( responsibilityService == null ) {
+			responsibilityService = KimApiServiceLocator.getResponsibilityService();
+		}
+		return responsibilityService;
+	}
+}

Property changes on: work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java	(revision 32084)
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.List;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+
+import org.kuali.rice.core.impl.jaxb.DataXmlDTO;
+
+/**
+ * Helper class for importing and exporting KIM XML.
+ * 
+ * <p>TODO: Should this be converted into a service instead?
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class KimXmlUtil {
+    // Do not allow outside code to instantiate this class.
+    private KimXmlUtil() {}
+    
+    /**
+     * Parses permissions and/or roles from XML.
+     * 
+     * @param inputStream The input stream to read the XML from.
+     */
+    public static void parseKimXml(InputStream inputStream) {
+        try {
+            JAXBContext jaxbContext = JAXBContext.newInstance(DataXmlDTO.class);
+            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
+            unmarshaller.unmarshal(inputStream);
+        } catch (JAXBException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    
+    /**
+     * Exports one or more sets of KIM objects to XML.
+     * 
+     * @param outputStream The output stream to write the XML to.
+     * @param permissions The KIM permissions to export; set to a null or empty list to prevent exportation of a &lt;permissionData&gt; element.
+     * @param roles The KIM roles to export; set to a null or empty list to prevent exportation of a &lt;roleData&gt; element.
+     */
+    public static void exportKimXml(OutputStream outputStream, List<? extends Object> permissions, List<? extends Object> roles) {
+        PermissionDataXmlDTO permissionData = (permissions != null && !permissions.isEmpty()) ?
+                new PermissionDataXmlDTO(new PermissionsXmlDTO(permissions)) : null;
+        RoleDataXmlDTO roleData = (roles != null && !roles.isEmpty()) ?
+                new RoleDataXmlDTO(new RolesXmlDTO(roles)) : null;
+        try {
+            JAXBContext jaxbContext = JAXBContext.newInstance(DataXmlDTO.class);
+            Marshaller marshaller = jaxbContext.createMarshaller();
+            marshaller.marshal(new DataXmlDTO(permissionData, roleData), outputStream);
+        } catch (JAXBException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java	(revision 32084)
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.core.util.jaxb.StringTrimmingAdapter;
+import org.kuali.rice.kim.api.jaxb.NameAndNamespacePairToPermTemplateIdAdapter;
+import org.kuali.rice.kim.api.jaxb.PermissionDetailListAdapter;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This class represents a &lt;permission&gt; XML element.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionType", propOrder={
+        "permissionNameAndNamespace", "permissionTemplateId", "permissionDescription", "active", "permissionDetails"
+})
+public class PermissionXmlDTO implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+
+    @XmlTransient
+    private String permissionId;
+    
+    @XmlElement(name="permissionName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair permissionNameAndNamespace;
+    
+    @XmlElement(name="templateName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairToPermTemplateIdAdapter.class)
+    private String permissionTemplateId;
+    
+    @XmlElement(name="description")
+    @XmlJavaTypeAdapter(StringTrimmingAdapter.class)
+    private String permissionDescription;
+    
+    @XmlElement(name="active")
+    private Boolean active;
+    
+    @XmlElement(name="permissionDetails")
+    @XmlJavaTypeAdapter(PermissionDetailListAdapter.class)
+    private Map<String, String> permissionDetails;
+    
+    public PermissionXmlDTO() {
+        this.active = Boolean.TRUE;
+    }
+    
+    public PermissionXmlDTO(PermissionContract permission) {
+        this.permissionNameAndNamespace = new NameAndNamespacePair(permission.getNamespaceCode(), permission.getName());
+        this.permissionTemplateId = permission.getTemplate().getId();
+        this.permissionDescription = permission.getDescription();
+        this.active = Boolean.valueOf(permission.isActive());
+        this.permissionDetails = (permission.getAttributes() != null) ?
+                new HashMap<String, String>(permission.getAttributes()) : new HashMap<String, String>();
+    }
+    
+    /**
+     * @return the permissionId
+     */
+    public String getPermissionId() {
+        return this.permissionId;
+    }
+
+    /**
+     * @param permissionId the permissionId to set
+     */
+    public void setPermissionId(String permissionId) {
+        this.permissionId = permissionId;
+    }
+
+    /**
+     * @return the permissionNameAndNamespace
+     */
+    public NameAndNamespacePair getPermissionNameAndNamespace() {
+        return this.permissionNameAndNamespace;
+    }
+
+    /**
+     * @param permissionNameAndNamespace the permissionNameAndNamespace to set
+     */
+    public void setPermissionNameAndNamespace(NameAndNamespacePair permissionNameAndNamespace) {
+        this.permissionNameAndNamespace = permissionNameAndNamespace;
+    }
+
+    /**
+     * @return the permissionTemplateId
+     */
+    public String getPermissionTemplateId() {
+        return this.permissionTemplateId;
+    }
+
+    /**
+     * @param permissionTemplateId the permissionTemplateId to set
+     */
+    public void setPermissionTemplateId(String permissionTemplateId) {
+        this.permissionTemplateId = permissionTemplateId;
+    }
+
+    /**
+     * @return the permissionDescription
+     */
+    public String getPermissionDescription() {
+        return this.permissionDescription;
+    }
+
+    /**
+     * @param permissionDescription the permissionDescription to set
+     */
+    public void setPermissionDescription(String permissionDescription) {
+        this.permissionDescription = permissionDescription;
+    }
+
+    /**
+     * @return the active
+     */
+    public Boolean getActive() {
+        return this.active;
+    }
+
+    /**
+     * @param active the active to set
+     */
+    public void setActive(Boolean active) {
+        this.active = active;
+    }
+
+    /**
+     * @return the permissionDetails
+     */
+    public Map<String, String> getPermissionDetails() {
+        return this.permissionDetails;
+    }
+
+    /**
+     * @param permissionDetails the permissionDetails to set
+     */
+    public void setPermissionDetails(Map<String, String> permissionDetails) {
+        this.permissionDetails = permissionDetails;
+    }
+
+    /**
+     * Retrieves the permission's name from the permission-name-and-namespace combo.
+     * 
+     * @return The name of the permission, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getPermissionName() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getName() : null;
+    }
+
+    /**
+     * Retrieves the permission's namespace code from the permission-name-and-namespace combo.
+     * 
+     * @return The namespace code of the permission, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getNamespaceCode() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getNamespaceCode() : null;
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java	(revision 32084)
@@ -0,0 +1,394 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.kim.api.group.GroupContract;
+import org.kuali.rice.kim.api.identity.principal.PrincipalContract;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.kim.api.role.RoleMemberContract;
+import org.kuali.rice.kim.api.role.RoleService;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+import org.kuali.rice.kim.util.KimConstants.KimUIConstants;
+
+import javax.xml.bind.UnmarshalException;
+import java.sql.Date;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Helper class containing static methods for aiding in parsing role XML.
+ * 
+ * <p>All non-private methods are package-private so that only the KIM-parsing-related code can make use of them. (TODO: Is that necessary?)
+ * 
+ * <p>TODO: Should this be converted into a service instead?
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class RoleXmlUtil {
+    // Do not allow outside code to instantiate this class.
+    private RoleXmlUtil() {}
+
+    /**
+     * Performs the necessary validation on the new role, then saves it.
+     * 
+     * @param newRole The role to persist.
+     * @return The ID of the persisted role.
+     * @throws IllegalArgumentException if newRole is null.
+     * @throws UnmarshalException if newRole contains invalid data.
+     */
+    static String validateAndPersistNewRole(RoleXmlDTO newRole) throws UnmarshalException {
+        if (newRole == null) {
+            throw new IllegalArgumentException("Cannot persist a null role");
+        }
+        
+        // Validate the role and (if applicable) retrieve the ID from an existing matching role.
+        validateAndPrepareRole(newRole);
+        
+        // If necessary, assign a new role ID.
+        if (StringUtils.isBlank(newRole.getRoleId())) {
+            newRole.setRoleId(KimApiServiceLocator.getRoleService().getNextAvailableRoleId());
+        }
+        
+        // Save the role.
+        KimApiServiceLocator.getRoleService().saveRole(newRole.getRoleId(), newRole.getRoleName(), newRole.getRoleDescription(), newRole.getActive().booleanValue(),
+                newRole.getKimTypeId(), newRole.getNamespaceCode());
+        
+        // Set a flag on the role to indicate that it has now been persisted so that the unmarshalling process will not save this role more than once.
+        newRole.setAlreadyPersisted(true);
+        
+        return newRole.getRoleId();
+    }
+    
+    /**
+     * Performs the necessary validation on the new role member, then saves it.
+     * 
+     * @param newRoleMember The role member to save.
+     * @return The ID of the persisted role member.
+     * @throws IllegalArgumentException if newRoleMember is null.
+     * @throws UnmarshalException if newRoleMember contains invalid data.
+     */
+    static String validateAndPersistNewRoleMember(RoleMemberXmlDTO newRoleMember) throws UnmarshalException {
+        
+        if (newRoleMember == null) {
+            throw new IllegalArgumentException("Cannot persist a null role member");
+        }
+        
+        // Validate role ID and role name/namespace.
+        validateRoleIdAndRoleNameForMember(newRoleMember);
+        
+        // Validate member type, member ID, and member name/namespace.
+        validateMemberIdentity(newRoleMember);
+        
+        // Validate the from/to dates, if defined.
+        if (newRoleMember.getActiveFromDate() != null && newRoleMember.getActiveToDate() != null &&
+                newRoleMember.getActiveFromDate().compareTo(newRoleMember.getActiveToDate()) > 0) {
+            throw new UnmarshalException("Cannot create a role member whose activeFromDate occurs after its activeToDate");
+        }
+        
+        // Define defaults as needed.
+        if (newRoleMember.getQualifications() == null) {
+            newRoleMember.setQualifications(new HashMap<String, String>());
+        }
+        
+        // Save the role member.
+        RoleMemberContract newMember = KimApiServiceLocator.getRoleService().saveRoleMemberForRole(
+                null, newRoleMember.getMemberId(), newRoleMember.getMemberTypeCode(),
+                        newRoleMember.getRoleId(), newRoleMember.getQualifications(),
+                                (newRoleMember.getActiveFromDate() != null) ? new Date(newRoleMember.getActiveFromDate().getMillis()) : null,
+                                (newRoleMember.getActiveToDate() != null) ? new Date(newRoleMember.getActiveToDate().getMillis()) : null);
+        
+        return newMember.getRoleMemberId();
+    }
+    
+    /**
+     * Performs the necessary validation on the role permission, then saves it.
+     * 
+     * @param newRolePermission The role permission to save.
+     * @throws IllegalArgumentException if newRolePermission is null
+     * @throws UnmarshalException if newRolePermission contains invalid data.
+     */
+    static void validateAndPersistNewRolePermission(RolePermissionXmlDTO newRolePermission) throws UnmarshalException {
+        if (newRolePermission == null) {
+            throw new IllegalArgumentException("newRolePermission cannot be null");
+        }
+        
+        // Validate the role permission, and prepare its role ID if necessary.
+        validateAndPrepareRolePermission(newRolePermission);
+        
+        // Save the role permission.
+        KimApiServiceLocator.getRoleService().assignPermissionToRole(newRolePermission.getPermissionId(), newRolePermission.getRoleId());
+    }
+    
+    /**
+     * Removes any role members for a given role whose IDs are not listed in a given role member ID set.
+     * 
+     * @param roleId The ID of the role containing the role members.
+     * @param existingRoleMemberIds The IDs of the role members that should not be removed.
+     * @throws IllegalArgumentException if roleId is blank or refers to a non-existent role, or if existingRoleMemberIds is null.
+     */
+    static void removeRoleMembers(String roleId, Set<String> existingRoleMemberIds) {
+        if (StringUtils.isBlank(roleId)) {
+            throw new IllegalArgumentException("roleId cannot be blank");
+        } else if (existingRoleMemberIds == null) {
+            throw new IllegalArgumentException("existingRoleMemberIds cannot be null");
+        }
+        RoleService roleUpdateService = KimApiServiceLocator.getRoleService();
+        RoleContract role = KimApiServiceLocator.getRoleService().getRole(roleId);
+        if (role == null) {
+            throw new IllegalArgumentException("Cannot remove role members for role with ID \"" + roleId + "\" because that role does not exist");
+        }
+        
+        // Remove any role members whose IDs are not in the set.
+        List<? extends RoleMemberContract> roleMembers = KimApiServiceLocator.getRoleService().findRoleMembers(Collections.singletonMap("roleId", roleId));
+        if (roleMembers != null && !roleMembers.isEmpty()) {
+            for (RoleMemberContract roleMember : roleMembers) {
+                if (!existingRoleMemberIds.contains(roleMember.getRoleMemberId())) {
+                    // If the role member needs to be removed, use the member type code to determine which removal method to call.
+                    String memberTypeCode = roleMember.getMemberTypeCode();
+                    if (KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE.equals(memberTypeCode)) {
+                        roleUpdateService.removePrincipalFromRole(roleMember.getMemberId(), role.getNamespaceCode(), role.getName(),
+                                (roleMember.getAttributes() != null) ? roleMember.getAttributes() : new HashMap<String, String>());
+                    } else if (KimUIConstants.MEMBER_TYPE_GROUP_CODE.equals(memberTypeCode)) {
+                        roleUpdateService.removeGroupFromRole(roleMember.getMemberId(), role.getNamespaceCode(), role.getName(),
+                                (roleMember.getAttributes() != null) ? roleMember.getAttributes() :new HashMap<String, String>());
+                    } else if (KimUIConstants.MEMBER_TYPE_ROLE_CODE.equals(memberTypeCode)) {
+                        roleUpdateService.removeRoleFromRole(roleMember.getMemberId(), role.getNamespaceCode(), role.getName(),
+                                (roleMember.getAttributes() != null) ? roleMember.getAttributes() : new HashMap<String, String>());
+                    }
+                }
+            }
+        }
+    }
+    
+    /**
+     * Validates a new role's name, namespace, KIM type, and description, and sets the role's ID if the name and namespace match an existing role.
+     */
+    private static void validateAndPrepareRole(RoleXmlDTO newRole) throws UnmarshalException {
+        // Ensure that the role name, role namespace, KIM type, and description have all been specified.
+        if (StringUtils.isBlank(newRole.getRoleName()) || StringUtils.isBlank(newRole.getNamespaceCode())) {
+            throw new UnmarshalException("Cannot create or override a role with a blank name or a blank namespace");
+        } else if (StringUtils.isBlank(newRole.getKimTypeId())) {
+            throw new UnmarshalException("Cannot create or override a role without specikfying a KIM type");
+        } else if (StringUtils.isBlank(newRole.getRoleDescription())) {
+            throw new UnmarshalException("Cannot create or override a role with a blank description");
+        }
+        
+        // Attempt to find an existing matching role, and assign its ID to the validated role if it exists.
+        String matchingId = KimApiServiceLocator.getRoleService().getRoleIdByName(newRole.getNamespaceCode(), newRole.getRoleName());
+        if (StringUtils.isNotBlank(matchingId)) {
+            newRole.setRoleId(matchingId);
+        }
+    }
+    
+    /**
+     * Validates a new role member's role ID, role name, and role namespace.
+     */
+    private static void validateRoleIdAndRoleNameForMember(RoleMemberXmlDTO newRoleMember) throws UnmarshalException {
+        // If the "roleMember" tag was not a descendant of a "role" tag, derive and validate its role information accordingly.
+        if (newRoleMember instanceof RoleMemberXmlDTO.OutsideOfRole) {
+            RoleMemberXmlDTO.OutsideOfRole standaloneMember = (RoleMemberXmlDTO.OutsideOfRole) newRoleMember;
+            if (standaloneMember.getRoleNameAndNamespace() != null) {
+                // If a name + namespace combo is given, verify that the combo maps to an existing role.
+                String existingId = KimApiServiceLocator.getRoleService().getRoleIdByName(standaloneMember.getRoleNamespaceCode(), standaloneMember.getRoleName());
+                if (StringUtils.isBlank(existingId)) {
+                    throw new UnmarshalException("Cannot create role member for role with name \"" + standaloneMember.getRoleName() + "\" and namespace \"" +
+                            standaloneMember.getRoleNamespaceCode() + "\" because such a role does not exist");
+                }
+                
+                // If the role member defines its own role ID, verify that it's the same as the one from the existing role; otherwise, assign the member's role ID.
+                if (StringUtils.isBlank(standaloneMember.getRoleId())) {
+                    standaloneMember.setRoleId(existingId);
+                } else if (!standaloneMember.getRoleId().equals(existingId)) {
+                    throw new UnmarshalException("Cannot create role member for role with ID \"" + standaloneMember.getRoleId() + "\", name \"" +
+                            standaloneMember.getRoleName() + "\", and namespace \"" + standaloneMember.getRoleNamespaceCode() +
+                                    "\" because the existing role with the same name and namespace has an ID of \"" + existingId + "\" instead");
+                }
+            } else if (StringUtils.isBlank(standaloneMember.getRoleId())) {
+                throw new UnmarshalException("Cannot create role member without providing the role ID or role name + namespace that the member belongs to");
+            } else if (KimApiServiceLocator.getRoleService().getRole(standaloneMember.getRoleId()) == null) {
+                throw new UnmarshalException("Cannot create role member for the role with ID \"" + standaloneMember.getRoleId() + "\" because that role does not exist");
+            }
+        }
+        
+        // Ensure that a role ID was explicitly defined or was derived from a name + namespace combo.
+        if (StringUtils.isBlank(newRoleMember.getRoleId())) {
+            throw new UnmarshalException("Cannot create role member without providing the role ID or role name + namespace that the member belongs to");
+        }
+    }
+    
+    /**
+     * Validates a new role member's member type, member ID, member name, and (if applicable) member namespace code.
+     */
+    private static void validateMemberIdentity(RoleMemberXmlDTO newRoleMember) throws UnmarshalException {
+        // Ensure that sufficient and non-conflicting membership info has been set. (The getMemberTypeCode() method performs such validation.)
+        String memberTypeCode = newRoleMember.getMemberTypeCode();
+        if (StringUtils.isBlank(memberTypeCode)) {
+            throw new UnmarshalException("Cannot create a role member with no member principal/group/role identification information specified");
+        }
+        
+        // Ensure that a valid member ID was specified, if present.
+        if (StringUtils.isNotBlank(newRoleMember.getMemberId())) {
+            if (KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE.equals(memberTypeCode)) {
+                // If the member is a principal, ensure that the principal exists.
+                if (KimApiServiceLocator.getIdentityService().getPrincipal(newRoleMember.getPrincipalId()) == null) {
+                    throw new UnmarshalException("Cannot create principal role member with principal ID \"" +
+                            newRoleMember.getPrincipalId() + "\" because such a person does not exist");
+                }
+            } else if (KimUIConstants.MEMBER_TYPE_GROUP_CODE.equals(memberTypeCode)) {
+                // If the member is a group, ensure that the group exists.
+                if (KimApiServiceLocator.getGroupService().getGroup(newRoleMember.getGroupId()) == null) {
+                    throw new UnmarshalException("Cannot create group role member with group ID \"" +
+                            newRoleMember.getGroupId() + "\" because such a group does not exist");
+                }
+            } else if (KimUIConstants.MEMBER_TYPE_ROLE_CODE.equals(memberTypeCode)) {
+                // If the member is another role, ensure that the role exists and that the role is not trying to become a member of itself.
+                if (newRoleMember.getRoleId().equals(newRoleMember.getRoleIdAsMember())) {
+                    throw new UnmarshalException("The role with ID \"" + newRoleMember.getRoleIdAsMember() + "\" cannot be made a member of itself");
+                } else if (KimApiServiceLocator.getRoleService().getRole(newRoleMember.getRoleIdAsMember()) == null) {
+                    throw new UnmarshalException("Cannot use role with ID \"" + newRoleMember.getRoleIdAsMember() +
+                            "\" as a role member because such a role does not exist");
+                }
+            }
+        }
+        
+        // Ensure that a valid member name (and namespace, if applicable) was specified, if present.
+        if (StringUtils.isNotBlank(newRoleMember.getMemberName())) {
+            if (KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE.equals(memberTypeCode)) {
+                //If the member is a principal, ensure that the principal exists and does not conflict with any existing principal ID information.
+                PrincipalContract tempPrincipal = KimApiServiceLocator.getIdentityService().getPrincipalByPrincipalName(newRoleMember.getPrincipalName());
+                if (tempPrincipal == null) {
+                    throw new UnmarshalException("Cannot create principal role member with principal name \"" +
+                            newRoleMember.getPrincipalName() + "\" because such a person does not exist");
+                } else if (StringUtils.isBlank(newRoleMember.getPrincipalId())) {
+                    // If no principal ID was given, assign one from the retrieved principal.
+                    newRoleMember.setPrincipalId(tempPrincipal.getPrincipalId());
+                } else if (!newRoleMember.getPrincipalId().equals(tempPrincipal.getPrincipalId())) {
+                    throw new UnmarshalException("Cannot create principal role member with principal ID \"" + newRoleMember.getPrincipalId() +
+                            "\" and principal name \"" + newRoleMember.getPrincipalName() + "\" because the principal with that name has an ID of \"" +
+                                    tempPrincipal.getPrincipalId() + "\" instead");
+                }
+            } else if (KimUIConstants.MEMBER_TYPE_GROUP_CODE.equals(memberTypeCode)) {
+                // If the member is a group, ensure that the group exists and does not conflict with any existing group ID information.
+                NameAndNamespacePair groupNameAndNamespace = newRoleMember.getGroupName();
+                GroupContract tempGroup = KimApiServiceLocator.getGroupService().getGroupByName(
+                        groupNameAndNamespace.getNamespaceCode(), groupNameAndNamespace.getName());
+                if (tempGroup == null) {
+                    throw new UnmarshalException("Cannot create group role member with namespace \"" + groupNameAndNamespace.getNamespaceCode() +
+                            "\" and name \"" + groupNameAndNamespace.getName() + "\" because such a group does not exist");
+                } else if (StringUtils.isBlank(newRoleMember.getGroupId())) {
+                    // If no group ID was given, assign one from the retrieved group.
+                    newRoleMember.setGroupId(tempGroup.getId());
+                } else if (!newRoleMember.getGroupId().equals(tempGroup.getId())) {
+                    throw new UnmarshalException("Cannot create group role member with ID \"" + newRoleMember.getGroupId() + "\", namespace \"" +
+                            groupNameAndNamespace.getNamespaceCode() + "\", and name \"" + groupNameAndNamespace.getName() +
+                                    "\" because the group with that namespace and name has an ID of \"" + tempGroup.getId() + "\" instead");
+                }
+            } else if (KimUIConstants.MEMBER_TYPE_ROLE_CODE.equals(memberTypeCode)) {
+                // If the member is another role, ensure that the role exists, does not conflict with any existing role ID information, and is not the member's role.
+                NameAndNamespacePair roleNameAndNamespace = newRoleMember.getRoleNameAsMember();
+                RoleContract tempRole = KimApiServiceLocator.getRoleService().getRoleByName(
+                        roleNameAndNamespace.getNamespaceCode(), roleNameAndNamespace.getName());
+                if (tempRole == null) {
+                    throw new UnmarshalException("Cannot use role with namespace \"" + roleNameAndNamespace.getNamespaceCode() +
+                            "\" and name \"" + roleNameAndNamespace.getName() + "\" as a role member because such a role does not exist");
+                } else if (newRoleMember.getRoleId().equals(tempRole.getId())) {
+                    throw new UnmarshalException("The role with namespace \"" + roleNameAndNamespace.getNamespaceCode() +
+                            "\" and name \"" + roleNameAndNamespace.getName() + "\" cannot be made a member of itself");
+                } else if (StringUtils.isBlank(newRoleMember.getRoleId())) {
+                    // If no role ID was given, assign one from the retrieved role.
+                    newRoleMember.setRoleIdAsMember(tempRole.getId());
+                } else if (!newRoleMember.getRoleId().equals(tempRole.getId())) {
+                    throw new RuntimeException("Cannot use role with ID \"" + newRoleMember.getRoleId() + "\", namespace \"" +
+                            roleNameAndNamespace.getNamespaceCode() + "\", and name \"" + roleNameAndNamespace.getName() +
+                                    "\" as a role member because the role with that namespace and name has an ID of \"" +
+                                            tempRole.getId() + "\" instead");
+                }
+            }
+        }
+        
+        // Ensure that a member ID was either explicitly defined or was derived from the member name (and namespace, if applicable).
+        if (StringUtils.isBlank(newRoleMember.getMemberId())) {
+            throw new RuntimeException("Cannot create a role member with no member principal/group/role identification information specified");
+        }
+        
+    }
+    
+    /**
+     * Validates a role permission's role and permission identification information, and assigns its role ID if needed.
+     */
+    private static void validateAndPrepareRolePermission(RolePermissionXmlDTO newRolePermission) throws UnmarshalException {
+        
+        // If this is a standalone role permission, derive and validate its role information accordingly.
+        if (newRolePermission instanceof RolePermissionXmlDTO.OutsideOfRole) {
+            RolePermissionXmlDTO.OutsideOfRole standaloneRolePerm = (RolePermissionXmlDTO.OutsideOfRole) newRolePermission;
+            if (standaloneRolePerm.getRoleNameAndNamespace() != null) {
+                // If a role name + namespace is given, assign or validate the role ID accordingly.
+                String tempRoleId = KimApiServiceLocator.getRoleService().getRoleIdByName(
+                        standaloneRolePerm.getRoleNamespaceCode(), standaloneRolePerm.getRoleName());
+                if (StringUtils.isBlank(tempRoleId)) {
+                    throw new UnmarshalException("Cannot assign permission to role with namespace \"" + standaloneRolePerm.getRoleNamespaceCode() +
+                            "\" and name \"" + standaloneRolePerm.getRoleName() + "\" because that role does not exist");
+                } else if (StringUtils.isBlank(standaloneRolePerm.getRoleId())) {
+                    // If no role ID was given, assign one from the retrieved role.
+                    standaloneRolePerm.setRoleId(standaloneRolePerm.getRoleId());
+                } else if (!standaloneRolePerm.getRoleId().equals(tempRoleId)) {
+                    throw new UnmarshalException("Cannot assign permission to role with ID \"" + standaloneRolePerm.getRoleId() + "\", namespace \"" +
+                            standaloneRolePerm.getRoleNamespaceCode() + "\", and name \"" + standaloneRolePerm.getRoleName() +
+                                    "\" because the existing role with that name and namespace has an ID of \"" + tempRoleId + "\" instead");
+                }
+            } else if (StringUtils.isBlank(standaloneRolePerm.getRoleId())) {
+                throw new UnmarshalException(
+                        "Cannot assign permission to role without providing the role ID or role name + namespace that the permission is assigned to");
+            } else if (KimApiServiceLocator.getRoleService().getRole(standaloneRolePerm.getRoleId()) == null) {
+                throw new UnmarshalException("Cannot assign permission to role with ID \"" + standaloneRolePerm.getRoleId() +
+                        "\" because that role does not exist");
+            }
+        }
+        
+        // Ensure that a role ID was explicitly defined or was derived from a name + namespace combo.
+        if (StringUtils.isBlank(newRolePermission.getRoleId())) {
+            throw new UnmarshalException("Cannot assign permission to role without providing the role ID or role name + namespace that the permission is assigned to");
+        }
+        
+        // If the permission is being identified by name and namespace, derive or validate its permission ID accordingly.
+        if (newRolePermission.getPermissionNameAndNamespace() != null) {
+            PermissionContract permission = KimApiServiceLocator.getPermissionService().getPermissionByName(
+                    newRolePermission.getPermissionNamespaceCode(), newRolePermission.getPermissionName());
+            if (permission == null) {
+                throw new UnmarshalException("Cannot get role assigned to permission with namespace \"" + newRolePermission.getPermissionNamespaceCode() +
+                        "\" and name \"" + newRolePermission.getPermissionName() + "\" because that permission does not exist");
+            } else if (StringUtils.isBlank(newRolePermission.getPermissionId())) {
+                // If no permission ID was given, assign one from the retrieved permission.
+                newRolePermission.setPermissionId(permission.getId());
+            } else if (!newRolePermission.getPermissionId().equals(permission.getId())) {
+                throw new UnmarshalException("Cannot get role assigned to permission with ID \"" + newRolePermission.getPermissionId() + "\", namespace \"" +
+                        newRolePermission.getPermissionNamespaceCode() + "\", and name \"" + newRolePermission.getPermissionName() +
+                                "\" because the existing permission with that name and namespace has an ID of \"" + permission.getId() + "\" instead");
+            }
+        } else if (StringUtils.isBlank(newRolePermission.getPermissionId())) {
+            throw new UnmarshalException("Cannot assign permission to role without specifying the ID or name and namespace of the permission to assign");
+        } else if (KimApiServiceLocator.getPermissionService().getPermission(newRolePermission.getPermissionId()) == null) {
+            throw new UnmarshalException("Cannot get role assigned to permission with ID \"" + newRolePermission.getPermissionId() +
+                    "\" because that permission does not exist");
+        }
+    }
+    
+}
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java	(revision 32084)
@@ -0,0 +1,508 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.joda.time.DateTime;
+import org.kuali.rice.core.api.util.jaxb.DateTimeAdapter;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.kim.api.group.GroupContract;
+import org.kuali.rice.kim.api.identity.principal.PrincipalContract;
+import org.kuali.rice.kim.api.jaxb.QualificationListAdapter;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.kim.api.role.RoleMemberContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+import org.kuali.rice.kim.util.KimConstants.KimUIConstants;
+
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Base class representing an unmarshalled &lt;roleMember&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RoleMemberXmlDTO implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    @XmlElement(name="principalId")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String principalId;
+    
+    @XmlElement(name="principalName")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String principalName;
+    
+    @XmlElement(name="groupId")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String groupId;
+    
+    @XmlElement(name="groupName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair groupName;
+    
+    @XmlElement(name="roleIdAsMember")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String roleIdAsMember;
+    
+    @XmlElement(name="roleNameAsMember")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair roleNameAsMember;
+    
+    @XmlElement(name="activeFromDate")
+    @XmlJavaTypeAdapter(DateTimeAdapter.class)
+    private DateTime activeFromDate;
+    
+    @XmlElement(name="activeToDate")
+    @XmlJavaTypeAdapter(DateTimeAdapter.class)
+    private DateTime activeToDate;
+    
+    @XmlElement(name="qualifications")
+    @XmlJavaTypeAdapter(QualificationListAdapter.class)
+    private Map<String, String> qualifications;
+    
+    @XmlTransient
+    private String memberTypeCode;
+    
+    /**
+     * Constructs an empty RoleMemberXmlDTO instance.
+     */
+    public RoleMemberXmlDTO() {}
+    
+    /**
+     * Constructs a RoleMemberXmlDTO instance that is populated with the info from the given role member.
+     * 
+     * @param roleMember The role member that this DTO should populate its data from.
+     * @param populateMemberId If true, the member principal/group/role ID will get populated; otherwise, only
+     * the member principal/group/role name and (if applicable) namespace will get populated.
+     * @throws IllegalArgumentException if roleMember is null, has an invalid member type code, or refers to a nonexistent principal/group/role.
+     */
+    public RoleMemberXmlDTO(RoleMemberContract roleMember, boolean populateMemberId) {
+        if (roleMember == null) {
+            throw new IllegalArgumentException("roleMember cannot be null");
+        }
+        this.memberTypeCode = roleMember.getMemberTypeCode();
+        this.activeFromDate = roleMember.getActiveFromDate();
+        this.activeToDate = roleMember.getActiveToDate();
+        this.qualifications = (roleMember.getAttributes() != null) ? roleMember.getAttributes() : new HashMap<String, String>();
+        
+        if (KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE.equals(memberTypeCode)) {
+            if (populateMemberId) {
+                this.principalId = roleMember.getMemberId();
+            }
+            PrincipalContract principal = KimApiServiceLocator.getIdentityService().getPrincipal(roleMember.getMemberId());
+            if (principal == null) {
+                throw new IllegalArgumentException("Cannot find principal with ID \"" +  roleMember.getMemberId() + "\"");
+            }
+            this.principalName = principal.getPrincipalName();
+        } else if (KimUIConstants.MEMBER_TYPE_GROUP_CODE.equals(memberTypeCode)) {
+            if (populateMemberId) {
+                this.groupId = roleMember.getMemberId();
+            }
+            GroupContract group = KimApiServiceLocator.getGroupService().getGroup(roleMember.getMemberId());
+            if (group == null) {
+                throw new IllegalArgumentException("Cannot find group with ID \"" + roleMember.getMemberId() + "\"");
+            }
+            this.groupName = new NameAndNamespacePair(group.getNamespaceCode(), group.getName());
+        } else if (KimUIConstants.MEMBER_TYPE_ROLE_CODE.equals(memberTypeCode)) {
+            if (populateMemberId) {
+                this.roleIdAsMember = roleMember.getMemberId();
+            }
+            RoleContract role = KimApiServiceLocator.getRoleService().getRole(roleMember.getMemberId());
+            if (role == null) {
+                throw new IllegalArgumentException("Cannot find role with ID \"" + roleMember.getMemberId() + "\"");
+            }
+            this.roleNameAsMember = new NameAndNamespacePair(role.getNamespaceCode(), role.getName());
+        } else {
+            throw new IllegalArgumentException("Cannot construct a RoleMemberXmlDTO from a role member with an unrecognized member type code of \"" +
+                    memberTypeCode + "\"");
+        }    
+    }
+
+    /**
+     * @return the principalId
+     */
+    public String getPrincipalId() {
+        return this.principalId;
+    }
+
+    /**
+     * @param principalId the principalId to set
+     */
+    public void setPrincipalId(String principalId) {
+        this.principalId = principalId;
+    }
+
+    /**
+     * @return the principalName
+     */
+    public String getPrincipalName() {
+        return this.principalName;
+    }
+
+    /**
+     * @param principalName the principalName to set
+     */
+    public void setPrincipalName(String principalName) {
+        this.principalName = principalName;
+    }
+
+    /**
+     * @return the groupId
+     */
+    public String getGroupId() {
+        return this.groupId;
+    }
+
+    /**
+     * @param groupId the groupId to set
+     */
+    public void setGroupId(String groupId) {
+        this.groupId = groupId;
+    }
+
+    /**
+     * @return the groupName
+     */
+    public NameAndNamespacePair getGroupName() {
+        return this.groupName;
+    }
+
+    /**
+     * @param groupName the groupName to set
+     */
+    public void setGroupName(NameAndNamespacePair groupName) {
+        this.groupName = groupName;
+    }
+
+    /**
+     * @return the roleIdAsMember
+     */
+    public String getRoleIdAsMember() {
+        return this.roleIdAsMember;
+    }
+
+    /**
+     * @param roleIdAsMember the roleIdAsMember to set
+     */
+    public void setRoleIdAsMember(String roleIdAsMember) {
+        this.roleIdAsMember = roleIdAsMember;
+    }
+
+    /**
+     * @return the roleNameAsMember
+     */
+    public NameAndNamespacePair getRoleNameAsMember() {
+        return this.roleNameAsMember;
+    }
+
+    /**
+     * @param roleNameAsMember the roleNameAsMember to set
+     */
+    public void setRoleNameAsMember(NameAndNamespacePair roleNameAsMember) {
+        this.roleNameAsMember = roleNameAsMember;
+    }
+
+    /**
+     * @return the activeFromDate
+     */
+    public DateTime getActiveFromDate() {
+        return this.activeFromDate;
+    }
+
+    /**
+     * @param activeFromDate the activeFromDate to set
+     */
+    public void setActiveFromDate(DateTime activeFromDate) {
+        this.activeFromDate = activeFromDate;
+    }
+
+    /**
+     * @return the activeToDate
+     */
+    public DateTime getActiveToDate() {
+        return this.activeToDate;
+    }
+
+    /**
+     * @param activeToDate the activeToDate to set
+     */
+    public void setActiveToDate(DateTime activeToDate) {
+        this.activeToDate = activeToDate;
+    }
+
+    /**
+     * @return the qualifications
+     */
+    public Map<String, String> getQualifications() {
+        return this.qualifications;
+    }
+
+    /**
+     * @param qualifications the qualifications to set
+     */
+    public void setQualifications(Map<String, String> qualifications) {
+        this.qualifications = qualifications;
+    }
+
+    /**
+     * Retrieves the member type code.
+     * 
+     * <p>If the member type code is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return the member type code, or null if no membership identification information has been set on this member.
+     * @throws IllegalStateException if the role member is populated simultaneously with multiple member ID/name information
+     */
+    public String getMemberTypeCode() {
+        if (memberTypeCode == null) {
+            boolean foundMemberInfo = false;
+            
+            if (StringUtils.isNotBlank(principalId) || StringUtils.isNotBlank(principalName)) {
+                memberTypeCode = KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE;
+                foundMemberInfo = true;
+            }
+            
+            if (StringUtils.isNotBlank(groupId) || groupName != null) {
+                if (foundMemberInfo) {
+                    memberTypeCode = null;
+                    throw new IllegalStateException("Cannot have a role member that is simultaneously populated with member principal, member group, and/or member role information");
+                }
+                memberTypeCode = KimUIConstants.MEMBER_TYPE_GROUP_CODE;
+                foundMemberInfo = true;
+            }
+            
+            if (StringUtils.isNotBlank(roleIdAsMember) || roleNameAsMember != null) {
+                if (foundMemberInfo) {
+                    memberTypeCode = null;
+                    throw new IllegalStateException("Cannot have a role member that is simultaneously populated with member principal, member group, and/or member role information");
+                }
+                memberTypeCode = KimUIConstants.MEMBER_TYPE_ROLE_CODE;
+                foundMemberInfo = true;
+            }
+        }
+        return this.memberTypeCode;
+    }
+
+    /**
+     * Retrieves the role member's ID, based on the member type code and any populated member principal/group/role IDs.
+     * 
+     * <p>If the member type code is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return The member's ID, or null if the member type code is null or the associated member ID information is null.
+     */
+    public String getMemberId() {
+        if (KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE.equals(getMemberTypeCode())) {
+            return principalId;
+        } else if (KimUIConstants.MEMBER_TYPE_GROUP_CODE.equals(getMemberTypeCode())) {
+            return groupId;
+        } else if (KimUIConstants.MEMBER_TYPE_ROLE_CODE.equals(getMemberTypeCode())) {
+            return roleIdAsMember;
+        }
+        return null;
+    }
+    
+    /**
+     * Retrieves the role member's name, based on the member type code and any populated member principal/group/role names.
+     * 
+     * <p>If the member type code is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return The member's name, or null if the member type code is null or the associated member name information is null.
+     */
+    public String getMemberName() {
+        if (KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE.equals(getMemberTypeCode())) {
+            return principalName;
+        } else if (KimUIConstants.MEMBER_TYPE_GROUP_CODE.equals(getMemberTypeCode())) {
+            return (groupName != null) ? groupName.getName() : null;
+        } else if (KimUIConstants.MEMBER_TYPE_ROLE_CODE.equals(getMemberTypeCode())) {
+            return (roleNameAsMember != null) ? roleNameAsMember.getName() : null;
+        }
+        return null;
+    }
+    
+    /**
+     * Retrieves the role member's namespace code, based on the member type code and any populated member principal/group/role names.
+     * 
+     * <p>If the member type code is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return The member's namespace code, or null if the member type code is null, the associated member name information is null,
+     * or the role member is a principal.
+     */
+    public String getMemberNamespaceCode() {
+        if (KimUIConstants.MEMBER_TYPE_PRINCIPAL_CODE.equals(getMemberTypeCode())) {
+            return null;
+        } else if (KimUIConstants.MEMBER_TYPE_GROUP_CODE.equals(getMemberTypeCode())) {
+            return (groupName != null) ? groupName.getName() : null;
+        } else if (KimUIConstants.MEMBER_TYPE_ROLE_CODE.equals(getMemberTypeCode())) {
+            return (roleNameAsMember != null) ? roleNameAsMember.getName() : null;
+        }
+        return null;
+    }
+    
+    /**
+     * Retrieves the ID of the role that this member belongs to.
+     * Subclasses are responsible for implementing this method so that it does so.
+     * 
+     * @return The role ID of the role that this member belongs to.
+     */
+    public abstract String getRoleId();
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMember&gt; element that is not a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRoleMemberType", propOrder={
+            "roleId", "roleNameAndNamespace", "principalId", "principalName", "groupId", "groupName", "roleIdAsMember",
+                    "roleNameAsMember", "activeFromDate", "activeToDate", "qualifications"
+    })
+    public static class OutsideOfRole extends RoleMemberXmlDTO {
+
+        private static final long serialVersionUID = 1L;
+
+        @XmlElement(name="roleId")
+        @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+        private String roleId;
+
+        @XmlElement(name="roleName")
+        @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+        private NameAndNamespacePair roleNameAndNamespace;
+        
+        public OutsideOfRole() {
+            super();
+        }
+        
+        public OutsideOfRole(RoleMemberContract roleMember, boolean populateMemberId) {
+            super(roleMember, populateMemberId);
+            this.roleId = roleMember.getRoleId();
+            RoleContract tempRole = KimApiServiceLocator.getRoleService().getRole(roleId);
+            if (tempRole == null) {
+                throw new IllegalArgumentException("Cannot find role with ID \"" + roleId + "\"");
+            }
+            this.roleNameAndNamespace = new NameAndNamespacePair(tempRole.getNamespaceCode(), tempRole.getName());
+        }
+        
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return roleId;
+        }
+
+        /**
+         * @param roleId the roleId to set
+         */
+        public void setRoleId(String roleId) {
+            this.roleId = roleId;
+        }
+        
+        /**
+         * @return the roleNameAndNamespace
+         */
+        public NameAndNamespacePair getRoleNameAndNamespace() {
+            return this.roleNameAndNamespace;
+        }
+
+        /**
+         * @param roleNameAndNamespace the roleNameAndNamespace to set
+         */
+        public void setRoleNameAndNamespace(NameAndNamespacePair roleNameAndNamespace) {
+            this.roleNameAndNamespace = roleNameAndNamespace;
+        }
+
+        /**
+         * Retrieves the role name from the role-name-and-namespace combo.
+         * 
+         * @return The name of the role that this member belongs to, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleName() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getName() : null;
+        }
+
+        /**
+         * Retrieves the role namespace code from the role-name-and-namespace combo.
+         * 
+         * @return The namespace code of the role that this member belongs to, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleNamespaceCode() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getNamespaceCode() : null;
+        }
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMember&gt; element that is a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RoleMemberType", propOrder={
+            "principalId", "principalName", "groupId", "groupName", "roleIdAsMember",
+                    "roleNameAsMember", "activeFromDate", "activeToDate", "qualifications"
+    })
+    public static class WithinRole extends RoleMemberXmlDTO {
+
+        private static final long serialVersionUID = 1L;
+        
+        @XmlTransient
+        private String roleId;
+
+        public WithinRole() {
+            super();
+        }
+        
+        public WithinRole(RoleMemberContract roleMember, boolean populateMemberId) {
+            super(roleMember, populateMemberId);
+            this.roleId = roleMember.getRoleId();
+        }
+        
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+            if (parent instanceof RoleMembersXmlDTO.WithinRole) {
+                this.roleId = ((RoleMembersXmlDTO.WithinRole)parent).getRoleId();
+            }
+        }
+        
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return roleId;
+        }
+        
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java	(revision 32084)
@@ -0,0 +1,257 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+
+/**
+ * Base class representing an unmarshalled &lt;rolePermission&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RolePermissionXmlDTO implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="permissionId")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String permissionId;
+    
+    @XmlElement(name="permissionName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair permissionNameAndNamespace;
+
+    /**
+     * Constructs an empty RolePermissionXmlDTO instance.
+     */
+    public RolePermissionXmlDTO() {}
+    
+    /**
+     * Constructs a RolePermissionXmlDTO that gets populated from the given KIM permission.
+     * 
+     * @param permission The permission that this DTO should obtain its data from.
+     * @param populateIds If true, the permission ID will get populated; otherwise, it will remain null.
+     */
+    public RolePermissionXmlDTO(PermissionContract permission, boolean populateIds) {
+        if (permission == null) {
+            throw new IllegalArgumentException("Cannot construct a role permission with a null permission");
+        }
+        if (populateIds) {
+            this.permissionId = permission.getId();
+        }
+        this.permissionNameAndNamespace = new NameAndNamespacePair(permission.getNamespaceCode(), permission.getName());
+    }
+
+    /**
+     * @return the permissionId
+     */
+    public String getPermissionId() {
+        return this.permissionId;
+    }
+
+    /**
+     * @param permissionId the permissionId to set
+     */
+    public void setPermissionId(String permissionId) {
+        this.permissionId = permissionId;
+    }
+
+    /**
+     * @return the permissionNameAndNamespace
+     */
+    public NameAndNamespacePair getPermissionNameAndNamespace() {
+        return this.permissionNameAndNamespace;
+    }
+
+    /**
+     * @param permissionNameAndNamespace the permissionNameAndNamespace to set
+     */
+    public void setPermissionNameAndNamespace(NameAndNamespacePair permissionNameAndNamespace) {
+        this.permissionNameAndNamespace = permissionNameAndNamespace;
+    }
+
+    /**
+     * Retrieves the permission name from the permission-name-and-namespace combo.
+     * 
+     * @return The name of the permission assigned to the role, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getPermissionName() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getName() : null;
+    }
+
+    /**
+     * Retrieves the permission namespace code from the permission-name-and-namespace combo.
+     * 
+     * @return The namespace code of the permission assigned to the role, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getPermissionNamespaceCode() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getNamespaceCode() : null;
+    }
+    
+    /**
+     * Retrieves the ID of the role that the permission is assigned to.
+     * Subclasses are responsible for implementing this method so that it does so.
+     * 
+     * @return The role ID of the role that the permission is assigned to.
+     */
+    public abstract String getRoleId();
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermission&gt; element that is not a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRolePermissionType", propOrder={
+            "roleId", "roleNameAndNamespace", "permissionId", "permissionNameAndNamespace"
+    })
+    public static class OutsideOfRole extends RolePermissionXmlDTO {
+        
+        private static final long serialVersionUID = 1L;
+
+        @XmlElement(name="roleId")
+        @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+        private String roleId;
+        
+        @XmlElement(name="roleName")
+        @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+        private NameAndNamespacePair roleNameAndNamespace;
+        
+        public OutsideOfRole() {
+            super();
+        }
+        
+        public OutsideOfRole(PermissionContract permission, String roleId, boolean populateIds) {
+            super(permission, populateIds);
+            if (populateIds) {
+                this.roleId = roleId;
+            }
+            RoleContract tempRole = KimApiServiceLocator.getRoleService().getRole(roleId);
+            if (tempRole == null) {
+                throw new IllegalArgumentException("Cannot find role with ID \"" + roleId + "\"");
+            }
+            this.roleNameAndNamespace = new NameAndNamespacePair(tempRole.getNamespaceCode(), tempRole.getName());
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RolePermissionXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return this.roleId;
+        }
+
+        /**
+         * @param roleId the roleId to set
+         */
+        public void setRoleId(String roleId) {
+            this.roleId = roleId;
+        }
+
+        /**
+         * @return the roleNameAndNamespace
+         */
+        public NameAndNamespacePair getRoleNameAndNamespace() {
+            return this.roleNameAndNamespace;
+        }
+
+        /**
+         * @param roleNameAndNamespace the roleNameAndNamespace to set
+         */
+        public void setRoleNameAndNamespace(NameAndNamespacePair roleNameAndNamespace) {
+            this.roleNameAndNamespace = roleNameAndNamespace;
+        }
+        
+        /**
+         * Retrieves the role name from the role-name-and-namespace combo.
+         * 
+         * @return The name of the role that is assigned to the permission, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleName() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getName() : null;
+        }
+
+        /**
+         * Retrieves the role namespace code from the role-name-and-namespace combo.
+         * 
+         * @return The namespace code of the role that is assigned to the permission, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleNamespaceCode() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getNamespaceCode() : null;
+        }
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermission&gt; element that is a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RolePermissionType", propOrder={
+            "permissionId", "permissionNameAndNamespace"
+    })
+    public static class WithinRole extends RolePermissionXmlDTO {
+        
+        private static final long serialVersionUID = 1L;
+        
+        @XmlTransient
+        private String roleId;
+        
+        public WithinRole() {
+            super();
+        }
+        
+        public WithinRole(PermissionContract permission, boolean populateIds) {
+            super(permission, populateIds);
+        }
+        
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+            if (parent instanceof RolePermissionsXmlDTO) {
+                this.roleId = ((RolePermissionXmlDTO)parent).getRoleId();
+            }
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RolePermissionXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return this.roleId;
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java	(revision 32084)
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.List;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+
+/**
+ * This class represents a &lt;permissions&gt; element. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionsType", propOrder={"permissions"})
+public class PermissionsXmlDTO implements RiceXmlListAdditionListener<PermissionXmlDTO>,
+        RiceXmlListGetterListener<PermissionXmlDTO,Object>, Serializable {
+    
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="permission")
+    private List<PermissionXmlDTO> permissions;
+    
+    public PermissionsXmlDTO() {}
+    
+    public PermissionsXmlDTO(List<? extends Object> permissionsToExport) {
+        this.permissions = new RiceXmlExportList<PermissionXmlDTO,Object>(permissionsToExport, this);
+    }
+    
+    /**
+     * @return the permissions
+     */
+    public List<PermissionXmlDTO> getPermissions() {
+        return this.permissions;
+    }
+
+    /**
+     * @param permissions the permissions to set
+     */
+    public void setPermissions(List<PermissionXmlDTO> permissions) {
+        this.permissions = permissions;
+    }
+
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        permissions = new RiceXmlImportList<PermissionXmlDTO>(this);
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        permissions = null;
+    }
+    
+    public void newItemAdded(PermissionXmlDTO item) {
+        try {
+            PermissionXmlUtil.validateAndPersistNewPermission(item);
+        } catch (UnmarshalException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    void afterMarshal(Marshaller marshaller) {
+        permissions = null;
+    }
+    
+    public PermissionXmlDTO gettingNextItem(Object nextItem, int index) {
+        if (!(nextItem instanceof PermissionContract)) {
+            throw new IllegalStateException("Object for exportation should have been a permission");
+        }
+        return new PermissionXmlDTO((PermissionContract) nextItem);
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java	(revision 32084)
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+/**
+ * This class represents a &lt;roleData&gt; element.
+ * 
+ * <p>The expected XML structure is as follows:
+ * 
+ * <br>
+ * <br>&lt;roleData&gt;
+ * <br>&nbsp;&nbsp;&lt;roles&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;role&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleName namespaceCode=""&gt;&lt;/roleName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;kimTypeName namespaceCode=""&gt;&lt;/kimTypeName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;&lt;/description&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;active&gt;&lt;/active&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleMembers&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalId&gt;&lt;/principalId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalName&gt;&lt;/principalName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;&lt;/groupId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupName namespaceCode=""&gt;&lt;/groupName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleIdAsMember&gt;&lt;/roleIdAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleNameAsMember namespaceCode=""&gt;&lt;/roleNameAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeFromDate&gt;&lt;/activeFromDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeToDate&gt;&lt;/activeToDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualification key=""&gt;&lt;/qualification&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/roleMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/roleMembers&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rolePermissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rolePermission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionId&gt;&lt;/permissionId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionName namespaceCode=""&gt;&lt;/permissionName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rolePermission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rolePermissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/role&gt;
+ * <br>&nbsp;&nbsp;&lt;/roles&gt;
+ * <br>&nbsp;&nbsp;&lt;roleMembers&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleId&gt;&lt;/roleId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleName namespaceCode=""&gt;&lt;/roleName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalId&gt;&lt;/principalId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalName&gt;&lt;/principalName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;&lt;/groupId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupName namespaceCode=""&gt;&lt;/groupName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleIdAsMember&gt;&lt;/roleIdAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleNameAsMember namespaceCode=""&gt;&lt;/roleNameAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeFromDate&gt;&lt;/activeFromDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeToDate&gt;&lt;/activeToDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualification key=""&gt;&lt;/qualification&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/roleMember&gt;
+ * <br>&nbsp;&nbsp;&lt;/roleMembers&gt;
+ * <br>&nbsp;&nbsp;&lt;rolePermissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;rolePermission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleId&gt;&lt;/roleId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleName namespaceCode=""&gt;&lt;/roleName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionId&gt;&lt;/permissionId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionName namespaceCode=""&gt;&lt;/permissionName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rolePermission&gt;
+ * <br>&nbsp;&nbsp;&lt;/rolePermissions&gt;
+ * <br>&lt;/roleData&gt;
+ * 
+ * <p>Note the following:
+ * <ul>
+ *   <li>The &lt;roles&gt; element is optional, and can contain zero or more &lt;role&gt; elements.
+ *   <li>The &lt;roleName&gt; element on the &lt;role&gt; element and its "namespaceCode" attribute
+ *   are required, and must be non-blank. The namespace code must map to a valid namespace.
+ *   If the name and namespace combo matches an existing role, then the role in the XML will
+ *   overwrite the existing role.
+ *   <li>The &lt;kimTypeName&gt; and its "namespaceCode" attribute are both required, and the
+ *   name and namespace combo must match an existing KIM type.
+ *   <li>The &lt;description&gt; element is required, and must be non-blank.
+ *   <li>The &lt;active&gt; element is optional, and will be set to true if not specified.
+ *   <li>Both &lt;roleMembers&gt; elements are optional, and can contain zero or more
+ *   &lt;roleMember&gt; elements. If the &lt;roleMembers&gt; element within the &lt;role&gt;
+ *   element is specified, then any role members that are not within that element will be removed
+ *   from the role if the XML is overwriting an existing one. (The &lt;roleMembers&gt; element
+ *   outside of the &lt;role&gt; element can still add or re-add members that are not located
+ *   within the other &lt;roleMembers&gt; element.)
+ *   <li>For both &lt;roleMember&gt; elements:
+ *     <ul>
+ *       <li>Exactly one of these sets of member identification must be specified:
+ *         <ol>
+ *           <li>A &lt;principalId&gt; and/or &lt;principalName&gt; element, where the former
+ *           must contain a valid principal ID and the latter must contain a valid principal name.
+ *           <li>A &lt;groupId&gt; and/or &lt;groupName&gt; element, where the former must contain
+ *           a valid group ID and the latter must contain a valid group name and namespace.
+ *           <li>A &lt;roleIdAsMember&gt; and/or &lt;roleNameAsMember&gt; element, where the former
+ *           must contain a valid role ID and the latter must contain a valid role name and namespace.
+ *         </ol>
+ *       <li>The &lt;activeFromDate&gt; element is optional, and its content must be a date String
+ *       that can be parsed by the DateTimeService.
+ *       <li>The &lt;activeToDate&gt; element is optional, and its content must be a date String
+ *       that can be parsed by the DateTimeService.
+ *       <li>The &lt;qualifications&gt; element is optional, and can contain zero or more
+ *       &lt;qualification&gt; elements.
+ *       <li>The &lt;qualification&gt; element's "key" attribute is required, and must be non-blank.
+ *       Duplicate keys within a &lt;qualifications&gt; element are not permitted.
+ *     </ul>
+ *   <li>For both &lt;rolePermission&gt; elements:
+ *     <ul>
+ *       <li>A &lt;permissionId&gt; and/or &lt;permissionName&gt; element must be specified, where the
+ *       former must contain a valid permission ID and the latter must contain a valid permission
+ *       name and namespace.
+ *     </ul>
+ *   <li>For the &lt;roleMember&gt; and &lt;rolePermission&gt; elements not inside a &lt;role&gt; element:
+ *     <ul>
+ *       <li>A &lt;roleId&gt; and/or &lt;roleName&gt; element must be specified, where the former must
+ *       contain a valid role ID and the latter must contain a valid role name and namespace.
+ *     </ul>
+ *   <li>The ingestion process is currently order-dependent, which should be kept in mind when adding
+ *   roles as members of another role or assigning permissions to roles. (The permission XML always
+ *   gets ingested prior to the role XML.)
+ *   <li>The assignments of permissions to roles can only be added, not removed or deactivated.
+ *   (TODO: Improve the role/permission-updating API to allow for updates and removals.)
+ *   <li>The same roles, role members, and role permissions can be ingested within the same file,
+ *   where subsequent ones will overwrite previous ones. (TODO: Is this acceptable?)
+ *   <li>The IDs of principals, groups, roles, and permissions are not included when exporting the XML.
+ *   <li>Delegations and responsibility actions are currently not supported by the ingestion process.
+ * </ul>
+ * 
+ * TODO: Verify that the above behavior is correct.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="RoleDataType", propOrder={"roles", "roleMembers", "rolePermissions"})
+public class RoleDataXmlDTO implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    @XmlElement(name="roles")
+    private RolesXmlDTO roles;
+    
+    @XmlElement(name="roleMembers")
+    private RoleMembersXmlDTO.OutsideOfRole roleMembers;
+
+    @XmlElement(name="rolePermissions")
+    private RolePermissionsXmlDTO.OutsideOfRole rolePermissions;
+    
+    public RoleDataXmlDTO() {}
+    
+    public RoleDataXmlDTO(RolesXmlDTO roles) {
+        this.roles = roles;
+    }
+
+    /**
+     * @return the roles
+     */
+    public RolesXmlDTO getRoles() {
+        return this.roles;
+    }
+
+    /**
+     * @param roles the roles to set
+     */
+    public void setRoles(RolesXmlDTO roles) {
+        this.roles = roles;
+    }
+
+    /**
+     * @return the roleMembers
+     */
+    public RoleMembersXmlDTO.OutsideOfRole getRoleMembers() {
+        return this.roleMembers;
+    }
+
+    /**
+     * @param roleMembers the roleMembers to set
+     */
+    public void setRoleMembers(RoleMembersXmlDTO.OutsideOfRole roleMembers) {
+        this.roleMembers = roleMembers;
+    }
+
+    /**
+     * @return the rolePermissions
+     */
+    public RolePermissionsXmlDTO.OutsideOfRole getRolePermissions() {
+        return this.rolePermissions;
+    }
+
+    /**
+     * @param rolePermissions the rolePermissions to set
+     */
+    public void setRolePermissions(RolePermissionsXmlDTO.OutsideOfRole rolePermissions) {
+        this.rolePermissions = rolePermissions;
+    }
+        
+}
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java	(revision 32084)
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.role.RoleMemberContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+/**
+ * Base class representing an unmarshalled &lt;roleMembers&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RoleMembersXmlDTO<T extends RoleMemberXmlDTO> implements RiceXmlListAdditionListener<T>, Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    public abstract List<T> getRoleMembers();
+    
+    public abstract void setRoleMembers(List<T> roleMembers);
+    
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRoleMembers(new RiceXmlImportList<T>(this));
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRoleMembers(null);
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMembers&gt; element that is not a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRoleMembersType", propOrder={"roleMembers"})
+    public static class OutsideOfRole extends RoleMembersXmlDTO<RoleMemberXmlDTO.OutsideOfRole> {
+
+        private static final long serialVersionUID = 1L;
+        
+        @XmlElement(name="roleMember")
+        private List<RoleMemberXmlDTO.OutsideOfRole> roleMembers;
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#getRoleMembers()
+         */
+        @Override
+        public List<RoleMemberXmlDTO.OutsideOfRole> getRoleMembers() {
+            return this.roleMembers;
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#setRoleMembers(java.util.List)
+         */
+        @Override
+        public void setRoleMembers(List<RoleMemberXmlDTO.OutsideOfRole> roleMembers) {
+            this.roleMembers = roleMembers;
+        }
+
+        /**
+         * @see org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener#newItemAdded(java.lang.Object)
+         */
+        @Override
+        public void newItemAdded(RoleMemberXmlDTO.OutsideOfRole item) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRoleMember(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMembers&gt; element that is a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RoleMembersType", propOrder={"roleMembers"})
+    public static class WithinRole extends RoleMembersXmlDTO<RoleMemberXmlDTO.WithinRole>
+            implements RiceXmlListGetterListener<RoleMemberXmlDTO.WithinRole,String> {
+
+        private static final long serialVersionUID = 1L;
+        
+        @XmlElement(name="roleMember")
+        private List<RoleMemberXmlDTO.WithinRole> roleMembers;
+
+        @XmlTransient
+        private String roleId;
+        
+        @XmlTransient
+        private Set<String> existingRoleMemberIds;
+        
+        public WithinRole() {}
+        
+        public WithinRole(String roleId) {
+            this.roleId = roleId;
+        }
+        
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#getRoleMembers()
+         */
+        @Override
+        public List<org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO.WithinRole> getRoleMembers() {
+            return this.roleMembers;
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#setRoleMembers(java.util.List)
+         */
+        @Override
+        public void setRoleMembers(List<org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO.WithinRole> roleMembers) {
+            this.roleMembers = roleMembers;
+        }
+        
+        /**
+         * @return the roleId
+         */
+        public String getRoleId() {
+            return this.roleId;
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#beforeUnmarshal(javax.xml.bind.Unmarshaller, java.lang.Object)
+         */
+        @Override
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+            if (parent instanceof RoleXmlDTO) {
+                // Obtain the role ID from the enclosing role, and persist the role if it has not been persisted yet.
+                RoleXmlDTO parentRole = (RoleXmlDTO) parent;
+                if (!parentRole.isAlreadyPersisted()) {
+                    RoleXmlUtil.validateAndPersistNewRole(parentRole);
+                }
+                roleId = parentRole.getRoleId();
+            }
+            existingRoleMemberIds = new HashSet<String>();
+            super.beforeUnmarshal(unmarshaller, parent);
+        }
+
+        /**
+         * This overridden method ...
+         * 
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#afterUnmarshal(javax.xml.bind.Unmarshaller, java.lang.Object)
+         */
+        @Override
+        void afterUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+            super.afterUnmarshal(unmarshaller, parent);
+            if (parent instanceof RoleXmlDTO) {
+                ((RoleXmlDTO)parent).setExistingRoleMemberIds(existingRoleMemberIds);
+            }
+            existingRoleMemberIds = null;
+        }
+
+        /**
+         * @see org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener#newItemAdded(java.lang.Object)
+         */
+        @Override
+        public void newItemAdded(org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO.WithinRole item) {
+            // Persist the role member and add it to the set of role members that should not be removed from the role.
+            try {
+                existingRoleMemberIds.add(RoleXmlUtil.validateAndPersistNewRoleMember(item));
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+        void beforeMarshal(Marshaller marshaller) {
+            List<? extends RoleMemberContract> tempMembers = KimApiServiceLocator.getRoleService().findRoleMembers(Collections.singletonMap("roleId", roleId));
+            if (tempMembers != null && !tempMembers.isEmpty()) {
+                List<String> roleMemberIds = new ArrayList<String>();
+                
+                for (RoleMemberContract tempMember : tempMembers) {
+                    if (tempMember.isActive(null)) {
+                        roleMemberIds.add(tempMember.getRoleMemberId());
+                    }
+                }
+                
+                if (!roleMemberIds.isEmpty()) {
+                    setRoleMembers(new RiceXmlExportList<RoleMemberXmlDTO.WithinRole,String>(roleMemberIds, this));
+                }
+            }
+        }
+        
+        void afterMarshal(Marshaller marshaller) {
+            setRoleMembers(null);
+        }
+
+        /**
+         * @see org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener#gettingNextItem(java.lang.Object, int)
+         */
+        @Override
+        public RoleMemberXmlDTO.WithinRole gettingNextItem(String nextItem, int index) {
+            return new RoleMemberXmlDTO.WithinRole(KimApiServiceLocator.getRoleService().findRoleMembers(
+                    Collections.singletonMap("roleMemberId", nextItem)).get(0), false);
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/package-info.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/package-info.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/package-info.java	(revision 32084)
@@ -0,0 +1,6 @@
+@javax.xml.bind.annotation.XmlSchema(namespace = KimApiConstants.Namespaces.KIM_NAMESPACE_2_0, elementFormDefault = XmlNsForm.QUALIFIED)
+package org.kuali.rice.kim.impl.jaxb;
+
+import javax.xml.bind.annotation.XmlNsForm;
+
+import org.kuali.rice.kim.api.KimApiConstants;
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/package-info.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java	(revision 32084)
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+/**
+ * Base class representing an unmarshalled &lt;rolePermissions&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * TODO: Alter the role/permission service APIs so that finding all the permissions assigned to a role is possible; the
+ * current lack of such an API method prevents role permissions from being exported.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RolePermissionsXmlDTO<T extends RolePermissionXmlDTO> implements RiceXmlListAdditionListener<T>, Serializable {
+    
+    private static final long serialVersionUID = 1L;
+
+    public abstract List<T> getRolePermissions();
+    
+    public abstract void setRolePermissions(List<T> rolePermissions);
+    
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRolePermissions(new RiceXmlImportList<T>(this));
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRolePermissions(null);
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermissions&gt; element that is not a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRolePermissionsType", propOrder={"rolePermissions"})
+    public static class OutsideOfRole extends RolePermissionsXmlDTO<RolePermissionXmlDTO.OutsideOfRole> {
+        
+        private static final long serialVersionUID = 1L;
+        
+        @XmlElement(name="rolePermission")
+        private List<RolePermissionXmlDTO.OutsideOfRole> rolePermissions;
+        
+        public List<RolePermissionXmlDTO.OutsideOfRole> getRolePermissions() {
+            return rolePermissions;
+        }
+
+        public void setRolePermissions(List<RolePermissionXmlDTO.OutsideOfRole> rolePermissions) {
+            this.rolePermissions = rolePermissions;
+        }
+        
+        public void newItemAdded(RolePermissionXmlDTO.OutsideOfRole item) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRolePermission(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermissions&gt; element that is a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RolePermissionsType", propOrder={"rolePermissions"})
+    public static class WithinRole extends RolePermissionsXmlDTO<RolePermissionXmlDTO.WithinRole>
+            implements RiceXmlListGetterListener<RolePermissionXmlDTO.WithinRole,String> {
+        
+        private static final long serialVersionUID = 1L;
+
+        @XmlElement(name="rolePermission")
+        private List<RolePermissionXmlDTO.WithinRole> rolePermissions;
+        
+        @XmlTransient
+        private String roleId;
+        
+        public WithinRole() {}
+        
+        public WithinRole(String roleId) {
+            this.roleId = roleId;
+        }
+        
+        public List<RolePermissionXmlDTO.WithinRole> getRolePermissions() {
+            return rolePermissions;
+        }
+
+        public void setRolePermissions(List<RolePermissionXmlDTO.WithinRole> rolePermissions) {
+            this.rolePermissions = rolePermissions;
+        }
+        
+        public String getRoleId() {
+            return roleId;
+        }
+        
+        @Override
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+            if (parent instanceof RoleXmlDTO) {
+                // Obtain the role ID from the enclosing role, and persist the role if it has not been persisted yet.
+                RoleXmlDTO parentRole = (RoleXmlDTO) parent;
+                if (!parentRole.isAlreadyPersisted()) {
+                    RoleXmlUtil.validateAndPersistNewRole(parentRole);
+                }
+                roleId = parentRole.getRoleId();
+            }
+            super.beforeUnmarshal(unmarshaller, parent);
+        }
+        
+        public void newItemAdded(RolePermissionXmlDTO.WithinRole item) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRolePermission(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+        void beforeMarshal(Marshaller marshaller) {
+            // TODO: Use new API method once it becomes available!!!!
+            List<String> permissionIds = new ArrayList<String>();// KIMServiceLocator.getPermissionService().getRoleIdsForPermissionId(permissionId);
+            if (permissionIds != null && !permissionIds.isEmpty()) {
+                setRolePermissions(new RiceXmlExportList<RolePermissionXmlDTO.WithinRole,String>(permissionIds, this));
+            }
+        }
+        
+        void afterMarshal(Marshaller marshaller) {
+            setRolePermissions(null);
+        }
+
+        public RolePermissionXmlDTO.WithinRole gettingNextItem(String nextItem, int index) {
+            PermissionContract permission = KimApiServiceLocator.getPermissionService().getPermission(nextItem);
+            if (permission == null) {
+                throw new RuntimeException("Cannot find permission with ID \"" + nextItem + "\"");
+            }
+            return new RolePermissionXmlDTO.WithinRole(permission, false);
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java	(revision 32084)
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import javax.xml.bind.UnmarshalException;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.api.common.template.Template;
+import org.kuali.rice.kim.api.permission.Permission;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+/**
+ * Helper class containing static methods for aiding in parsing parsing XML.
+ * 
+ * <p>All non-private methods are package-private so that only the KIM-parsing-related code can make use of them. (TODO: Is that necessary?)
+ * 
+ * <p>TODO: Should this be converted into a service instead?
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class PermissionXmlUtil {
+    // Do not allow outside code to instantiate this class.
+    private PermissionXmlUtil() {}
+    
+    /**
+     * Validates a new permission and then saves it.
+     * 
+     * @param newPermission
+     * @throws IllegalArgumentException if newPermission is null.
+     * @throws UnmarshalException if newPermission contains invalid data.
+     */
+    static void validateAndPersistNewPermission(PermissionXmlDTO newPermission) throws UnmarshalException {
+        if (newPermission == null) {
+            throw new IllegalArgumentException("Cannot persist a null permission");
+        }
+        
+        // Validate the new permission.
+        validatePermission(newPermission);
+        
+        // Save the permission.
+        Permission.Builder builder = Permission.Builder.create(newPermission.getNamespaceCode(), newPermission.getPermissionName());
+        builder.setDescription(newPermission.getPermissionDescription());
+        builder.setActive(newPermission.getActive().booleanValue());
+        builder.setAttributes(newPermission.getPermissionDetails());
+        
+        KimApiServiceLocator.getPermissionService().createPermission(builder.build());
+    }
+
+    /**
+     * Validates a permission to ensure that the required fields have been filled.
+     * 
+     * @throws UnmarshalException if newPermission contains invalid data.
+     */
+    private static void validatePermission(PermissionXmlDTO newPermission) throws UnmarshalException {
+        // Ensure that the permission name, namespace, template, and description have been filled in.
+        if (StringUtils.isBlank(newPermission.getPermissionName()) || StringUtils.isBlank(newPermission.getNamespaceCode())) {
+            throw new UnmarshalException("Cannot create a permission with a blank name or namespace");
+        } else if (StringUtils.isBlank(newPermission.getPermissionTemplateId())) {
+            throw new UnmarshalException("Cannot create a permission without specifying a permission template");
+        } else if (StringUtils.isBlank(newPermission.getPermissionDescription())) {
+            throw new UnmarshalException("Cannot create a permission with a blank description");
+        }
+        
+        // If another permission with that name and namespace exists, use its ID on the new permission.
+        PermissionContract permission = KimApiServiceLocator.getPermissionService().getPermissionByName(newPermission.getNamespaceCode(), newPermission.getPermissionName());
+        if (permission != null) {
+            newPermission.setPermissionId(permission.getId());
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java	(revision 32084)
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.Set;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.core.util.jaxb.StringTrimmingAdapter;
+import org.kuali.rice.kim.api.jaxb.NameAndNamespacePairToKimTypeIdAdapter;
+import org.kuali.rice.kim.api.role.RoleContract;
+
+/**
+ * This class represents a &lt;role&gt; XML element.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="RoleType", propOrder={
+        "roleNameAndNamespace", "kimTypeId", "roleDescription", "active", "roleMembers", "rolePermissions"
+})
+public class RoleXmlDTO implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+
+    @XmlTransient
+    private String roleId;
+    
+    @XmlElement(name="roleName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair roleNameAndNamespace;
+    
+    @XmlElement(name="kimTypeName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairToKimTypeIdAdapter.class)
+    private String kimTypeId;
+    
+    @XmlElement(name="description")
+    @XmlJavaTypeAdapter(StringTrimmingAdapter.class)
+    private String roleDescription;
+    
+    @XmlElement(name="active")
+    private Boolean active;
+    
+    @XmlElement(name="roleMembers")
+    private RoleMembersXmlDTO.WithinRole roleMembers;
+    
+    @XmlElement(name="rolePermissions")
+    private RolePermissionsXmlDTO.WithinRole rolePermissions;
+
+    @XmlTransient
+    private boolean alreadyPersisted = false;
+    
+    @XmlTransient
+    private Set<String> existingRoleMemberIds;
+    
+    public RoleXmlDTO() {
+        this.active = Boolean.TRUE;
+    }
+    
+    public RoleXmlDTO(RoleContract role, RoleMembersXmlDTO.WithinRole roleMembers, RolePermissionsXmlDTO.WithinRole rolePermissions) {
+        if (role == null) {
+            throw new IllegalArgumentException("role cannot be null");
+        }
+        
+        this.roleNameAndNamespace = new NameAndNamespacePair(role.getNamespaceCode(), role.getName());
+        this.kimTypeId = role.getKimTypeId();
+        this.roleDescription = role.getDescription();
+        this.active = Boolean.valueOf(role.isActive());
+        this.roleMembers = roleMembers;
+        this.rolePermissions = rolePermissions;
+    }
+
+    /**
+     * @return the roleId
+     */
+    public String getRoleId() {
+        return this.roleId;
+    }
+
+    /**
+     * @param roleId the roleId to set
+     */
+    public void setRoleId(String roleId) {
+        this.roleId = roleId;
+    }
+
+    /**
+     * @return the roleNameAndNamespace
+     */
+    public NameAndNamespacePair getRoleNameAndNamespace() {
+        return this.roleNameAndNamespace;
+    }
+
+    /**
+     * @param roleNameAndNamespace the roleNameAndNamespace to set
+     */
+    public void setRoleNameAndNamespace(NameAndNamespacePair roleNameAndNamespace) {
+        this.roleNameAndNamespace = roleNameAndNamespace;
+    }
+
+    /**
+     * @return the kimTypeId
+     */
+    public String getKimTypeId() {
+        return this.kimTypeId;
+    }
+
+    /**
+     * @param kimTypeId the kimTypeId to set
+     */
+    public void setKimTypeId(String kimTypeId) {
+        this.kimTypeId = kimTypeId;
+    }
+
+    /**
+     * @return the roleDescription
+     */
+    public String getRoleDescription() {
+        return this.roleDescription;
+    }
+
+    /**
+     * @param roleDescription the roleDescription to set
+     */
+    public void setRoleDescription(String roleDescription) {
+        this.roleDescription = roleDescription;
+    }
+
+    /**
+     * @return the active
+     */
+    public Boolean getActive() {
+        return this.active;
+    }
+
+    /**
+     * @param active the active to set
+     */
+    public void setActive(Boolean active) {
+        this.active = active;
+    }
+
+    /**
+     * @return the roleMembers
+     */
+    public RoleMembersXmlDTO.WithinRole getRoleMembers() {
+        return this.roleMembers;
+    }
+
+    /**
+     * @param roleMembers the roleMembers to set
+     */
+    public void setRoleMembers(RoleMembersXmlDTO.WithinRole roleMembers) {
+        this.roleMembers = roleMembers;
+    }
+
+    /**
+     * @return the rolePermissions
+     */
+    public RolePermissionsXmlDTO.WithinRole getRolePermissions() {
+        return this.rolePermissions;
+    }
+
+    /**
+     * @param rolePermissions the rolePermissions to set
+     */
+    public void setRolePermissions(RolePermissionsXmlDTO.WithinRole rolePermissions) {
+        this.rolePermissions = rolePermissions;
+    }
+
+    /**
+     * @return the alreadyPersisted
+     */
+    public boolean isAlreadyPersisted() {
+        return this.alreadyPersisted;
+    }
+
+    /**
+     * @param alreadyPersisted the alreadyPersisted to set
+     */
+    public void setAlreadyPersisted(boolean alreadyPersisted) {
+        this.alreadyPersisted = alreadyPersisted;
+    }
+    
+    /**
+     * @return the existingRoleMemberIds
+     */
+    public Set<String> getExistingRoleMemberIds() {
+        return this.existingRoleMemberIds;
+    }
+
+    /**
+     * @param existingRoleMemberIds the existingRoleMemberIds to set
+     */
+    public void setExistingRoleMemberIds(Set<String> existingRoleMemberIds) {
+        this.existingRoleMemberIds = existingRoleMemberIds;
+    }
+
+    /**
+     * Retrieves the role's name from the role-name-and-namespace combo.
+     * 
+     * @return The name of the role, or null if the role-name-and-namespace combo is null.
+     */
+    public String getRoleName() {
+        return (roleNameAndNamespace != null) ? roleNameAndNamespace.getName() : null;
+    }
+
+    /**
+     * Retrieves the role's namespace code from the role-name-and-namespace combo.
+     * 
+     * @return The namespace code of the role, or null if the role-name-and-namespace combo is null.
+     */
+    public String getNamespaceCode() {
+        return (roleNameAndNamespace != null) ? roleNameAndNamespace.getNamespaceCode() : null;
+    }
+}
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java	(revision 32084)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+/**
+ * This class represents the &lt;permissionData&gt; element.
+ * 
+ * <p>The expected XML structure is as follows:
+ * 
+ * <br>
+ * <br>&lt;permissionData&gt;
+ * <br>&nbsp;&nbsp;&lt;permissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;permission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionName namespaceCode=""&gt;&lt;/permissionName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;templateName namespaceCode=""&gt;&lt;/templateName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;&lt;/description&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;active&gt;&lt;/active&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionDetails&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionDetail key=""&gt;&lt;/permissionDetail&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/permissionDetails&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/permission&gt;
+ * <br>&nbsp;&nbsp;&lt;/permissions&gt;
+ * <br>&lt;/permissionData&gt;
+ * 
+ * <p>Note the following:
+ * <ul>
+ *   <li>The &lt;permissions&gt; element is optional, and can contain zero or more &lt;permission&gt; elements.
+ *   <li>The &lt;permissionName&gt; element and its "namespaceCode" attribute are both required.
+ *   The namespace code must map to a valid namespace.
+ *   If the name and namespace combo matches an existing permission, then the permission in the XML
+ *   will overwrite the existing permission.
+ *   <li>The &lt;templateName&gt; element and its "namespaceCode" attribute are both required.
+ *   The name and namespace combo on this element must match a valid permission template.
+ *   <li>The &lt;description&gt; element is required, and must be non-blank.
+ *   <li>The &lt;active&gt; element is optional, and will be set to true if not specified.
+ *   <li>The &lt;permissionDetails&gt; element is optional, and can contain zero or more
+ *   &lt;permissionDetail&gt; elements.
+ *   <li>The &lt;permissionDetail&gt; element's "key" attribute is required, and must be non-blank.
+ *   Duplicate keys within a &lt;permissionDetails&gt; element are not permitted.
+ *   <li>The same permission can be ingested multiple times in the same file, where subsequent ones will
+ *   overwrite previous ones. (TODO: Is this acceptable?)
+ * </ul>
+ * 
+ * TODO: Verify that the above behavior is correct.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionDataType", propOrder={"permissions"})
+public class PermissionDataXmlDTO {
+
+    @XmlElement(name="permissions")
+    private PermissionsXmlDTO permissions;
+    
+    public PermissionDataXmlDTO() {}
+    
+    public PermissionDataXmlDTO(PermissionsXmlDTO permissions) {
+        this.permissions = permissions;
+    }
+
+    /**
+     * @return the permissions
+     */
+    public PermissionsXmlDTO getPermissions() {
+        return this.permissions;
+    }
+
+    /**
+     * @param permissions the permissions to set
+     */
+    public void setPermissions(PermissionsXmlDTO permissions) {
+        this.permissions = permissions;
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java	(revision 32084)
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.List;
+import java.util.Set;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.role.RoleContract;
+
+/**
+ * This class represents a &lt;roles&gt; element. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="RolesType", propOrder={"roles"})
+public class RolesXmlDTO implements RiceXmlListAdditionListener<RoleXmlDTO>, RiceXmlListGetterListener<RoleXmlDTO,Object>, Serializable {
+    
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="role")
+    private List<RoleXmlDTO> roles;
+    
+    public RolesXmlDTO() {}
+    
+    public RolesXmlDTO(List<? extends Object> rolesToExport) {
+        this.roles = new RiceXmlExportList<RoleXmlDTO,Object>(rolesToExport, this);
+    }
+    
+    public List<RoleXmlDTO> getRoles() {
+        return roles;
+    }
+
+    public void setRoles(List<RoleXmlDTO> roles) {
+        this.roles = roles;
+    }
+
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        roles = new RiceXmlImportList<RoleXmlDTO>(this);
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        roles = null;
+    }
+    
+    /**
+     * @see org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener#newItemAdded(java.lang.Object)
+     */
+    public void newItemAdded(RoleXmlDTO item) {
+        // Persist the role if it has not already been persisted yet.
+        if (!item.isAlreadyPersisted()) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRole(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+        // If a "roleMembers" element was present, remove any existing roles that do not match the new ones.
+        Set<String> existingRoleMemberIds = item.getExistingRoleMemberIds();
+        if (existingRoleMemberIds != null) {
+            RoleXmlUtil.removeRoleMembers(item.getRoleId(), existingRoleMemberIds);
+        }
+        item.setExistingRoleMemberIds(null);
+    }
+
+    void afterMarshal(Marshaller marshaller) {
+        roles = null;
+    }
+    
+    /**
+     * @see org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener#gettingNextItem(java.lang.Object, int)
+     */
+    public RoleXmlDTO gettingNextItem(Object nextItem, int index) {
+        if (!(nextItem instanceof RoleContract)) {
+            throw new IllegalStateException("Object for exportation should have been a role");
+        }
+        RoleContract role = ((RoleContract)nextItem);
+        return new RoleXmlDTO(role, new RoleMembersXmlDTO.WithinRole(role.getId()), new RolePermissionsXmlDTO.WithinRole(role.getId()));
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java	(revision 32084)
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Collections;
+import java.util.List;
+
+import org.kuali.rice.core.framework.impex.xml.XmlLoader;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.krad.bo.Exporter;
+import org.kuali.rice.krad.exception.ExportNotSupportedException;
+import org.kuali.rice.krad.util.KRADConstants;
+
+/**
+ * Imports and exports roles and permissions from/to XML via JAXB.
+ * 
+ * <p>TODO: Do we need to restrict XML additions or updates based on which user is performing the ingestion?
+ * 
+ * <p>TODO: It may be best to make this class into a "service" instead.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class KimImporterAndExporter implements XmlLoader, Exporter {
+
+    private final List<String> supportedFormats = Collections.singletonList(KRADConstants.XML_FORMAT);
+    
+    /**
+     * @see org.kuali.rice.core.framework.impex.xml.XmlLoader#loadXml(java.io.InputStream, java.lang.String)
+     */
+    @Override
+    public void loadXml(InputStream inputStream, String principalId) {
+        KimXmlUtil.parseKimXml(inputStream);
+    }
+
+    /**
+     * @see org.kuali.rice.krad.bo.Exporter#export(java.lang.Class, java.util.List, java.lang.String, java.io.OutputStream)
+     */
+    @Override
+    public void export(Class<?> dataObjectClass, List<? extends Object> dataObjects, String exportFormat,
+            OutputStream outputStream) throws IOException, ExportNotSupportedException {
+        if (!supportedFormats.contains(exportFormat)) {
+            throw new ExportNotSupportedException("The KimImporterAndExporter does not support the \"" + exportFormat + "\" export format");
+        }
+        
+        if (PermissionContract.class.isAssignableFrom(dataObjectClass)) {
+            KimXmlUtil.exportKimXml(outputStream, dataObjects, null);
+        } else if (RoleContract.class.isAssignableFrom(dataObjectClass)) {
+            KimXmlUtil.exportKimXml(outputStream, null, dataObjects);
+        } else {
+            throw new ExportNotSupportedException("The KimImporterAndExporter cannot export non-permission and non-role objects");
+        }
+        
+    }
+
+    /**
+     * @see org.kuali.rice.krad.bo.Exporter#getSupportedFormats(java.lang.Class)
+     */
+    @Override
+    public List<String> getSupportedFormats(Class<?> dataObjectClass) {
+        return supportedFormats;
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/sesn/DistributedSession.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/DistributedSession.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/DistributedSession.java	(revision 32084)
@@ -0,0 +1,278 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kim.sesn.timeouthandlers.TimeoutHandler;
+import org.springframework.dao.IncorrectResultSizeDataAccessException;
+import org.springframework.jdbc.core.JdbcTemplate;
+
+/**
+ * This class is used to interface with the distributed session database.
+ * 
+ * TODO: add clear principals to clearSesn
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class DistributedSession {
+    public static final String DEFAULT_PREFIX="DST";
+    private static String prefix = DEFAULT_PREFIX;
+    private JdbcTemplate jdbcTemplate;
+    private TimeoutHandler timeoutHandler;
+    private boolean allowInsertOnTouch = false;
+    
+    private static final Log logger = LogFactory.getLog(DistributedSession.class);
+
+    /**
+     * @param timeoutHandler the timeoutHandler to set
+     */
+    public void setTimeoutHandler(TimeoutHandler timeoutHandler) {
+        this.timeoutHandler = timeoutHandler;
+    }
+
+    /**
+     * @param jdbcTemplate the jdbcTemplate to set
+     */
+    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
+        this.jdbcTemplate = jdbcTemplate;
+    }
+    
+    /**
+     * This method determines if the Session Ticket is valid.
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @return true if the session is valid
+     */
+    public boolean isSesnValid(String DST) {
+        logger.debug("isSesnValid(DST)");
+        return isSesnValid (DST, new HashMap<String,Object>());
+    }
+    
+    /**
+     * This method determines if the Session Ticket is valid.
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @param timoutArgs - Additional information on which to base timeouts
+     * @return true if the session is valid
+     */
+    public boolean isSesnValid(String DST, Map<String,Object> timeoutArgs) {
+        logger.debug("isSesnValid(DST, timeoutArgs)");
+        boolean bRet = false;
+        String sql = "select sesnID, lastAccessDt, maxIdleTime from authnsesn where sesnID=?";
+        
+        if (DST != null) {
+            Object[] args = { DST };
+            
+            try {
+                Map<String,Object> fields = jdbcTemplate.queryForMap(sql, args);
+                fields.put("maxIdleTime", this.getMaxIdleTime((Long)fields.get("maxIdleTime"), (Date)fields.get("lastAccessDt")));
+                fields.putAll(timeoutArgs);
+                
+                if (logger.isDebugEnabled()) {
+                    logger.debug("ARGUMENTS number:" + fields.size());
+                    for (Iterator<Map.Entry<String,Object>> i = fields.entrySet().iterator(); i.hasNext(); ) {
+                        Map.Entry<String,Object> entry = (Map.Entry<String,Object>)i.next();
+                        logger.debug("ARGUMENT " + entry.getKey() + ":" + entry.getValue());
+                    }
+                }
+                
+                if(!timeoutHandler.hasTimedOut(fields)) {
+                    logger.debug("Session not timed out");
+                    bRet = true;
+                } else {
+                    logger.debug("Session timed out");
+                }
+            } catch (Exception e) {
+                logger.debug(e);
+            }
+        } 
+        else {
+            logger.debug("Session ID is null");           
+        }
+                
+        return bRet;
+    }
+    
+    
+    /**
+     * This method returns the list of principals currently authenticated
+     * that are associated with the provided Distributed Session Ticket
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @return the List of authenticated principals
+     */
+    public List<String> getAuthenticatedPricipals(String DST) {
+        String sql = "select principalID from authnsesn where sesnID=?";
+        Object args[] = { DST };
+        
+        return jdbcTemplate.queryForList(sql, args, String.class);
+    }
+    
+    /**
+     * This method removes the session
+     * 
+     * @param DST - the Distributed Session Ticket
+     */
+    public void clearSesn(String DST) {
+        String sql = "delete from authnsesn where sesnID='" + DST + "'";
+        
+        jdbcTemplate.execute(sql);
+    }
+    
+    
+    /**
+     * This method takes an authenticated principal and generates a
+     * Distributed Session Ticket and updates the session database
+     * 
+     * @param principalID - the id of the authenticated entity
+     * @return DST - the Distributed Session Ticket
+     */
+    public String createSesn(String principalID) {
+        String DST = this.generateDST();
+        
+        this.touchSesn(DST);
+        this.addPrincipalToSesn(DST, principalID);
+
+        return DST;
+    }
+    
+    /**
+     * This method generates a unique Distributed Session Ticket
+     * 
+     * @return DST - the Distributed Session Ticket
+     */
+    public String generateDST() {
+        return prefix + "-" + SessionIdGenerator.getNewString();
+    }
+    
+    /**
+     * This method updates the session
+     * 
+     * @param DST - the Distributed Session Ticket
+     */
+    public void touchSesn(String DST) {
+        String sql = "select lastAccessDt, maxIdleTime from authnsesn where sesnID=?";
+        String updateSql = "";
+        Object[] args = { DST },
+               updateArgs;
+        Long maxIdleTime;
+        
+        try {
+            if (logger.isDebugEnabled()) {
+                logger.debug("ARGUMENTS number:" + args.length);
+                logger.debug("ARGUMENTS 0:" + args[0]);
+            }
+            Map<String,Object> fields = jdbcTemplate.queryForMap(sql, args);
+            Date lastAccessDt = (Date)fields.get("lastAccessDt");
+            if (logger.isDebugEnabled()) {
+                logger.debug("Last Access:" + lastAccessDt);
+            }
+            maxIdleTime = getMaxIdleTime((Long)fields.get("maxIdleTime"), lastAccessDt);
+            
+            
+            updateSql = "update authnsesn set lastAccessDt=NOW(), maxIdleTime = ? where sesnID=?";
+            updateArgs = new Object[] { maxIdleTime, DST };
+            jdbcTemplate.update(updateSql, updateArgs);
+        } 
+        // catch if no or more than 1 results are returned
+        catch (IncorrectResultSizeDataAccessException ex) {
+            if (this.allowInsertOnTouch) {
+                maxIdleTime = new Long(0);
+                
+                updateSql = "insert into authnsesn (sesnID, insertDt, lastAccessDt, maxIdleTime) values (?, NOW(), NOW(), ?)";
+                updateArgs = new Object[] { DST, maxIdleTime };
+                jdbcTemplate.update(updateSql, updateArgs);
+            }
+        }
+    }
+    
+    
+    /**
+     * This method returns the greater of the stored max idle time and 
+     * time since last access
+     * 
+     * @param oldMaxIdleTime - the previous max idle time
+     * @param lastAccessDt - the timestamp of last access
+     * @return the max idle time
+     */
+    public Long getMaxIdleTime(Long oldMaxIdleTime, Date lastAccessDt) {
+        Long maxIdleTime = oldMaxIdleTime;
+        
+        if (logger.isDebugEnabled()) {
+            logger.debug("Max Idle:" + maxIdleTime);
+        }
+        long curIdleTime = System.currentTimeMillis()-lastAccessDt.getTime();
+        if (logger.isDebugEnabled()) {
+            logger.debug("Curr Idle:" + curIdleTime);
+        }
+        if (curIdleTime > maxIdleTime) {
+            maxIdleTime = new Long(curIdleTime);
+        }
+        
+        return maxIdleTime;
+    }
+    
+    /**
+     * This method appends a principal to an active session
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @param principalID - the id of the authenticated entity
+     */
+    public void addPrincipalToSesn(String DST, String principalID) {
+        // this will fail if the record already exists 
+        try {
+            String updateSql = "insert into authnsesnprincipal (sesnID, principalID) values (?, ?)";
+            
+            jdbcTemplate.update(updateSql, new Object[] { DST, principalID });
+            if (logger.isDebugEnabled()) {
+                logger.debug("Added Principal to Sesn:" + principalID + " " + DST);
+            }
+        }
+        catch (Exception e) {
+            if (logger.isDebugEnabled()) {
+                logger.debug("Principal Probably already exists:" + principalID + " " + DST);
+            }
+        }
+    }
+
+    /**
+     * @return the prefix
+     */
+    public static String getPrefix() {
+        return DistributedSession.prefix;
+    }
+
+    /**
+     * @param prefix the prefix to set
+     */
+    public static void setPrefix(String prefix) {
+        DistributedSession.prefix = prefix;
+    }
+
+    /**
+     * @param allowInsertOnTouch the allowInsertOnTouch to set
+     */
+    public void setAllowInsertOnTouch(boolean allowInsertOnTouch) {
+        this.allowInsertOnTouch = allowInsertOnTouch;
+    }
+}
Index: work/src/org/kuali/rice/kim/sesn/SessionIdGenerator.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/SessionIdGenerator.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/SessionIdGenerator.java	(revision 32084)
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn;
+
+import java.security.SecureRandom;
+
+/**
+ * This class generates a random string for creating Distributed Session Tickets 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class SessionIdGenerator {
+
+    /** The array of printable characters to be used in our random string. */
+    private static final char[] PRINTABLE_CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345679"
+        .toCharArray();
+
+    private static final SecureRandom randomizer = new SecureRandom();
+
+    public static String getNewString() {
+        final byte[] random = getNewStringAsBytes();
+
+        return convertBytesToString(random);
+    }
+
+
+    private static byte[] getNewStringAsBytes() {
+        final byte[] random = new byte[40];
+
+        randomizer.nextBytes(random);
+        
+        return random;
+    }
+
+    private static String convertBytesToString(final byte[] random) {
+        final char[] output = new char[random.length];
+        for (int i = 0; i < random.length; i++) {
+            final int index = Math.abs(random[i] % PRINTABLE_CHARACTERS.length);
+            output[i] = PRINTABLE_CHARACTERS[index];
+        }
+
+        return new String(output);
+    }
+}
Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/TimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/TimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/TimeoutHandler.java	(revision 32084)
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+import java.util.Map;
+
+/**
+ * This interface allows different methods for handling timeouts for Authentication
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public interface TimeoutHandler {
+    
+    /**
+     * Determines the timeout based on the context and initiator
+     *
+     * @param args the args passed depends on the requirements of the TimeoutHandler Implementation
+     *
+     * @return the timeout in seconds.  Returns 0 to disable timeouts.
+     */
+    public int getTimeout(Map<String,Object> args);
+    
+    
+    /**
+     * Determines if the timeout has expired
+     *
+     * @param args the args passed depends on the requirements of the TimeoutHandler Implementation
+     *
+     * @return true if the session has timed out.
+     */
+    public boolean hasTimedOut(Map<String,Object> args);
+
+}
Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/GlobalTimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/GlobalTimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/GlobalTimeoutHandler.java	(revision 32084)
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * This class uses the same timeout for all authentication methods and applications
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class GlobalTimeoutHandler extends AbstractTimeoutHandler {
+    private int timeoutPeriod;
+    
+    private static final Log logger = LogFactory.getLog(GlobalTimeoutHandler.class);
+
+    /**
+     * @return the timeoutPeriod
+     */
+    public int getTimeoutPeriod() {
+        return this.timeoutPeriod;
+    }
+
+    /**
+     * @param timeoutPeriod the timeoutPeriod to set
+     */
+    public void setTimeoutPeriod(int timeoutPeriod) {
+        this.timeoutPeriod = timeoutPeriod;
+    }
+
+    /**
+     * Determines the timeout based on the context and initiator
+     *
+     * @param args the args in this implementation aren't used
+     *
+     * @return the timeout in seconds
+     */
+    public int getTimeout(Map args) {
+        return timeoutPeriod; 
+    }
+    
+    /**
+     * 
+     * Examines results from session to determine if timeout has expired 
+     * 
+     * @see org.kuali.rice.kim.client.timeouthandlers.TimeoutHandler#hasTimedOut(java.lang.Object[])
+     */
+    public boolean hasTimedOut(Map args) {
+        boolean bRet = true;
+        Long maxIdleTime = (Long)args.get("maxIdleTime");
+        
+        if (maxIdleTime <= timeoutPeriod) {
+            logger.debug("Not timed out: " + maxIdleTime + " " + timeoutPeriod);
+            bRet = false;
+        } else {
+            logger.debug("Timed out: " + maxIdleTime + " " + timeoutPeriod);
+        }
+        return bRet;
+    }
+
+}
+
Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/AbstractTimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/AbstractTimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/AbstractTimeoutHandler.java	(revision 32084)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+/**
+ * This Abstract Class allows the configuration of timeout fields.
+ * TODO: change how TimoutHandlers choose fields from ndx to name.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public abstract class AbstractTimeoutHandler implements TimeoutHandler{
+
+    private static final int MAX_IDLE_TIME_TIMEOUT_FIELD=1;
+    private static final int LAST_ACCCESS_TIMEOUT_FIELD=2;
+    private static final int DEFAULT_TIMEOUT_FIELD=MAX_IDLE_TIME_TIMEOUT_FIELD; 
+    private int timeoutField=AbstractTimeoutHandler.DEFAULT_TIMEOUT_FIELD;
+    
+    /**
+     * @return the timeoutField
+     */
+    public int getTimeoutField() {
+        return this.timeoutField;
+    }
+    /**
+     * @param timeoutField the timeoutField to set
+     */
+    public void setTimeoutField(int timeoutField) {
+        this.timeoutField = timeoutField;
+    }
+
+}
+
Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/DisabledTimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/DisabledTimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/DisabledTimeoutHandler.java	(revision 32084)
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+import java.util.Map;
+
+/**
+ * This is a description of what this class does - lsymms don't forget to fill this in. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class DisabledTimeoutHandler implements TimeoutHandler{
+    
+    /**
+     * @return false
+     * @see org.kuali.rice.kim.client.timeouthandlers.TimeoutHandler#hasTimedOut(java.lang.Object[])
+     */
+    public boolean hasTimedOut(Map<String,Object> args) {
+        // TODO lsymms - THIS METHOD NEEDS JAVADOCS
+        return false;
+    }
+
+    /**
+     * Determines the timeout based on the context and initiator
+     *
+     * @param args the args in this implementation aren't used
+     *
+     * @return 0 which disables the timeout.
+     */
+    public int getTimeout(Map<String,Object> args) {
+        return 0;
+    }
+}
+
Index: work/src/org/kuali/rice/kim/api/role/RoleManagementService.java
===================================================================
--- work/src/org/kuali/rice/kim/api/role/RoleManagementService.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/role/RoleManagementService.java	(revision 32084)
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.role;
+
+/**
+ * This service adds caching on top of the RoleService. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public interface RoleManagementService extends RoleService, RoleUpdateService {
+
+	/**
+	 * Flush all of the role-related caches.
+	 */
+	void flushRoleCaches();
+	
+	/**
+	 * Flush all of the role-member-related caches.
+	 */
+	void flushRoleMemberCaches();
+	
+	/**
+	 * Flush all of the delegation-related caches.
+	 */
+	void flushDelegationCaches();
+
+	/**
+	 * Flush all of the delegation-member-related caches.
+	 */
+	void flushDelegationMemberCaches();
+	
+	/**
+	 * Remove all cache entries for the given roleId and principalId combination.
+	 */
+	void removeCacheEntries( String roleId, String principalId );
+}

Property changes on: work/src/org/kuali/rice/kim/api/role/RoleManagementService.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java
===================================================================
--- work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java	(revision 32084)
@@ -0,0 +1,173 @@
+/*
+ * Copyright 2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.role;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.exception.RiceIllegalArgumentException;
+import org.kuali.rice.core.api.uif.RemotableAttributeError;
+import org.kuali.rice.kim.api.type.KimAttributeField;
+import org.kuali.rice.kim.framework.role.RoleTypeService;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+public abstract class PassThruRoleTypeServiceBase implements RoleTypeService {
+
+	private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(PassThruRoleTypeServiceBase.class);
+	
+	public static final String UNMATCHABLE_QUALIFICATION = "!~!~!~!~!~";
+
+    @Override
+	public abstract Map<String, String> convertQualificationForMemberRoles(String namespaceCode, String roleName, String memberRoleNamespaceCode, String memberRoleName, Map<String, String> qualification);
+    
+    @Override
+	public List<RoleMembership> getMatchingRoleMemberships(Map<String, String> qualification,
+            List<RoleMembership> roleMemberList) {
+
+        if (qualification == null) {
+            throw new RiceIllegalArgumentException("qualification was null");
+        }
+
+        if (roleMemberList == null) {
+            throw new RiceIllegalArgumentException("roleMemberList was null");
+        }
+        return Collections.unmodifiableList(new ArrayList<RoleMembership>(roleMemberList));
+    }
+
+    @Override
+	public boolean doesRoleQualifierMatchQualification(Map<String, String> qualification, Map<String, String> roleQualifier) {
+        if (qualification == null) {
+            throw new RiceIllegalArgumentException("qualification was null");
+        }
+
+        if (roleQualifier == null) {
+            throw new RiceIllegalArgumentException("roleQualifier was null");
+        }
+
+        return true;
+    }
+    
+    @Override
+	public boolean hasApplicationRole(String principalId, List<String> groupIds, String namespaceCode, String roleName, Map<String, String> qualification) {
+        if (StringUtils.isBlank(principalId)) {
+            throw new RiceIllegalArgumentException("principalId was null or blank");
+        }
+
+        if (groupIds == null) {
+            throw new RiceIllegalArgumentException("groupIds was null or blank");
+        }
+
+        if (StringUtils.isBlank(namespaceCode)) {
+            throw new RiceIllegalArgumentException("namespaceCode was null or blank");
+        }
+
+        if (StringUtils.isBlank(roleName)) {
+            throw new RiceIllegalArgumentException("roleName was null or blank");
+        }
+
+        if (qualification == null) {
+            throw new RiceIllegalArgumentException("qualification was null");
+        }
+
+        return false;
+    }
+
+    @Override
+	public boolean isApplicationRoleType() {
+        return false;
+    }
+
+    public List<String> getAcceptedAttributeNames() {
+        return Collections.emptyList();
+    }
+
+    @Override
+	public List<KimAttributeField> getAttributeDefinitions(String kimTypeId) {
+        if (StringUtils.isBlank(kimTypeId)) {
+            throw new RiceIllegalArgumentException("kimTypeId was null or blank");
+        }
+
+        return Collections.emptyList();
+    }
+
+    @Override
+	public String getWorkflowDocumentTypeName() {
+        return null;
+    }
+
+    @Override
+	public List<String> getWorkflowRoutingAttributes(String routeLevel) {
+    	if (StringUtils.isBlank(routeLevel)) {
+            throw new RiceIllegalArgumentException("routeLevel was null or blank");
+        }
+
+        return Collections.emptyList();
+    }
+
+    public boolean supportsAttributes(List<String> attributeNames) {
+        return true;
+    }
+
+    public Map<String, String> translateInputAttributes(Map<String, String> inputAttributes) {
+        return inputAttributes;
+    }
+
+    @Override
+	public List<RemotableAttributeError> validateAttributes(String kimTypeId, Map<String, String> attributes) {
+        if (StringUtils.isBlank(kimTypeId)) {
+            throw new RiceIllegalArgumentException("kimTypeId was null or blank");
+        }
+
+        if (attributes == null) {
+            throw new RiceIllegalArgumentException("attributes was null or blank");
+        }
+
+        return Collections.emptyList();
+    }
+    
+	@Override
+	public List<RemotableAttributeError> validateAttributesAgainstExisting(String kimTypeId, Map<String, String> newAttributes, Map<String, String> oldAttributes){
+		if (StringUtils.isBlank(kimTypeId)) {
+            throw new RiceIllegalArgumentException("kimTypeId was null or blank");
+        }
+
+        if (newAttributes == null) {
+            throw new RiceIllegalArgumentException("newAttributes was null or blank");
+        }
+
+        if (oldAttributes == null) {
+            throw new RiceIllegalArgumentException("oldAttributes was null or blank");
+        }
+
+        return Collections.emptyList();
+	}
+
+	@Override
+	public boolean dynamicRoleMembership(String namespaceCode, String roleName) {
+	    if (StringUtils.isBlank(namespaceCode)) {
+            throw new RiceIllegalArgumentException("namespaceCode was null or blank");
+        }
+
+	    if (StringUtils.isBlank(roleName)) {
+            throw new RiceIllegalArgumentException("roleName was null or blank");
+        }
+
+        return false;
+	}
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java
===================================================================
--- work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java	(revision 32084)
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2008-2009 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.services;
+
+import org.kuali.rice.core.api.criteria.QueryByCriteria;
+import org.kuali.rice.kim.api.common.assignee.Assignee;
+import org.kuali.rice.kim.api.group.Group;
+import org.kuali.rice.kim.api.identity.Type;
+import org.kuali.rice.kim.api.identity.affiliation.EntityAffiliationType;
+import org.kuali.rice.kim.api.identity.entity.Entity;
+import org.kuali.rice.kim.api.identity.entity.EntityDefault;
+import org.kuali.rice.kim.api.identity.entity.EntityDefaultQueryResults;
+import org.kuali.rice.kim.api.identity.entity.EntityQueryResults;
+import org.kuali.rice.kim.api.identity.external.EntityExternalIdentifierType;
+import org.kuali.rice.kim.api.identity.principal.Principal;
+import org.kuali.rice.kim.api.permission.Permission;
+import org.kuali.rice.kim.api.responsibility.Responsibility;
+import org.kuali.rice.kim.api.responsibility.ResponsibilityAction;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * This is the front end for the KIM module.  Clients of KIM should access this service from
+ * their applications.  If KIM is not running on the same machine (VM) as the application
+ * (as would be the case with a standalone Rice server), then this service should be implemented
+ * locally within the application and access the core KIM services
+ * (Authentication/Authorization/Identity/Group) via the service bus.
+ *
+ *  For efficiency, implementations of this interface should add appropriate caching of
+ *  the information retrieved from the core services for load and performance reasons.
+ *
+ *  Most of the methods on this interface are straight pass-thrus to methods on the four core services.
+ *
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public interface IdentityManagementService {
+
+	// *******************************
+	// IdentityService
+	// *******************************
+
+	Principal getPrincipal( String principalId);
+	Principal getPrincipalByPrincipalName( String principalName);
+
+	Principal getPrincipalByPrincipalNameAndPassword(
+             String principalName,
+             String password
+    );
+
+	EntityDefault getEntityDefaultInfo( String entityId);
+	EntityDefault getEntityDefaultInfoByPrincipalId( String principalId);
+	EntityDefault getEntityDefaultInfoByPrincipalName( String principalName);
+
+    EntityDefaultQueryResults findEntityDefaults(QueryByCriteria queryByCriteria);
+
+	//KimEntityPrivacyPreferencesInfo getEntityPrivacyPreferences(String entityId);
+
+	Entity getEntity( String entityId);
+	Entity getEntityByPrincipalId( String principalId);
+	Entity getEntityByPrincipalName( String principalName);
+
+	EntityQueryResults findEntities(QueryByCriteria queryByCriteria);
+
+	Type getAddressType( String code);
+	EntityAffiliationType getAffiliationType( String code);
+	Type getCitizenshipStatus( String code);
+	Type getEmailType( String code);
+	Type getEmploymentStatus( String code);
+	Type getEmploymentType( String code);
+	Type getEntityNameType( String code);
+	Type getEntityType( String code);
+	EntityExternalIdentifierType getExternalIdentifierType( String code);
+	Type getPhoneType( String code);
+
+	// *******************************
+	// GroupService
+	// *******************************
+
+	Group getGroup( String groupId);
+
+    Group getGroupByName(
+             String namespaceCode,
+             String groupName
+    );
+
+    List<String> getParentGroupIds( String groupId);
+    List<String> getDirectParentGroupIds( String groupId);
+
+    
+    List<String> getGroupIdsForPrincipal( String principalId);
+
+    
+    List<String> getGroupIdsForPrincipal(
+             String principalId,
+             String namespaceCode
+    );
+
+    
+    List<? extends Group> getGroupsForPrincipal( String principalId);
+
+    
+    List<? extends Group> getGroupsForPrincipal(
+             String principalId,
+             String namespaceCode
+    );
+
+    List<String> getMemberGroupIds( String groupId);
+    List<String> getDirectMemberGroupIds( String groupId);
+
+    
+	boolean isMemberOfGroup(
+             String principalId,
+             String groupId
+    );
+
+    
+	boolean isMemberOfGroup(
+             String principalId,
+             String namespaceCode,
+             String groupName
+    );
+
+	boolean isGroupMemberOfGroup(
+             String potentialMemberGroupId,
+             String potentialParentId
+    );
+
+	List<String> getGroupMemberPrincipalIds( String groupId);
+	List<String> getDirectGroupMemberPrincipalIds( String groupId);
+
+    boolean addGroupToGroup(
+             String childId,
+             String parentId
+    );
+
+    boolean removeGroupFromGroup(
+             String childId,
+             String parentId
+    );
+
+    boolean addPrincipalToGroup(
+             String principalId,
+             String groupId
+    );
+
+    boolean removePrincipalFromGroup(
+             String principalId,
+             String groupId
+    );
+
+    Group createGroup( Group group);
+    void removeAllMembers( String groupId);
+
+    Group updateGroup(
+             String groupId,
+             Group group
+    );
+
+    // --------------------
+    // Authorization Checks
+    // --------------------
+
+    boolean hasPermission(
+             String principalId,
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails
+    );
+
+    boolean isAuthorized(
+             String principalId,
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    boolean hasPermissionByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String permissionTemplateName,
+              Map<String, String> permissionDetails
+    );
+
+    boolean isAuthorizedByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String permissionTemplateName,
+             Map<String, String> permissionDetails,
+             Map<String, String> qualification
+    );
+
+    /**
+     * Returns the matching permission objects for a principal.
+     */
+    List<Permission> getAuthorizedPermissions(
+             String principalId,
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    List<Permission> getAuthorizedPermissionsByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String permissionTemplateName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    List<Assignee> getPermissionAssignees(
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    List<Assignee> getPermissionAssigneesForTemplateName(
+             String namespaceCode,
+             String permissionTemplateName,
+             Map<String, String> permissionDetails,
+             Map<String, String> qualification
+    );
+
+    // ----------------------
+    // Responsibility Methods
+    // ----------------------
+
+    /**
+     * Get the responsibility object with the given ID.
+     */
+    Responsibility getResponsibility( String responsibilityId);
+
+ 	/**
+ 	 * Return the responsibility object for the given unique combination of namespace,
+ 	 * component and responsibility name.
+ 	 */
+    Responsibility getResponsibilityByName(
+             String namespaceCode,
+             String responsibilityName
+    );
+
+    /**
+     * Check whether the principal has the given responsibility within the passed qualifier.
+     */
+    boolean hasResponsibility(
+             String principalId,
+             String namespaceCode,
+             String responsibilityName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    /**
+     * Check whether the principal has the given responsibility within the passed qualifier.
+     */
+    boolean hasResponsibilityByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String responsibilityTemplateName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    List<ResponsibilityAction> getResponsibilityActions(
+             String namespaceCode,
+             String responsibilityName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    List<ResponsibilityAction> getResponsibilityActionsByTemplateName(
+             String namespaceCode,
+             String responsibilityTemplateName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    /**
+     * Returns true if there are any assigned permissions with the given template.
+     */
+    boolean isPermissionDefinedForTemplateName(
+             String namespaceCode,
+             String permissionTemplateName,
+              Map<String, String> permissionDetails
+    );
+
+
+    // ----------------------
+    // Cache Flush Methods
+    // ----------------------
+
+    void flushAllCaches();
+    void flushEntityPrincipalCaches();
+	void flushGroupCaches();
+	void flushPermissionCaches();
+	void flushResponsibilityCaches();
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java	(revision 32084)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import javax.xml.bind.MarshalException;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+import org.kuali.rice.kim.api.type.KimTypeContract;
+
+/**
+ * An XML adapter that converts between a NameAndNamespacePair and a KIM type ID.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class NameAndNamespacePairToKimTypeIdAdapter extends XmlAdapter<NameAndNamespacePair,String> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public String unmarshal(NameAndNamespacePair v) throws Exception {
+        if (v != null) {
+            KimTypeContract kimType = KimApiServiceLocator.getKimTypeInfoService().findKimTypeByNameAndNamespace(
+                    v.getNamespaceCode(), new NormalizedStringAdapter().unmarshal(v.getName()));
+            if (kimType == null) {
+                throw new UnmarshalException("Cannot find KIM Type with namespace \"" + v.getNamespaceCode() + "\" and name \"" + v.getName() + "\"");
+            }
+            return kimType.getId();
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public NameAndNamespacePair marshal(String v) throws Exception {
+        if (v != null) {
+            KimTypeContract kimType = KimApiServiceLocator.getKimTypeInfoService().getKimType(StringUtils.trim(v));
+            if (kimType == null) {
+                throw new MarshalException("Cannot find KIM Type with ID \"" + v + "\"");
+            }
+            return new NameAndNamespacePair(kimType.getNamespaceCode(), kimType.getName());
+        }
+        return null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java	(revision 32084)
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.kuali.rice.core.api.util.jaxb.StringMapEntry;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An XML element that can have zero or more StringMapEntry elements. This is similar
+ * to the StringMapEntryList, except this element's children are &lt;qualification&gt; elements.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="QualificationListType", propOrder={"qualifications"})
+public class QualificationList implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="qualification")
+    private List<StringMapEntry> qualifications;
+    
+    public QualificationList () {
+        qualifications = new ArrayList<StringMapEntry>();
+    }
+    
+    public QualificationList(Map<String, String> map) {
+        this();
+        for (Map.Entry<String,String> tempEntry : map.entrySet()) {
+            qualifications.add(new StringMapEntry(tempEntry));
+        }
+    }
+
+    /**
+     * @return the qualifications
+     */
+    public List<StringMapEntry> getQualifications() {
+        return this.qualifications;
+    }
+
+    /**
+     * @param qualifications the qualifications to set
+     */
+    public void setQualifications(List<StringMapEntry> qualifications) {
+        this.qualifications = qualifications;
+    }
+
+    
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/package-info.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/package-info.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/package-info.java	(revision 32084)
@@ -0,0 +1,6 @@
+@javax.xml.bind.annotation.XmlSchema(namespace = KimApiConstants.Namespaces.KIM_NAMESPACE_2_0, elementFormDefault = XmlNsForm.QUALIFIED)
+package org.kuali.rice.kim.api.jaxb;
+
+import javax.xml.bind.annotation.XmlNsForm;
+
+import org.kuali.rice.kim.api.KimApiConstants;
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/package-info.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java	(revision 32084)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.util.jaxb.StringMapEntry;
+
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An XML adapter that converts between QualificationList objects and Map<String, String> objects.
+ * Unmarshalled keys and values will automatically be trimmed if non-null.
+ * 
+ * <p>This adapter will throw an exception during unmarshalling if blank or duplicate keys are encountered.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class QualificationListAdapter extends XmlAdapter<QualificationList,Map<String, String>> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public Map<String, String> unmarshal(QualificationList v) throws Exception {
+        if (v != null) {
+            NormalizedStringAdapter normalizedStringAdapter = new NormalizedStringAdapter();
+            Map<String, String> map = new HashMap<String, String>();
+            for (StringMapEntry stringMapEntry : v.getQualifications()) {
+                String tempKey = normalizedStringAdapter.unmarshal(stringMapEntry.getKey());
+                if (StringUtils.isBlank(tempKey)) {
+                    throw new UnmarshalException("Cannot create a qualification entry with a blank key");
+                } else if (map.containsKey(tempKey)) {
+                    throw new UnmarshalException("Cannot create more than one qualification entry with a key of \"" + tempKey + "\"");
+                }
+                map.put(tempKey, normalizedStringAdapter.unmarshal(stringMapEntry.getValue()));
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public QualificationList marshal(Map<String, String> v) throws Exception {
+        return (v != null) ? new QualificationList(v) : null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java	(revision 32084)
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.kuali.rice.core.api.util.jaxb.StringMapEntry;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An XML element that can have zero or more StringMapEntry elements. This is similar
+ * to the StringMapEntryList, except this element's children are &lt;permissionDetail&gt; elements.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionDetailListType", propOrder={"permissionDetails"})
+public class PermissionDetailList implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="permissionDetail")
+    private List<StringMapEntry> permissionDetails;
+    
+    public PermissionDetailList() {
+        this.permissionDetails = new ArrayList<StringMapEntry>();
+    }
+    
+    public PermissionDetailList(Map<String, String> map) {
+        this();
+        for (Map.Entry<String,String> tempEntry : map.entrySet()) {
+            permissionDetails.add(new StringMapEntry(tempEntry));
+        }
+    }
+
+    /**
+     * @return the permissionDetails
+     */
+    public List<StringMapEntry> getPermissionDetails() {
+        return this.permissionDetails;
+    }
+
+    /**
+     * @param permissionDetails the permissionDetails to set
+     */
+    public void setPermissionDetails(List<StringMapEntry> permissionDetails) {
+        this.permissionDetails = permissionDetails;
+    }
+    
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java	(revision 32084)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.util.jaxb.StringMapEntry;
+
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An XML adapter that converts between PermissionDetailList objects and Map<String, String> objects.
+ * Unmarshalled keys and values will automatically be trimmed if non-null.
+ * 
+ * <p>This adapter will throw an exception during unmarshalling if blank or duplicate keys are encountered.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class PermissionDetailListAdapter extends XmlAdapter<PermissionDetailList,Map<String, String>> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public Map<String, String> unmarshal(PermissionDetailList v) throws Exception {
+        if (v != null) {
+            NormalizedStringAdapter normalizedStringAdapter = new NormalizedStringAdapter();
+            Map<String, String> map = new HashMap<String, String>();
+            for (StringMapEntry stringMapEntry : v.getPermissionDetails()) {
+                String tempKey = normalizedStringAdapter.unmarshal(stringMapEntry.getKey());
+                if (StringUtils.isBlank(tempKey)) {
+                    throw new UnmarshalException("Cannot create a permission detail entry with a blank key");
+                } else if (map.containsKey(tempKey)) {
+                    throw new UnmarshalException("Cannot create more than one permission detail entry with a key of \"" + tempKey + "\"");
+                }
+                map.put(tempKey, normalizedStringAdapter.unmarshal(stringMapEntry.getValue()));
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public PermissionDetailList marshal(Map<String, String> v) throws Exception {
+        return (v != null) ? new PermissionDetailList(v) : null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java	(revision 32084)
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import javax.xml.bind.MarshalException;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+import org.kuali.rice.kim.api.common.template.Template;
+
+/**
+ * An XML adapter that converts between a NameAndNamespacePair and a permission template ID.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class NameAndNamespacePairToPermTemplateIdAdapter extends XmlAdapter<NameAndNamespacePair,String> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public String unmarshal(NameAndNamespacePair v) throws Exception {
+        if (v != null) {
+            Template permissionTemplate = KimApiServiceLocator.getPermissionService().getPermissionTemplateByName(
+                    v.getNamespaceCode(), new NormalizedStringAdapter().unmarshal(v.getName()));
+            if (permissionTemplate == null) {
+                throw new UnmarshalException("Cannot find permission template with namespace \"" + v.getNamespaceCode() + "\" and name \"" + v.getName() + "\"");
+            }
+            return permissionTemplate.getId();
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public NameAndNamespacePair marshal(String v) throws Exception {
+        if (v != null) {
+            Template permissionTemplate = KimApiServiceLocator.getPermissionService().getPermissionTemplate(v);
+            if (permissionTemplate == null) {
+                throw new MarshalException("Cannot find permission template with ID \"" + v + "\"");
+            }
+            return new NameAndNamespacePair(permissionTemplate.getNamespaceCode(), permissionTemplate.getName());
+        }
+        return null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/util/KimCommonUtils.java
===================================================================
--- work/src/org/kuali/rice/kim/util/KimCommonUtils.java	(revision 0)
+++ work/src/org/kuali/rice/kim/util/KimCommonUtils.java	(revision 32084)
@@ -0,0 +1,373 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.util;
+
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+
+import org.apache.commons.beanutils.PropertyUtils;
+import org.apache.commons.lang.StringUtils;
+import org.kuali.kfs.sys.context.SpringContext;
+import org.kuali.rice.core.api.config.property.ConfigurationService;
+import org.kuali.rice.kew.doctype.bo.DocumentType;
+
+/**
+ * This is a description of what this class does - bhargavp don't forget to fill
+ * this in.
+ *
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class KimCommonUtils {
+    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KimCommonUtils.class);
+
+    public static String getClosestParentDocumentTypeName(
+            DocumentType documentType,
+            Set<String> potentialParentDocumentTypeNames) {
+        if ( potentialParentDocumentTypeNames == null || documentType == null ) {
+            return null;
+        }
+        if (potentialParentDocumentTypeNames.contains(documentType.getName())) {
+            return documentType.getName();
+        } else {
+            if ((documentType.getDocTypeParentId() == null)
+                    || documentType.getDocTypeParentId().equals(
+                            documentType.getDocumentTypeId())) {
+                return null;
+            } else {
+                return getClosestParentDocumentTypeName(documentType
+                        .getParentDocType(), potentialParentDocumentTypeNames);
+            }
+        }
+    }
+
+    public static boolean storedValueNotSpecifiedOrInputValueMatches(Map<String,String> storedValues, Map<String,String> inputValues, String attributeName) {
+        return ((storedValues == null) || (inputValues == null)) || !storedValues.containsKey(attributeName) || storedValues.get(attributeName).equals(inputValues.get(attributeName));
+    }
+
+    public static boolean doesPropertyNameMatch(
+            String requestedDetailsPropertyName,
+            String permissionDetailsPropertyName) {
+        if (StringUtils.isBlank(permissionDetailsPropertyName)) {
+            return true;
+        }
+        if ( requestedDetailsPropertyName == null ) {
+            requestedDetailsPropertyName = ""; // prevent NPE
+        }
+        return StringUtils.equals(requestedDetailsPropertyName, permissionDetailsPropertyName)
+                || (requestedDetailsPropertyName.startsWith(permissionDetailsPropertyName+"."));
+    }
+
+//    public static AttributeSet getNamespaceAndComponentSimpleName( Class<? extends Object> clazz) {
+//        AttributeSet attributeSet = new AttributeSet();
+//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimAttributes.COMPONENT_NAME, getComponentSimpleName(clazz));
+//        return attributeSet;
+//    }
+//
+//    public static AttributeSet getNamespaceAndComponentFullName( Class<? extends Object> clazz) {
+//        AttributeSet attributeSet = new AttributeSet();
+//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimAttributes.COMPONENT_NAME, getComponentFullName(clazz));
+//        return attributeSet;
+//    }
+//
+//    public static AttributeSet getNamespaceAndActionClass( Class<? extends Object> clazz) {
+//        AttributeSet attributeSet = new AttributeSet();
+//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimAttributes.ACTION_CLASS, clazz.getName());
+//        return attributeSet;
+//    }
+//
+//    public static String getNamespaceCode(Class<? extends Object> clazz) {
+//        ModuleService moduleService = getKualiModuleService().getResponsibleModuleService(clazz);
+//        if (moduleService == null) {
+//            return KimConstants.KIM_TYPE_DEFAULT_NAMESPACE;
+//        }
+//        return moduleService.getModuleConfiguration().getNamespaceCode();
+//    }
+
+    public static String getComponentSimpleName(Class<? extends Object> clazz) {
+        return clazz.getSimpleName();
+    }
+
+    public static String getComponentFullName(Class<? extends Object> clazz) {
+        return clazz.getName();
+    }
+
+//    public static boolean isAttributeSetEntryEquals( AttributeSet map1, AttributeSet map2, String key ) {
+//        return StringUtils.equals( map1.get( key ), map2.get( key ) );
+//    }
+
+    /**
+     * Resolves the given kim type service name represented as a String to the appropriate QName.
+     * If the value given is empty or null, then it will resolve to the default KimTypeService name.
+     */
+    public static QName resolveKimTypeServiceName(String kimTypeServiceName) {
+        if (StringUtils.isBlank(kimTypeServiceName)) {
+            return resolveKimTypeServiceName(KimConstants.DEFAULT_KIM_TYPE_SERVICE);
+        }
+        return QName.valueOf(kimTypeServiceName);
+    }
+
+//    /**
+//     * @deprecated Please use KIMServiceLocator.getKimTypeService(KimType) instead
+//     */
+//    @Deprecated
+//    public static KimTypeService getKimTypeService(KimType kimType){
+//        return KIMServiceLocator.getKimTypeService(kimType);
+//    }
+//
+//    /**
+//     * @deprecated Please use KIMServiceLocator.getKimTypeService(QName) instead
+//     */
+//    @Deprecated
+//    public static KimTypeService getKimTypeService( String serviceName ) {
+//        return KIMServiceLocator.getKimTypeService(resolveKimTypeServiceName(serviceName));
+//    }
+
+    public static void copyProperties(Object targetToCopyTo, Object sourceToCopyFrom){
+        if(targetToCopyTo!=null && sourceToCopyFrom!=null)
+        try{
+            PropertyUtils.copyProperties(targetToCopyTo, sourceToCopyFrom);
+        } catch(Exception ex){
+            throw new RuntimeException("Failed to copy from source object: "+sourceToCopyFrom.getClass()+" to target object: "+targetToCopyTo,ex);
+        }
+    }
+
+    public static String getKimBasePath(){
+        String kimBaseUrl = SpringContext.getBean(ConfigurationService.class).getPropertyString(KimConstants.KimUIConstants.KIM_URL_KEY);
+        if (!kimBaseUrl.endsWith(KimConstants.KimUIConstants.URL_SEPARATOR)) {
+            kimBaseUrl = kimBaseUrl + KimConstants.KimUIConstants.URL_SEPARATOR;
+        }
+        return kimBaseUrl;
+    }
+
+    public static String getPathWithKimContext(String path, String kimActionName){
+        String kimContext = KimConstants.KimUIConstants.KIM_APPLICATION+KimConstants.KimUIConstants.URL_SEPARATOR;
+        String kimContextParameterized = KimConstants.KimUIConstants.KIM_APPLICATION+KimConstants.KimUIConstants.PARAMETERIZED_URL_SEPARATOR;
+        if(path.contains(kimActionName) && !path.contains(kimContext + kimActionName)
+                && !path.contains(kimContextParameterized + kimActionName))
+            path = path.replace(kimActionName, kimContext+kimActionName);
+        return path;
+    }
+
+    public static String stripEnd(String toStripFrom, String toStrip){
+        String stripped;
+        if(toStripFrom==null) return null;
+        if(toStrip==null) return toStripFrom;
+        if(toStrip.length() > toStripFrom.length()) return toStripFrom;
+        if(toStripFrom.endsWith(toStrip)){
+            StringBuffer buffer = new StringBuffer(toStripFrom);
+            buffer.delete(buffer.length()-toStrip.length(), buffer.length());
+            stripped = buffer.toString();
+        } else stripped = toStripFrom;
+        return stripped;
+    }
+
+//    protected static boolean canOverrideEntityPrivacyPreferences( String principalId ){
+//        return getIdentityManagementService().isAuthorized(
+//                GlobalVariables.getUserSession().getPrincipalId(),
+//                KimConstants.NAMESPACE_CODE,
+//                KimConstants.PermissionNames.OVERRIDE_ENTITY_PRIVACY_PREFERENCES,
+//                null,
+//                new AttributeSet(KimAttributes.PRINCIPAL_ID, principalId) );
+//    }
+//
+//    public static boolean isSuppressName(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressName = false;
+//        if (privacy != null) {
+//            suppressName = privacy.isSuppressName();
+//        }
+//        return suppressName
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressEmail(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressEmail = false;
+//        if (privacy != null) {
+//            suppressEmail = privacy.isSuppressEmail();
+//        }
+//        return suppressEmail
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressAddress(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressAddress = false;
+//        if (privacy != null) {
+//            suppressAddress = privacy.isSuppressAddress();
+//        }
+//        return suppressAddress
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressPhone(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressPhone = false;
+//        if (privacy != null) {
+//            suppressPhone = privacy.isSuppressPhone();
+//        }
+//        return suppressPhone
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressPersonal(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressPersonal = false;
+//        if (privacy != null) {
+//            suppressPersonal = privacy.isSuppressPersonal();
+//        }
+//        return suppressPersonal
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static String encryptExternalIdentifier(String externalIdentifier, String externalIdentifierType){
+//        Map<String, String> criteria = new HashMap<String, String>();
+//        criteria.put(KimConstants.PrimaryKeyConstants.KIM_TYPE_CODE, externalIdentifierType);
+//        ExternalIdentifierType externalIdentifierTypeObject = (ExternalIdentifierType) KNSServiceLocator.getBusinessObjectService().findByPrimaryKey(ExternalIdentifierTypeImpl.class, criteria);
+//        if( externalIdentifierTypeObject!= null && externalIdentifierTypeObject.isEncryptionRequired()){
+//            if(StringUtils.isNotEmpty(externalIdentifier)){
+//                try{
+//                    return KNSServiceLocator.getEncryptionService().encrypt(externalIdentifier);
+//                }catch (GeneralSecurityException e) {
+//                    LOG.info("Unable to encrypt value : " + e.getMessage() + " or it is already encrypted");
+//                }
+//            }
+//        }
+//        return externalIdentifier;
+//    }
+//
+//    public static String decryptExternalIdentifier(String externalIdentifier, String externalIdentifierType){
+//        Map<String, String> criteria = new HashMap<String, String>();
+//        criteria.put(KimConstants.PrimaryKeyConstants.KIM_TYPE_CODE, externalIdentifierType);
+//        ExternalIdentifierType externalIdentifierTypeObject = (ExternalIdentifierType) KNSServiceLocator.getBusinessObjectService().findByPrimaryKey(ExternalIdentifierTypeImpl.class, criteria);
+//        if( externalIdentifierTypeObject!= null && externalIdentifierTypeObject.isEncryptionRequired()){
+//            if(StringUtils.isNotEmpty(externalIdentifier)){
+//                try{
+//                    return KNSServiceLocator.getEncryptionService().decrypt(externalIdentifier);
+//                }catch (GeneralSecurityException e) {
+//                    LOG.info("Unable to decrypt value : " + e.getMessage() + " or it is already decrypted");
+//                }
+//            }
+//        }
+//        return externalIdentifier;
+//    }
+//
+//    public static IdentityManagementService getIdentityManagementService() {
+//        if ( identityManagementService == null ) {
+//            identityManagementService = KIMServiceLocator.getIdentityManagementService();
+//        }
+//        return identityManagementService;
+//    }
+//
+//
+//    public static GroupImpl copyInfoToGroup(Group info, GroupImpl group) {
+//        group.setActive(info.isActive());
+//        group.setGroupDescription(info.getGroupDescription());
+//        group.setGroupId(info.getGroupId());
+//        group.setGroupName(info.getGroupName());
+//        group.setKimTypeId(info.getKimTypeId());
+//        group.setNamespaceCode(info.getNamespaceCode());
+//
+//        return group;
+//    }
+//
+//    /**
+//     *
+//     * @param infoMap Containing the Info Attribute objects.
+//     * @param groupId for the group of attributes
+//     * @param kimTypeId for the group of attributes
+//     * @return a list of group attributes
+//     */
+//
+//    public static List<GroupAttributeDataImpl> copyInfoAttributesToGroupAttributes(Map<String, String> infoMap, String groupId, String kimTypeId) {
+//        List<GroupAttributeDataImpl> attrList = new ArrayList<GroupAttributeDataImpl>(infoMap.size());
+//        List<KimTypeAttributeInfo> attributeInfoList = KIMServiceLocator.getTypeInfoService().getKimType(kimTypeId).getAttributeDefinitions();
+//
+//        for (String key : infoMap.keySet()) {
+//            KimTypeAttributeInfo typeAttributeInfo = getAttributeInfo(attributeInfoList, key);
+//
+//            if (typeAttributeInfo != null) {
+//                GroupAttributeDataImpl groupAttribute = new GroupAttributeDataImpl();
+//                groupAttribute.setKimAttributeId(typeAttributeInfo.getKimAttributeId());
+//                groupAttribute.setAttributeValue(infoMap.get(typeAttributeInfo.getAttributeName()));
+//                groupAttribute.setGroupId(groupId);
+//                groupAttribute.setKimTypeId(kimTypeId);
+//                attrList.add(groupAttribute);
+//            } else {
+//                throw new IllegalArgumentException("KimAttribute not found: " + key);
+//            }
+//        }
+//        return attrList;
+//    }
+//
+//    private static KimTypeAttributeInfo getAttributeInfo(List<KimTypeAttributeInfo> attributeInfoList, String attributeName) {
+//        KimTypeAttributeInfo kRet = null;
+//        for (KimTypeAttributeInfo attributeInfo : attributeInfoList) {
+//            if (attributeInfo.getAttributeName().equals(attributeName)) {
+//                kRet = attributeInfo;
+//                break;
+//            }
+//        }
+//        return kRet;
+//    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/util/KimCommonUtils.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/service/impl/KFSModuleServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/krad/service/impl/KFSModuleServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/krad/service/impl/KFSModuleServiceImpl.java	(revision 32084)
@@ -0,0 +1,93 @@
+package org.kuali.rice.krad.service.impl;
+
+import org.kuali.rice.core.api.util.ClassLoaderUtils;
+import org.kuali.rice.krad.service.KualiModuleService;
+import org.kuali.rice.krad.service.ModuleService;
+
+import java.util.List;
+
+/**
+ * Module service that adds support for the kfs Step class.
+ */
+public class KFSModuleServiceImpl implements KualiModuleService {
+
+    //inject with the rice service
+    private KualiModuleService kualiModuleService;
+
+    private static final Class<?> STEP_CLASS;
+    static {
+        Class<?> clazz;
+        try {
+            ClassLoader cl = ClassLoaderUtils.getDefaultClassLoader();
+            //once this is pushed into kfs should not use class token directly
+            clazz =  Class.forName("org.kuali.kfs.sys.batch.Step", true, cl);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+        STEP_CLASS = clazz;
+    }
+
+
+    @Override
+    public List<ModuleService> getInstalledModuleServices() {
+        return kualiModuleService.getInstalledModuleServices();
+    }
+
+    @Override
+    public ModuleService getModuleService(String moduleId) {
+        return kualiModuleService.getModuleService(moduleId);
+    }
+
+    @Override
+    public ModuleService getModuleServiceByNamespaceCode(String namespaceCode) {
+        return kualiModuleService.getModuleServiceByNamespaceCode(namespaceCode);
+    }
+
+    @Override
+    public boolean isModuleServiceInstalled(String namespaceCode) {
+        return kualiModuleService.isModuleServiceInstalled(namespaceCode);
+    }
+
+    @Override
+    public ModuleService getResponsibleModuleService(Class boClass) {
+        return kualiModuleService.getResponsibleModuleService(boClass);
+    }
+
+    @Override
+    public ModuleService getResponsibleModuleServiceForJob(String jobName) {
+        return kualiModuleService.getResponsibleModuleServiceForJob(jobName);
+    }
+
+    @Override
+    public void setInstalledModuleServices(List<ModuleService> moduleServices) {
+        kualiModuleService.setInstalledModuleServices(moduleServices);
+    }
+
+    @Override
+    public List<String> getDataDictionaryPackages() {
+        return kualiModuleService.getDataDictionaryPackages();
+    }
+
+    @Override
+    public String getNamespaceName(String namespaceCode) {
+        return kualiModuleService.getNamespaceName(namespaceCode);
+    }
+
+    @Override
+    public String getNamespaceCode(Class<?> documentOrStepClass) {
+        if (STEP_CLASS != null && STEP_CLASS.isAssignableFrom(documentOrStepClass)) {
+            return documentOrStepClass.getSimpleName();
+        }
+
+        return kualiModuleService.getNamespaceCode(documentOrStepClass);
+    }
+
+    @Override
+    public String getComponentCode(Class<?> documentOrStepClass) {
+        return kualiModuleService.getComponentCode(documentOrStepClass);
+    }
+
+    public void setKualiModuleService(KualiModuleService kualiModuleService) {
+        this.kualiModuleService = kualiModuleService;
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/service/impl/KFSModuleServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java
===================================================================
--- work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java	(revision 32084)
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.PBKey;
+import org.apache.ojb.broker.TransactionAbortedException;
+import org.apache.ojb.broker.TransactionInProgressException;
+import org.apache.ojb.broker.TransactionNotInProgressException;
+import org.apache.ojb.broker.core.PersistenceBrokerFactoryIF;
+import org.apache.ojb.broker.core.PersistenceBrokerImpl;
+
+public class KualiPersistenceBrokerImpl extends PersistenceBrokerImpl {
+    private static final Logger LOG = Logger.getLogger(KualiPersistenceBrokerImpl.class);
+
+
+    private boolean fresh = true;
+
+    public KualiPersistenceBrokerImpl(PBKey key, PersistenceBrokerFactoryIF pbf) {
+        super(key, pbf);
+    }
+
+    public boolean isFresh() {
+        return fresh;
+    }
+
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#beginTransaction()
+     */
+    public synchronized void beginTransaction() throws TransactionInProgressException, TransactionAbortedException {
+        LOG.debug("beginning transaction for persistenceBroker " + getClass().getName() + "@" + hashCode());
+
+        super.beginTransaction();
+    }
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#abortTransaction()
+     */
+    public synchronized void abortTransaction() throws TransactionNotInProgressException {
+        LOG.debug("aborting transaction for persistenceBroker " + getClass().getName() + "@" + hashCode());
+
+        super.abortTransaction();
+    }
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#commitTransaction()
+     */
+    public synchronized void commitTransaction() throws TransactionNotInProgressException, TransactionAbortedException {
+        LOG.debug("committing transaction for persistenceBroker " + getClass().getName() + "@" + hashCode());
+
+        super.commitTransaction();
+    }
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#close()
+     */
+    public boolean close() {
+        LOG.debug("closing persistenceBroker " + getClass().getName() + "@" + hashCode());
+        fresh = false;
+
+        return super.close();
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java
===================================================================
--- work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java	(revision 32084)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.metadata.ConnectionRepository;
+import org.apache.ojb.broker.metadata.DescriptorRepository;
+import org.apache.ojb.broker.metadata.MetadataManager;
+import org.kuali.rice.core.api.util.ClassLoaderUtils;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.core.io.DefaultResourceLoader;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+public class OjbMetadataLoader implements InitializingBean {
+    
+    private static final Logger LOG = Logger.getLogger(OjbMetadataLoader.class);
+
+    private List<String> repositoryDescriptors = new ArrayList<String>();
+    private List<String> connectionDescriptors = new ArrayList<String>(); 
+    
+    public List<String> getConnectionDescriptors() {
+        return connectionDescriptors;
+    }
+
+    public void setConnectionDescriptors(List<String> connectionDescriptors) {
+        this.connectionDescriptors = connectionDescriptors;
+    }
+
+    public List<String> getRepositoryDescriptors() {
+        return repositoryDescriptors;
+    }
+
+    public void setRepositoryDescriptors(List<String> repositoryDescriptors) {
+        this.repositoryDescriptors = repositoryDescriptors;
+    }
+
+    public void afterPropertiesSet() throws Exception {
+        
+        MetadataManager mm = MetadataManager.getInstance();
+        DefaultResourceLoader resourceLoader = new DefaultResourceLoader(ClassLoaderUtils.getDefaultClassLoader());
+        
+        for (String repositoryDescriptor : repositoryDescriptors) {
+            InputStream is = resourceLoader.getResource(repositoryDescriptor).getInputStream();
+            DescriptorRepository dr = mm.readDescriptorRepository(is);
+            mm.mergeDescriptorRepository(dr);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("--------------------------------------------------------------------------");
+                LOG.debug("Merging repository descriptor: " + repositoryDescriptor);
+                LOG.debug("--------------------------------------------------------------------------");
+            }
+            try {
+                is.close();
+            } catch (Exception e) {
+                LOG.warn("Failed to close stream to file " + repositoryDescriptor, e);
+            }
+        }
+        
+        for (String connectionDesciptor : connectionDescriptors) {
+            InputStream is = resourceLoader.getResource(connectionDesciptor).getInputStream();
+            ConnectionRepository cr = mm.readConnectionRepository(is);
+            mm.mergeConnectionRepository(cr);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("--------------------------------------------------------------------------");
+                LOG.debug("Merging connection descriptor: " + connectionDesciptor);
+                LOG.debug("--------------------------------------------------------------------------");
+            }
+            try {
+                is.close();
+            } catch (Exception e) {
+                LOG.warn("Failed to close stream to file " + connectionDesciptor, e);
+            }
+        }
+        
+    }
+
+}

Property changes on: work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java
===================================================================
--- work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java	(revision 32084)
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
+
+/**
+ * Builds a <code>{@link String}</code> instance using a pattern similar to the varargs printf() variety.
+ * 
+ * 
+ */
+public class PatternedStringBuilder {
+    private String _pattern;
+
+    /**
+     * Constructor that takes a pattern
+     * 
+     * @param pattern
+     */
+    public PatternedStringBuilder(String pattern) {
+        setPattern(pattern);
+    }
+
+    /**
+     * Write accessor method for pattern
+     * 
+     * @param pattern
+     */
+    public void setPattern(String pattern) {
+        _pattern = pattern;
+    }
+
+    /**
+     * Read accessor method for pattern
+     * 
+     * @return String
+     */
+    public String getPattern() {
+        return _pattern;
+    }
+
+    /**
+     * Takes an ellipses of <code>{@link String}</code> parameters and builds a <code>{@link String}</code> instance from them
+     * and the pattern given earlier.
+     * 
+     * @param args
+     * @return String
+     */
+    public String sprintf(Object... args) {
+        ByteArrayOutputStream retval = new ByteArrayOutputStream();
+
+        new PrintStream(retval).printf(getPattern(), args);
+
+        return retval.toString();
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java
===================================================================
--- work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java	(revision 32084)
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2007 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import java.util.Iterator;
+
+import org.apache.commons.collections.IteratorUtils;
+
+/**
+ * This class provides utility methods to support the operation of transactional services
+ */
+public final class TransactionalServiceUtils {
+	
+	private TransactionalServiceUtils() {
+		throw new UnsupportedOperationException("do not call");
+	}
+    /**
+     * Copys iterators so that they may be used outside of this class.  Often, the DAO may
+     * return iterators that may not be used outside of this class because the transaction/
+     * connection may be automatically closed by Spring.
+     * 
+     * This method copies all of the elements in the OJB backed iterators into list-based iterators
+     * by placing the returned BOs into a list
+     * 
+     * @param iter an OJB backed iterator to copy
+     * @return an Iterator that may be used outside of this class
+     */
+    public static <E> Iterator<E> copyToExternallyUsuableIterator(Iterator<E> iter) {
+        return IteratorUtils.toList(iter).iterator();
+    }
+    
+    /**
+     * Returns the first element and exhausts an iterator
+     * 
+     * @param <E> the type of elements in the iterator
+     * @param iterator the iterator to exhaust
+     * @return the first element of the iterator; null if the iterator's empty
+     */
+    public static <E> E retrieveFirstAndExhaustIterator(Iterator<E> iterator) {
+        E returnVal = null;
+        if (iterator.hasNext()) {
+            returnVal = iterator.next();
+        }
+        exhaustIterator(iterator);
+        return returnVal;
+    }
+    
+    /**
+     * Exhausts (i.e. complete iterates through) an iterator
+     * 
+     * @param iterator
+     */
+    public static void exhaustIterator(Iterator<?> iterator) {
+        while (iterator.hasNext()) {
+            iterator.next();
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java
===================================================================
--- work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java	(revision 32084)
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.PBFactoryException;
+import org.apache.ojb.broker.PBKey;
+import org.apache.ojb.broker.PersistenceBrokerInternal;
+import org.apache.ojb.broker.core.PersistenceBrokerFactoryDefaultImpl;
+import org.apache.ojb.broker.core.PersistenceBrokerHandle;
+
+public class KualiPersistenceBrokerFactoryImpl extends PersistenceBrokerFactoryDefaultImpl {
+    private static final Logger LOG = Logger.getLogger(KualiPersistenceBrokerFactoryImpl.class);
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerFactoryDefaultImpl#createPersistenceBroker(org.apache.ojb.broker.PBKey)
+     */
+    public PersistenceBrokerInternal createPersistenceBroker(PBKey pbKey) throws PBFactoryException {
+        PersistenceBrokerInternal pb = super.createPersistenceBroker(pbKey);
+
+        PersistenceBrokerHandle pbh = (PersistenceBrokerHandle) pb;
+        KualiPersistenceBrokerImpl realBroker = (KualiPersistenceBrokerImpl) pbh.getInnermostDelegate();
+
+        LOG.debug((realBroker.isFresh() ? "created " : "reusing ") + "persistence broker " + pb.getClass().getName() + "@" + pb.hashCode());
+
+        return pb;
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java
===================================================================
--- work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java	(revision 32084)
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import java.util.Properties;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.Identity;
+import org.apache.ojb.broker.PersistenceBroker;
+import org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl;
+
+public class KualiObjectCachePerBrokerImpl extends ObjectCachePerBrokerImpl {
+    private static final Logger LOG = Logger.getLogger(KualiObjectCachePerBrokerImpl.class);
+
+
+    private final String brokerId;
+
+    public KualiObjectCachePerBrokerImpl(PersistenceBroker broker, Properties prop) {
+        super(broker, prop);
+        brokerId = broker.getClass().getName() + "@" + broker.hashCode();
+
+        LOG.debug("created objectCache for broker " + brokerId);
+    }
+
+    /**
+     * Clear ObjectCache. I.e. remove all entries for classes and objects.
+     */
+    public void clear() {
+        super.clear();
+
+        LOG.debug("cleared objectCache for broker " + brokerId);
+    }
+
+    /**
+     * @see org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl#cache(org.apache.ojb.broker.Identity, java.lang.Object)
+     */
+    public void cache(Identity oid, Object obj) {
+        super.cache(oid, obj);
+
+        boolean cached = (super.lookup(oid) != null);
+        LOG.debug((cached ? "cached oid " : "unable to cache oid ") + oid + " in objectCache for broker " + brokerId);
+    }
+
+    /**
+     * @see org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl#cacheIfNew(org.apache.ojb.broker.Identity, java.lang.Object)
+     */
+    public boolean cacheIfNew(Identity oid, Object obj) {
+        boolean cachedIfNew = super.cacheIfNew(oid, obj);
+
+        boolean cached = (super.lookup(oid) != null);
+        LOG.debug((cached ? "cached new oid " : "unable to cache new oid ") + oid + " in objectCache for broker " + brokerId);
+
+        return cachedIfNew;
+    }
+
+    /**
+     * @see org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl#lookup(org.apache.ojb.broker.Identity)
+     */
+    public Object lookup(Identity oid) {
+        Object o = super.lookup(oid);
+
+        LOG.debug((o != null ? "found oid " : "cannot find oid ") + oid + " in objectCache for broker " + brokerId);
+
+        return o;
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java
===================================================================
--- work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java	(revision 32083)
+++ work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java	(revision 32084)
@@ -24,7 +24,7 @@
 import org.apache.ojb.broker.util.sequence.SequenceManager;
 import org.apache.ojb.broker.util.sequence.SequenceManagerException;
 import org.kuali.kfs.sys.context.PropertyLoadingFactoryBean;
-import org.kuali.rice.core.config.ConfigurationException;
+import org.kuali.rice.core.api.config.ConfigurationException;
 
 
 /**
Index: work/src/org/kuali/rice/kns/service/ConfigurableDateService.java
===================================================================
--- work/src/org/kuali/rice/kns/service/ConfigurableDateService.java	(revision 0)
+++ work/src/org/kuali/rice/kns/service/ConfigurableDateService.java	(revision 32084)
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.service;
+
+import java.util.Date;
+
+import org.kuali.rice.core.api.datetime.DateTimeService;
+
+/**
+ * This is a timeDateService that allows tests to specify the date/time they need to run. Set the currentDate property in this class
+ * before running your code under test and dateTimeService.getCurrentDate() will return the one you specify instead of the current
+ * date.
+ */
+public interface ConfigurableDateService extends DateTimeService {
+    public void setCurrentDate(Date currentDate);
+}

Property changes on: work/src/org/kuali/rice/kns/service/ConfigurableDateService.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java	(revision 32084)
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.service.impl;
+
+import java.util.Date;
+
+import org.kuali.rice.core.impl.datetime.DateTimeServiceImpl;
+import org.kuali.rice.kns.service.ConfigurableDateService;
+
+public class ConfigurableDateTimeServiceImpl extends DateTimeServiceImpl implements ConfigurableDateService {
+    protected Date currentDate;
+
+    /**
+     * Sets the currentDate attribute value.
+     * 
+     * @param currentDate The currentDate to set.
+     */
+    public void setCurrentDate(Date currentDate) {
+        this.currentDate = currentDate;
+    }
+
+    @Override
+    public Date getCurrentDate() {
+        return currentDate;
+    }
+}

Property changes on: work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java
===================================================================
--- work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java	(revision 32083)
+++ work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java	(revision 32084)
@@ -28,7 +28,8 @@
 import javax.servlet.http.HttpServletRequestWrapper;
 
 import org.kuali.rice.kew.util.KEWConstants;
-import org.kuali.rice.kew.web.session.UserSession;
+import org.kuali.rice.krad.UserSession;
+import org.kuali.rice.krad.util.KRADConstants;
 
 /**
  * A login filter which forwards to a login page that allows for the desired
@@ -69,9 +70,9 @@
 	public void destroy() {
 	}
 	public static UserSession getUserSession(HttpServletRequest request) {
-		return (UserSession) request.getSession().getAttribute(KEWConstants.USER_SESSION_KEY);
+		return (UserSession) request.getSession().getAttribute(KRADConstants.USER_SESSION_KEY);
 	}
 	public static boolean isUserSessionEstablished(HttpServletRequest request) {
-		return (request.getSession(false) != null && request.getSession(false).getAttribute(KEWConstants.USER_SESSION_KEY) != null);
+		return (request.getSession(false) != null && request.getSession(false).getAttribute(KRADConstants.USER_SESSION_KEY) != null);
 	}
 }

Property changes on: work/web-root/WEB-INF/jsp/recurseTreeNode.jsp
___________________________________________________________________
Added: svn:eol-style
   + native


Property changes on: work/web-root/WEB-INF/tags
___________________________________________________________________
Modified: svn:ignore
   - kr
kim
kew
rice-portal

   + kr
kim
kew
rice-portal
krad



Property changes on: work/web-root/WEB-INF
___________________________________________________________________
Modified: svn:ignore
   - classes
web.xml
lib

   + classes
web.xml
lib
tld



Property changes on: work/web-root
___________________________________________________________________
Modified: svn:ignore
   - META-INF
kr
en
ksb
kcb
kew
kim
ken
rice-portal

   + META-INF
kr
en
ksb
kcb
kew
kim
ken
rice-portal
core
krad
krms


Index: build/properties/rice.properties
===================================================================
--- build/properties/rice.properties	(revision 32083)
+++ build/properties/rice.properties	(revision 32084)
@@ -24,7 +24,7 @@
 
 # Base Rice version properties
 rice.name=rice
-kfs.rice.version=1.0.3.3
+kfs.rice.version=2.0.0-b1
 rice.output.licenses.suffix=-licenses.zip
 rice.server.war.file.name.prefix=${rice.name}-web-
 rice.server.war.file.name=${rice.server.war.file.name.prefix}${kfs.rice.version}.war
Index: build/properties/build-foundation.properties
===================================================================
--- build/properties/build-foundation.properties	(revision 32083)
+++ build/properties/build-foundation.properties	(revision 32084)
@@ -22,7 +22,7 @@
 rice.sampleapp.module.name=sampleapp
 rice.output.src.suffix=-sources.jar
 rice.output.doc.suffix=-javadoc.jar
-rice.version=1.0.3.3-m2-SNAPSHOT
+rice.version=2.0.0-b1
 rice.war.file.name=${rice.name}-web-${rice.version}.war
 
 # paths used for pulling in rice changes using the KFS Ant script
@@ -30,4 +30,4 @@
 maven.home.directory=${base.directory}/tools/maven
 
 dependencies.project.directory=${projects.directory}/kfs-dependencies
-rice.project.directory=${projects.directory}/rice
+rice.project.directory=${projects.directory}/rice-20

Property changes on: .
___________________________________________________________________
Modified: svn:ignore
   - *.war
dist
.clover
${test.temp.directory}
${test.xml.results.directory}
*.zip
spy.log
batch-results
temp
log4j.properties
security.properties
workflow.xml
atomikos-tmp
kuali_intellij.iml
kuali_intellij.ipr
kuali_intellij.iws
.springBeans
rice.keystore

   + *.war
dist
.clover
${test.temp.directory}
${test.xml.results.directory}
*.zip
*.log
batch-results
temp
log4j.properties
security.properties
workflow.xml
atomikos-tmp
*.iml
*.ipr
*.iws
.springBeans
rice.keystore


