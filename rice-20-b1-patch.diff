Index: test/unit/src/org/kuali/kfs/sys/context/SpringAOPUsageTest.java
===================================================================
--- test/unit/src/org/kuali/kfs/sys/context/SpringAOPUsageTest.java	(revision 32235)
+++ test/unit/src/org/kuali/kfs/sys/context/SpringAOPUsageTest.java	(revision 32237)
@@ -1,127 +0,0 @@
-/*
- * Copyright 2007 The Kuali Foundation
- * 
- * Licensed under the Educational Community License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl2.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.kfs.sys.context;
-
-import java.lang.reflect.Method;
-
-import org.kuali.kfs.coa.service.BalanceTypeService;
-import org.kuali.kfs.coa.service.PriorYearAccountService;
-import org.kuali.kfs.coa.service.impl.BalanceTypeServiceImpl;
-import org.kuali.kfs.sys.ConfigureContext;
-import org.kuali.kfs.sys.suite.AnnotationTestSuite;
-import org.kuali.kfs.sys.suite.PreCommitSuite;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.service.DocumentService;
-import org.kuali.rice.kns.service.impl.AbstractStaticConfigurationServiceImpl;
-import org.kuali.rice.kns.service.impl.DocumentServiceImpl;
-import org.kuali.rice.kns.service.impl.PersistenceStructureServiceImpl;
-import org.kuali.rice.kns.util.cache.MethodCacheInterceptor;
-import org.kuali.rice.kns.util.cache.MethodCacheNoCopyInterceptor;
-import org.kuali.rice.kns.util.spring.CacheNoCopy;
-import org.kuali.rice.kns.util.spring.Cached;
-import org.kuali.rice.kns.util.spring.ClassOrMethodAnnotationFilter;
-import org.springframework.aop.Advisor;
-import org.springframework.aop.support.AopUtils;
-import org.springframework.transaction.TransactionDefinition;
-import org.springframework.transaction.annotation.Transactional;
-import org.springframework.transaction.interceptor.TransactionAttribute;
-import org.springframework.transaction.interceptor.TransactionAttributeSource;
-
-@AnnotationTestSuite(PreCommitSuite.class)
-@ConfigureContext
-public class SpringAOPUsageTest extends KualiTestBase {
-    public void testCaching() throws Exception {
-        ClassOrMethodAnnotationFilter classOrMethodAnnotationFilter = new ClassOrMethodAnnotationFilter(Cached.class);
-        ClassOrMethodAnnotationFilter classOrMethodAnnotationNoCopyFilter = new ClassOrMethodAnnotationFilter(CacheNoCopy.class);
-        assertTrue(AbstractStaticConfigurationServiceImpl.class.isAnnotationPresent(Cached.class));
-        assertFalse(BalanceTypeServiceImpl.class.isAnnotationPresent(Cached.class));
-        assertTrue(classOrMethodAnnotationFilter.matches(AbstractStaticConfigurationServiceImpl.class));
-        assertTrue(classOrMethodAnnotationNoCopyFilter.matches(BalanceTypeServiceImpl.class));
-        // should be cached cause of method annotation
-        SpringContext.getBean(BalanceTypeService.class).getCurrentYearCostShareEncumbranceBalanceType();
-        assertTrue("BalanceTypService.getCurrentYearCostShareEncumbranceBalanceType() is not cached.", methodIsCached(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {}));
-        // should not be cached cause no method annotation and no class annotation
-        SpringContext.getBean(BalanceTypeService.class).getAllBalanceTypes();
-        assertFalse(methodIsCached(BalanceTypeService.class.getMethod("getAllBalanceTypes", new Class[] {}), new Object[] {}));
-        // should not be cached, cause no annotations on the class or its methods
-        SpringContext.getBean(PriorYearAccountService.class).getByPrimaryKey("BL", "1031490");
-        assertFalse(methodIsCached(PriorYearAccountService.class.getMethod("getByPrimaryKey", new Class[] { String.class, String.class }), new Object[] { "BL", "1031490" }));
-    }
-    
-    /**
-     * Assures the removeCacheKey method of methodCacheInterceptor is actually removing the method cache.
-     * Depends on method implementations for BalanceTypService.getAllBalanceTyps() and PersistenceStructureService.getPrimaryKeys(Class clazz) 
-     * having the @Cached annotation.
-     */
-    public void testClearMethodCache() throws Exception {
-        SpringContext.getBean(BalanceTypeService.class).getCurrentYearCostShareEncumbranceBalanceType();
-        assertTrue("BalanceTypService.getCurrentYearCostShareEncumbranceBalanceType() is not cached.", methodIsCached(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {}));
-        removeCachedMethod(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {});
-        assertFalse(methodIsCached(BalanceTypeService.class.getMethod("getCurrentYearCostShareEncumbranceBalanceType", new Class[] {}), new Object[] {}));
-    }
-
-    @Transactional
-    public void testTransactions() throws Exception {
-//        ClassOrMethodAnnotationFilter classOrMethodAnnotationFilter = new ClassOrMethodAnnotationFilter(Transactional.class);
-//        Exception exception = null;
-//        try {
-//            classOrMethodAnnotationFilter.matches(getClass());
-//        } catch (Exception e) {
-//            exception = e;
-//        }
-//        assertNotNull(exception);
-//        assertEquals("The @Transactional annotation should be specified at the class level and overriden at the method level, if need be.", exception.getMessage());
-        Advisor transactionAdvisor = SpringContext.getBean(Advisor.class);
-        // should be transaction applicable because the class has the annotation
-        assertTrue(AopUtils.canApply(transactionAdvisor, DocumentServiceImpl.class));
-        // should not be transaction applicable since there's no annotation in the class hierarchy
-        assertFalse(AopUtils.canApply(transactionAdvisor, PersistenceStructureServiceImpl.class));
-        TransactionAttributeSource transactionAttributeSource = SpringContext.getBean(TransactionAttributeSource.class);
-        // should be transactionalized because the class that defines it has the transactional annotation
-        TransactionAttribute documentServiceSaveDocumentAttribute = transactionAttributeSource.getTransactionAttribute(DocumentService.class.getMethod("saveDocument", new Class[] { Document.class }), DocumentServiceImpl.class);
-        assertNotNull(documentServiceSaveDocumentAttribute);
-        TransactionAttribute documentServiceSaveDocumentWithEventAttribute = transactionAttributeSource.getTransactionAttribute(DocumentService.class.getMethod("saveDocument", new Class[] { Document.class, Class.class }), DocumentServiceImpl.class);
-        assertNotNull(documentServiceSaveDocumentWithEventAttribute);
-        assertTrue(TransactionDefinition.PROPAGATION_REQUIRED == documentServiceSaveDocumentWithEventAttribute.getPropagationBehavior());
-    }
-
-    private void removeCachedMethod(Method method, Object[] arguments) {
-        MethodCacheInterceptor methodCacheInterceptor = SpringContext.getBean(MethodCacheInterceptor.class);
-        if (methodCacheInterceptor.containsCacheKey(methodCacheInterceptor.buildCacheKey(method.toString(), arguments))) {
-            String cacheKey = methodCacheInterceptor.buildCacheKey(method.toString(), arguments);
-            System.out.println(cacheKey);
-            methodCacheInterceptor.removeCacheKey(cacheKey);
-            assertFalse(methodCacheInterceptor.containsCacheKey(cacheKey));
-        }
-
-        MethodCacheNoCopyInterceptor methodCacheNoCopyInterceptor = SpringContext.getBean(MethodCacheNoCopyInterceptor.class);
-        if (methodCacheNoCopyInterceptor.containsCacheKey(methodCacheInterceptor.buildCacheKey(method.toString(), arguments))) {
-            String cacheKey = methodCacheNoCopyInterceptor.buildCacheKey(method.toString(), arguments);
-            System.out.println(cacheKey);
-            methodCacheNoCopyInterceptor.removeCacheKey(cacheKey);
-            assertFalse(methodCacheNoCopyInterceptor.containsCacheKey(cacheKey));
-        }
-    }
-    
-    private boolean methodIsCached(Method method, Object[] arguments) {
-        MethodCacheInterceptor methodCacheInterceptor = SpringContext.getBean(MethodCacheInterceptor.class);
-        MethodCacheNoCopyInterceptor methodCacheNoCopyInterceptor = SpringContext.getBean(MethodCacheNoCopyInterceptor.class);
-
-        String cacheKey = methodCacheInterceptor.buildCacheKey(method.toString(), arguments);
-        
-        return methodCacheInterceptor.containsCacheKey( cacheKey ) || methodCacheNoCopyInterceptor.containsCacheKey(cacheKey);
-    }
-}
Index: work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java	(revision 32237)
@@ -0,0 +1,415 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.service.impl;
+
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.apache.log4j.Logger;
+import org.kuali.rice.kim.api.common.delegate.DelegateMember;
+import org.kuali.rice.kim.api.common.delegate.DelegateType;
+import org.kuali.rice.kim.api.role.Role;
+import org.kuali.rice.kim.api.role.RoleManagementService;
+import org.kuali.rice.kim.api.role.RoleMember;
+import org.kuali.rice.kim.api.role.RoleMembership;
+import org.kuali.rice.kim.api.role.RoleResponsibility;
+import org.kuali.rice.kim.api.role.RoleResponsibilityAction;
+import org.kuali.rice.kim.api.role.RoleService;
+import org.kuali.rice.kim.api.role.RoleUpdateService;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+import java.sql.Date;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class RoleManagementServiceImpl implements RoleManagementService {
+    private static final Logger LOG = Logger.getLogger(RoleManagementServiceImpl.class);
+
+    private RoleService roleService;
+    private RoleUpdateService roleUpdateService;
+
+    @Override
+    public void flushRoleCaches() {
+        flushInternalRoleCache();
+        flushInternalRoleMemberCache();
+        flushInternalDelegationCache();
+        flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void flushRoleMemberCaches() {
+        flushInternalRoleMemberCache();
+    }
+
+    @Override
+    public void flushDelegationCaches() {
+        flushInternalDelegationCache();
+        flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void flushDelegationMemberCaches() {
+        flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void removeCacheEntries(String roleId, String principalId) {
+
+    }
+
+    @Override
+    public Collection<String> getRoleMemberPrincipalIds(String namespaceCode, String roleName, Map<String, String> qualification) {
+        return getRoleService().getRoleMemberPrincipalIds(namespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public Role getRole(String roleId) {
+        return getRoleService().getRole(roleId);
+    }
+
+    @Override
+    public Role getRoleByName(String namespaceCode, String roleName) {
+        return getRoleService().getRoleByName(namespaceCode, roleName);
+    }
+
+    @Override
+    public String getRoleIdByName(String namespaceCode, String roleName) {
+        Role role = getRoleByName(namespaceCode, roleName);
+        if (role == null) {
+            return null;
+        }
+        return role.getId();
+    }
+
+    @Override
+    public List<Role> getRoles(List<String> roleIds) {
+        return getRoleService().getRoles(roleIds);
+    }
+
+    @Override
+    public List<RoleMembership> getRoleMembers(List<String> roleIds, Map<String, String> qualification) {
+        return getRoleService().getRoleMembers(roleIds, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getRoleQualifiersForPrincipal(String principalId, List<String> roleIds, Map<String, String> qualification) {
+        return getRoleService().getRoleQualifiersForPrincipal(principalId, roleIds, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getRoleQualifiersForPrincipal(String principalId, String namespaceCode, String roleName, Map<String, String> qualification) {
+        return getRoleService().getRoleQualifiersForPrincipal(principalId, namespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public boolean isRoleActive(String roleId) {
+        Role role = getRole(roleId);
+        return role != null && role.isActive();
+    }
+
+    @Override
+    public boolean principalHasRole(String principalId, List<String> roleIds, Map<String, String> qualification) {
+        if (LOG.isDebugEnabled()) {
+            logPrincipalHasRoleCheck(principalId, roleIds, qualification);
+        }
+        boolean hasRole =  getRoleService().principalHasRole(principalId, roleIds, qualification);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Result: " + hasRole);
+            }
+        return hasRole;
+    }
+
+    @Override
+    public List<String> getPrincipalIdSubListWithRole(
+            List<String> principalIds, String roleNamespaceCode,
+            String roleName, Map<String, String> qualification) {
+        return getRoleService().getPrincipalIdSubListWithRole(principalIds,
+                roleNamespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getNestedRoleQualifiersForPrincipal(String principalId, List<String> roleIds, Map<String, String> qualification) {
+        return getRoleService().getNestedRoleQualifiersForPrincipal(principalId, roleIds, qualification);
+    }
+
+    @Override
+    public List<Map<String, String>> getNestedRoleQualifiersForPrincipal(String principalId, String namespaceCode, String roleName, Map<String, String> qualification) {
+        return getRoleService().getNestedRoleQualifiersForPrincipal(principalId, namespaceCode, roleName, qualification);
+    }
+
+    @Override
+    public void assignGroupToRole(String groupId, String namespaceCode, String roleName,
+                                  Map<String, String> qualifications) {
+        getRoleUpdateService().assignGroupToRole(groupId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public void assignPrincipalToRole(String principalId, String namespaceCode, String roleName,
+                                      Map<String, String> qualifications) {
+        Role role = getRoleByName(namespaceCode, roleName);
+        getRoleUpdateService().assignPrincipalToRole(principalId, namespaceCode, roleName, qualifications);
+        removeCacheEntries(role.getId(), principalId);
+    }
+
+    @Override
+    public void removeGroupFromRole(String groupId, String namespaceCode, String roleName,
+                                    Map<String, String> qualifications) {
+        getRoleUpdateService().removeGroupFromRole(groupId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public void removePrincipalFromRole(String principalId, String namespaceCode, String roleName,
+                                        Map<String, String> qualifications) {
+        Role role = getRoleByName(namespaceCode, roleName);
+        getRoleUpdateService().removePrincipalFromRole(principalId, namespaceCode, roleName, qualifications);
+        removeCacheEntries(role.getId(), principalId);
+    }
+
+    @Override
+    public List<Role> getRolesSearchResults(
+            Map<String, String> fieldValues) {
+        return getRoleService().getRolesSearchResults(fieldValues);
+    }
+
+    protected void logPrincipalHasRoleCheck(String principalId, List<String> roleIds, Map<String, String> roleQualifiers) {
+        StringBuilder sb = new StringBuilder();
+        sb.append('\n');
+        sb.append("Has Role     : ").append(roleIds).append('\n');
+        if (roleIds != null) {
+            for (String roleId : roleIds) {
+                Role role = getRole(roleId);
+                if (role != null) {
+                    sb.append("        Name : ").append(role.getNamespaceCode()).append('/').append(role.getName());
+                    sb.append(" (").append(roleId).append(')');
+                    sb.append('\n');
+                }
+            }
+        }
+        sb.append("   Principal : ").append(principalId);
+        sb.append('\n');
+        sb.append("     Details :\n");
+        if (roleQualifiers != null) {
+            sb.append(new HashMap<String, String>(roleQualifiers));
+        } else {
+            sb.append("               [null]\n");
+        }
+        if (LOG.isTraceEnabled()) {
+            LOG.trace(sb.append(ExceptionUtils.getStackTrace(new Throwable())));
+        } else {
+            LOG.debug(sb.toString());
+        }
+    }
+
+    @Override
+    public void principalInactivated(String principalId) {
+        getRoleService().principalInactivated(principalId);
+        removeCacheEntries(null, principalId);
+    }
+
+    @Override
+    public void roleInactivated(String roleId) {
+        getRoleService().roleInactivated(roleId);
+        removeCacheEntries(roleId, null);
+    }
+
+    @Override
+    public void groupInactivated(String groupId) {
+        getRoleService().groupInactivated(groupId);
+    }
+
+    @Override
+    public List<RoleMembership> getFirstLevelRoleMembers(List<String> roleIds) {
+        return getRoleService().getFirstLevelRoleMembers(roleIds);
+    }
+
+    @Override
+    public List<RoleMember> findRoleMembers(Map<String, String> fieldValues) {
+        return getRoleService().findRoleMembers(fieldValues);
+    }
+
+    @Override
+    public List<RoleMembership> findRoleMemberships(Map<String, String> fieldValues) {
+        return getRoleService().findRoleMemberships(fieldValues);
+    }
+
+    @Override
+    public void assignRoleToRole(String roleId, String namespaceCode, String roleName,
+                                 Map<String, String> qualifications) {
+        getRoleUpdateService().assignRoleToRole(
+                roleId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public void saveDelegationMemberForRole(String delegationMemberId, String roleMemberId, String memberId, String memberTypeCode,
+                                            String delegationTypeCode, String roleId, Map<String, String> qualifications,
+                                            Date activeFromDate, Date activeToDate) throws UnsupportedOperationException {
+        getRoleUpdateService().saveDelegationMemberForRole(delegationMemberId, roleMemberId, memberId, memberTypeCode, delegationTypeCode, roleId, qualifications, activeFromDate, activeToDate);
+        Role role = getRole(roleId);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public RoleMember saveRoleMemberForRole(String roleMemberId, String memberId, String memberTypeCode,
+                                            String roleId, Map<String, String> qualifications, Date activeFromDate, Date activeToDate) throws UnsupportedOperationException {
+        Role role = getRole(roleId);
+        RoleMember roleMember = getRoleUpdateService().saveRoleMemberForRole(roleMemberId, memberId, memberTypeCode, roleId, qualifications, activeFromDate, activeToDate);
+        removeCacheEntries(role.getId(), memberId);
+        return roleMember;
+    }
+
+    @Override
+    public void removeRoleFromRole(String roleId, String namespaceCode, String roleName,
+                                   Map<String, String> qualifications) {
+        getRoleUpdateService().removeRoleFromRole(roleId, namespaceCode, roleName, qualifications);
+        Role role = getRoleByName(namespaceCode, roleName);
+        removeCacheEntries(role.getId(), null);
+    }
+
+    @Override
+    public List<DelegateMember> findDelegateMembers(Map<String, String> fieldValues) {
+        return getRoleService().findDelegateMembers(fieldValues);
+    }
+
+    @Override
+    public List<DelegateMember> getDelegationMembersByDelegationId(String delegationId) {
+        return getRoleService().getDelegationMembersByDelegationId(delegationId);
+    }
+
+    @Override
+    public DelegateMember getDelegationMemberByDelegationAndMemberId(String delegationId, String memberId) {
+        return getRoleService().getDelegationMemberByDelegationAndMemberId(delegationId, memberId);
+    }
+
+    @Override
+    public DelegateMember getDelegationMemberById(String delegationMemberId) {
+        return getRoleService().getDelegationMemberById(delegationMemberId);
+    }
+
+    @Override
+    public List<RoleResponsibilityAction> getRoleMemberResponsibilityActions(String roleMemberId) {
+        return getRoleService().getRoleMemberResponsibilityActions(roleMemberId);
+    }
+
+    @Override
+    public DelegateType getDelegateTypeInfo(String roleId, String delegationTypeCode) {
+        return getRoleService().getDelegateTypeInfo(roleId, delegationTypeCode);
+    }
+
+    @Override
+    public DelegateType getDelegateTypeInfoById(String delegationId) {
+        return getRoleService().getDelegateTypeInfoById(delegationId);
+    }
+
+    @Override
+    public void saveRoleRspActions(String roleResponsibilityActionId, String roleId, String roleResponsibilityId, String roleMemberId,
+                                   String actionTypeCode, String actionPolicyCode, Integer priorityNumber, Boolean forceAction) {
+        getRoleUpdateService().saveRoleRspActions(roleResponsibilityActionId, roleId, roleResponsibilityId, roleMemberId, actionTypeCode, actionPolicyCode, priorityNumber, forceAction);
+        removeCacheEntries(roleId, null);
+    }
+
+    @Override
+    public List<RoleResponsibility> getRoleResponsibilities(String roleId) {
+        return getRoleService().getRoleResponsibilities(roleId);
+    }
+
+    @Override
+    public void applicationRoleMembershipChanged(String roleId) {
+        removeCacheEntries(roleId, null);
+        getRoleService().applicationRoleMembershipChanged(roleId);
+    }
+
+    // Spring and injection methods
+
+    public RoleService getRoleService() {
+        if (roleService == null) {
+            roleService = KimApiServiceLocator.getRoleService();
+        }
+        return roleService;
+    }
+
+    public RoleUpdateService getRoleUpdateService() {
+        try {
+            if (roleUpdateService == null) {
+                roleUpdateService = KimApiServiceLocator.getRoleUpdateService();
+                if (roleUpdateService == null) {
+                    throw new UnsupportedOperationException("null returned for RoleUpdateService, unable to update role data");
+                }
+            }
+        } catch (Exception ex) {
+            throw new UnsupportedOperationException("unable to obtain a RoleUpdateService, unable to update role data", ex);
+        }
+        return roleUpdateService;
+    }
+
+    /**
+     * This overridden method looks up roles based on criteria.  If you want
+     * to return all roles pass in an empty map.
+     */
+    @Override
+    public List<Role> lookupRoles(Map<String, String> searchCriteria) {
+        return getRoleService().lookupRoles(searchCriteria);
+    }
+
+    @Override
+    public void flushInternalRoleCache() {
+        getRoleService().flushInternalRoleCache();
+    }
+
+    @Override
+    public void flushInternalRoleMemberCache() {
+        getRoleService().flushInternalRoleMemberCache();
+    }
+
+    @Override
+    public void flushInternalDelegationCache() {
+        getRoleService().flushInternalDelegationCache();
+    }
+
+    @Override
+    public void flushInternalDelegationMemberCache() {
+        getRoleService().flushInternalDelegationMemberCache();
+    }
+
+    @Override
+    public void assignPermissionToRole(String permissionId, String roleId) throws UnsupportedOperationException {
+        getRoleUpdateService().assignPermissionToRole(permissionId, roleId);
+    }
+
+    @Override
+    public String getNextAvailableRoleId() throws UnsupportedOperationException {
+        return getRoleUpdateService().getNextAvailableRoleId();
+    }
+
+    @Override
+    public void saveRole(String roleId, String roleName, String roleDescription, boolean active, String kimTypeId, String namespaceCode) throws UnsupportedOperationException {
+        getRoleUpdateService().saveRole(roleId, roleName, roleDescription, active, kimTypeId, namespaceCode);
+    }
+
+    @Override
+    public List<String> getMemberParentRoleIds(String memberType,
+                                               String memberId) {
+        return getRoleService().getMemberParentRoleIds(memberType, memberId);
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java	(revision 32237)
@@ -0,0 +1,498 @@
+/*
+ * Copyright 2008-2009 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.service.impl;
+
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.apache.log4j.Logger;
+import org.kuali.rice.core.api.criteria.QueryByCriteria;
+import org.kuali.rice.kim.api.common.assignee.Assignee;
+import org.kuali.rice.kim.api.group.Group;
+import org.kuali.rice.kim.api.group.GroupService;
+import org.kuali.rice.kim.api.identity.IdentityService;
+import org.kuali.rice.kim.api.identity.CodedAttribute;
+import org.kuali.rice.kim.api.identity.affiliation.EntityAffiliationType;
+import org.kuali.rice.kim.api.identity.entity.Entity;
+import org.kuali.rice.kim.api.identity.entity.EntityDefault;
+import org.kuali.rice.kim.api.identity.entity.EntityDefaultQueryResults;
+import org.kuali.rice.kim.api.identity.entity.EntityQueryResults;
+import org.kuali.rice.kim.api.identity.external.EntityExternalIdentifierType;
+import org.kuali.rice.kim.api.identity.principal.Principal;
+import org.kuali.rice.kim.api.permission.Permission;
+import org.kuali.rice.kim.api.permission.PermissionService;
+import org.kuali.rice.kim.api.responsibility.Responsibility;
+import org.kuali.rice.kim.api.responsibility.ResponsibilityAction;
+import org.kuali.rice.kim.api.responsibility.ResponsibilityService;
+import org.kuali.rice.kim.api.services.IdentityManagementService;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class IdentityManagementServiceImpl implements IdentityManagementService {
+	private static final Logger LOG = Logger.getLogger( IdentityManagementServiceImpl.class );
+
+	private PermissionService permissionService;
+	private ResponsibilityService responsibilityService;
+	private IdentityService identityService;
+	private GroupService groupService;
+
+    @Override
+	public void flushAllCaches() {
+	}
+
+    @Override
+	public void flushEntityPrincipalCaches() {
+	}
+
+    @Override
+	public void flushGroupCaches() {
+	}
+
+    @Override
+	public void flushPermissionCaches() {
+	}
+
+    @Override
+	public void flushResponsibilityCaches() {
+		// nothing currently being cached
+	}
+
+
+    // AUTHORIZATION SERVICE
+    @Override
+    public boolean hasPermission(String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails) {
+    	if ( LOG.isDebugEnabled() ) {
+    		logHasPermissionCheck("Permission", principalId, namespaceCode, permissionName, permissionDetails);
+    	}
+        boolean hasPerm = getPermissionService().hasPermission(principalId, namespaceCode, permissionName, permissionDetails);
+        if ( LOG.isDebugEnabled() ) {
+            LOG.debug( "Result: " + hasPerm );
+        }
+    	return hasPerm;
+    }
+
+    @Override
+    public boolean isAuthorized(String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification ) {
+    	if ( qualification == null || qualification.isEmpty() ) {
+    		return hasPermission( principalId, namespaceCode, permissionName, permissionDetails );
+    	}
+    	if ( LOG.isDebugEnabled() ) {
+    		logAuthorizationCheck("Permission", principalId, namespaceCode, permissionName, permissionDetails, qualification);
+    	}
+        boolean isAuthorized = getPermissionService().isAuthorized(principalId, namespaceCode, permissionName, permissionDetails, qualification);
+    	if ( LOG.isDebugEnabled() ) {
+    		LOG.debug( "Result: " + isAuthorized );
+    	}
+    	return isAuthorized;
+    }
+
+    @Override
+    public boolean hasPermissionByTemplateName(String principalId, String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails) {
+    	if ( LOG.isDebugEnabled() ) {
+    		logHasPermissionCheck("Perm Templ", principalId, namespaceCode, permissionTemplateName, permissionDetails);
+    	}
+
+		boolean hasPerm = getPermissionService().hasPermissionByTemplateName(principalId, namespaceCode, permissionTemplateName, permissionDetails);
+
+   		if ( LOG.isDebugEnabled() ) {
+   			LOG.debug( "Result: " + hasPerm );
+   		}
+    	return hasPerm;
+    }
+
+    @Override
+    public boolean isAuthorizedByTemplateName(String principalId, String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails, Map<String, String> qualification ) {
+    	if ( qualification == null || qualification.isEmpty() ) {
+    		return hasPermissionByTemplateName( principalId, namespaceCode, permissionTemplateName, new HashMap<String, String>(permissionDetails) );
+    	}
+    	if ( LOG.isDebugEnabled() ) {
+    		logAuthorizationCheck("Perm Templ", principalId, namespaceCode, permissionTemplateName, new HashMap<String, String>(permissionDetails), new HashMap<String, String>(qualification));
+    	}
+    	boolean isAuthorized = getPermissionService().isAuthorizedByTemplateName( principalId, namespaceCode, permissionTemplateName, new HashMap<String, String>(permissionDetails), new HashMap<String, String>(qualification) );
+   		if ( LOG.isDebugEnabled() ) {
+   			LOG.debug( "Result: " + isAuthorized );
+   		}
+    	return isAuthorized;
+    }
+
+    @Override
+    public List<Permission> getAuthorizedPermissions(String principalId,
+                                                     String namespaceCode, String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification) {
+    	return getPermissionService().getAuthorizedPermissions(principalId, namespaceCode, permissionName, permissionDetails, qualification);
+    }
+
+    @Override
+    public List<Permission> getAuthorizedPermissionsByTemplateName(String principalId,
+                                                                   String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails, Map<String, String> qualification) {
+    	return getPermissionService().getAuthorizedPermissionsByTemplateName(principalId, namespaceCode, permissionTemplateName, permissionDetails, qualification);
+    }
+
+    @Override
+    public boolean isPermissionDefinedForTemplateName(String namespaceCode, String permissionTemplateName, Map<String, String> permissionDetails) {
+        return getPermissionService().isPermissionDefinedByTemplateName(namespaceCode, permissionTemplateName,
+                permissionDetails);
+    }
+
+    @Override
+	public List<Assignee> getPermissionAssignees(String namespaceCode,
+			String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification) {
+		return this.permissionService.getPermissionAssignees(namespaceCode, permissionName,
+                permissionDetails, qualification);
+	}
+
+    @Override
+	public List<Assignee> getPermissionAssigneesForTemplateName(String namespaceCode,
+			String permissionTemplateName, Map<String, String> permissionDetails,
+			Map<String, String> qualification) {
+		return this.permissionService.getPermissionAssigneesByTemplateName(namespaceCode, permissionTemplateName,
+                new HashMap<String, String>(permissionDetails), new HashMap<String, String>(qualification));
+	}
+
+    // GROUP SERVICE
+    @Override
+	public boolean isMemberOfGroup(String principalId, String groupId) {
+		return getGroupService().isMemberOfGroup(principalId, groupId);
+	}
+    @Override
+	public boolean isMemberOfGroup(String principalId, String namespaceCode, String groupName) {
+		Group group = getGroupByName(namespaceCode, groupName);
+		return group == null ? false : isMemberOfGroup(principalId, group.getId());
+    }
+    @Override
+	public boolean isGroupMemberOfGroup(String potentialMemberId, String potentialParentId)
+	{
+	       return getGroupService()
+	                .isGroupMemberOfGroup(potentialMemberId, potentialParentId);
+	}
+    @Override
+	public List<String> getGroupMemberPrincipalIds(String groupId) {
+		return getGroupService().getMemberPrincipalIds(groupId);
+	}
+    @Override
+	public List<String> getDirectGroupMemberPrincipalIds(String groupId) {
+		return getGroupService().getDirectMemberPrincipalIds(groupId);
+	}
+    @Override
+    public List<String> getGroupIdsForPrincipal(String principalId) {
+		return getGroupService().getGroupIdsByPrincipalId(principalId);
+	}
+    @Override
+    public List<String> getGroupIdsForPrincipal(String principalId, String namespaceCode ) {
+		return getGroupService().getGroupIdsByPrincipalIdAndNamespaceCode(principalId, namespaceCode);
+	}
+    @Override
+    public List<Group> getGroupsForPrincipal(String principalId) {
+		return getGroupService().getGroupsByPrincipalId(principalId);
+	}
+    @Override
+    public List<Group> getGroupsForPrincipal(String principalId, String namespaceCode ) {
+		return getGroupService().getGroupsByPrincipalIdAndNamespaceCode(principalId, namespaceCode);
+	}
+    @Override
+    public List<String> getMemberGroupIds(String groupId) {
+		return getGroupService().getMemberGroupIds(groupId);
+	}
+    @Override
+    public List<String> getDirectMemberGroupIds(String groupId) {
+		return getGroupService().getDirectMemberGroupIds(groupId);
+	}
+    @Override
+    public Group getGroup(String groupId) {
+		return getGroupService().getGroup(groupId);
+	}
+    @Override
+    public Group getGroupByName(String namespaceCode, String groupName) {
+		return getGroupService().getGroupByNameAndNamespaceCode(namespaceCode, groupName);
+    }
+    @Override
+    public List<String> getParentGroupIds(String groupId) {
+		return getGroupService().getParentGroupIds(groupId);
+	}
+    @Override
+    public List<String> getDirectParentGroupIds(String groupId) {
+		return getGroupService().getDirectParentGroupIds( groupId );
+	}
+
+    @Override
+    public boolean addGroupToGroup(String childId, String parentId) {
+        return getGroupService().addGroupToGroup(childId, parentId);
+    }
+
+    @Override
+    public boolean addPrincipalToGroup(String principalId, String groupId) {
+        return getGroupService().addPrincipalToGroup(principalId, groupId);
+    }
+
+    @Override
+    public boolean removeGroupFromGroup(String childId, String parentId) {
+        return getGroupService().removeGroupFromGroup(childId, parentId);
+    }
+
+    @Override
+    public boolean removePrincipalFromGroup(String principalId, String groupId) {
+        return getGroupService().removePrincipalFromGroup(principalId, groupId);
+    }
+
+    @Override
+	public Group createGroup(Group group) {
+		return getGroupService().createGroup(group);
+	}
+
+    @Override
+	public void removeAllMembers(String groupId) {
+		getGroupService().removeAllMembers(groupId);
+	}
+
+    @Override
+	public Group updateGroup(String groupId, Group group) {
+		return getGroupService().updateGroup(groupId, group);
+	}
+
+
+    // IDENTITY SERVICE
+    @Override
+	public Principal getPrincipal(String principalId) {
+		return getIdentityService().getPrincipal(principalId);
+	}
+
+    @Override
+    public Principal getPrincipalByPrincipalName(String principalName) {
+		return getIdentityService().getPrincipalByPrincipalName(principalName);
+    }
+
+    @Override
+    public Principal getPrincipalByPrincipalNameAndPassword(String principalName, String password) {
+    	return getIdentityService().getPrincipalByPrincipalNameAndPassword(principalName, password);
+    }
+
+    @Override
+    public EntityDefault getEntityDefaultInfo(String entityId) {
+    		return getIdentityService().getEntityDefault(entityId);
+    }
+
+    @Override
+    public EntityDefault getEntityDefaultInfoByPrincipalId(
+    		String principalId) {
+	    	return getIdentityService().getEntityDefaultByPrincipalId(principalId);
+    }
+
+    @Override
+    public EntityDefault getEntityDefaultInfoByPrincipalName(
+    		String principalName) {
+	    	return getIdentityService().getEntityDefaultByPrincipalName(principalName);
+    }
+
+    @Override
+    public EntityDefaultQueryResults findEntityDefaults(QueryByCriteria queryByCriteria) {
+        return getIdentityService().findEntityDefaults(queryByCriteria);
+    }
+
+    @Override
+	public Entity getEntity(String entityId) {
+    		return getIdentityService().getEntity(entityId);
+	}
+
+    @Override
+    public Entity getEntityByPrincipalId(String principalId) {
+        return getIdentityService().getEntityByPrincipalId(principalId);
+    }
+
+    @Override
+    public Entity getEntityByPrincipalName(String principalName) {
+        return getIdentityService().getEntityByPrincipalName(principalName);
+    }
+
+    @Override
+    public EntityQueryResults findEntities(QueryByCriteria queryByCriteria) {
+        return getIdentityService().findEntities(queryByCriteria);
+    }
+
+    @Override
+	public CodedAttribute getAddressType( String code ) {
+		return getIdentityService().getAddressType(code);
+	}
+
+    @Override
+    public CodedAttribute getEmailType( String code ) {
+		return getIdentityService().getEmailType(code);
+	}
+
+    @Override
+	public EntityAffiliationType getAffiliationType( String code ) {
+			return getIdentityService().getAffiliationType(code);
+	}
+
+    @Override
+	public CodedAttribute getCitizenshipStatus( String code ) {
+			return CodedAttribute.Builder.create(getIdentityService().getCitizenshipStatus(code)).build();
+	}
+    @Override
+	public CodedAttribute getEmploymentStatus( String code ) {
+			return getIdentityService().getEmploymentStatus(code);
+	}
+    @Override
+	public CodedAttribute getEmploymentType( String code ) {
+			return getIdentityService().getEmploymentType(code);
+	}
+    @Override
+	public CodedAttribute getEntityNameType( String code ) {
+			return getIdentityService().getNameType(code);
+	}
+    @Override
+	public CodedAttribute getEntityType( String code ) {
+		return getIdentityService().getEntityType(code);
+	}
+    @Override
+	public EntityExternalIdentifierType getExternalIdentifierType( String code ) {
+			return getIdentityService().getExternalIdentifierType(code);
+	}
+    @Override
+	public CodedAttribute getPhoneType( String code ) {
+			return getIdentityService().getPhoneType(code);
+	}
+
+    // ----------------------
+    // Responsibility Methods
+    // ----------------------
+
+    @Override
+	public Responsibility getResponsibility(String responsibilityId) {
+		return getResponsibilityService().getResponsibility( responsibilityId );
+	}
+
+    @Override
+	public boolean hasResponsibility(String principalId, String namespaceCode,
+			String responsibilityName, Map<String, String> qualification,
+			Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().hasResponsibility( principalId, namespaceCode, responsibilityName,
+                qualification, responsibilityDetails );
+	}
+
+    @Override
+	public Responsibility getResponsibilityByName( String namespaceCode, String responsibilityName) {
+		return getResponsibilityService().findRespByNamespaceCodeAndName(namespaceCode, responsibilityName);
+	}
+
+    @Override
+	public List<ResponsibilityAction> getResponsibilityActions( String namespaceCode, String responsibilityName,
+    		Map<String, String> qualification, Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().getResponsibilityActions( namespaceCode, responsibilityName, qualification,
+                responsibilityDetails );
+	}
+
+    @Override
+	public List<ResponsibilityAction> getResponsibilityActionsByTemplateName(
+			String namespaceCode, String responsibilityTemplateName,
+			Map<String, String> qualification, Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().getResponsibilityActionsByTemplateName(namespaceCode, responsibilityTemplateName,
+                qualification, responsibilityDetails);
+	}
+
+    @Override
+	public boolean hasResponsibilityByTemplateName(String principalId,
+			String namespaceCode, String responsibilityTemplateName,
+			Map<String, String> qualification, Map<String, String> responsibilityDetails) {
+		return getResponsibilityService().hasResponsibilityByTemplateName(principalId, namespaceCode, responsibilityTemplateName,
+                qualification, responsibilityDetails);
+	}
+
+    protected void logAuthorizationCheck(String checkType, String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails, Map<String, String> qualification ) {
+		StringBuilder sb = new StringBuilder();
+		sb.append(  '\n' );
+		sb.append( "Is AuthZ for " ).append( checkType ).append( ": " ).append( namespaceCode ).append( "/" ).append( permissionName ).append( '\n' );
+		sb.append( "             Principal:  " ).append( principalId );
+		if ( principalId != null ) {
+			Principal principal = getPrincipal( principalId );
+			if ( principal != null ) {
+				sb.append( " (" ).append( principal.getPrincipalName() ).append( ')' );
+			}
+		}
+		sb.append( '\n' );
+		sb.append( "             Details:\n" );
+		if ( permissionDetails != null ) {
+			sb.append( permissionDetails);
+		} else {
+			sb.append( "                         [null]\n" );
+		}
+		sb.append( "             Qualifiers:\n" );
+		if ( qualification != null && !qualification.isEmpty() ) {
+			sb.append( qualification);
+		} else {
+			sb.append( "                         [null]\n" );
+		}
+		if (LOG.isTraceEnabled()) {
+			LOG.trace( sb.append(ExceptionUtils.getStackTrace(new Throwable())));
+		} else {
+			LOG.debug(sb.toString());
+		}
+    }
+
+    protected void logHasPermissionCheck(String checkType, String principalId, String namespaceCode, String permissionName, Map<String, String> permissionDetails ) {
+		StringBuilder sb = new StringBuilder();
+		sb.append(  '\n' );
+		sb.append( "Has Perm for " ).append( checkType ).append( ": " ).append( namespaceCode ).append( "/" ).append( permissionName ).append( '\n' );
+		sb.append( "             Principal:  " ).append( principalId );
+		if ( principalId != null ) {
+			Principal principal = getPrincipal( principalId );
+			if ( principal != null ) {
+				sb.append( " (" ).append( principal.getPrincipalName() ).append( ')' );
+			}
+		}
+		sb.append(  '\n' );
+		sb.append( "             Details:\n" );
+		if ( permissionDetails != null ) {
+			sb.append( permissionDetails);
+		} else {
+			sb.append( "                         [null]\n" );
+		}
+		if (LOG.isTraceEnabled()) {
+			LOG.trace( sb.append( ExceptionUtils.getStackTrace(new Throwable())) );
+		} else {
+			LOG.debug(sb.toString());
+		}
+    }
+
+    	// OTHER METHODS
+
+	public IdentityService getIdentityService() {
+		if ( identityService == null ) {
+			identityService = KimApiServiceLocator.getIdentityService();
+		}
+		return identityService;
+	}
+
+	public GroupService getGroupService() {
+		if ( groupService == null ) {
+			groupService = KimApiServiceLocator.getGroupService();
+		}
+		return groupService;
+	}
+
+	public PermissionService getPermissionService() {
+		if ( permissionService == null ) {
+			permissionService = KimApiServiceLocator.getPermissionService();
+		}
+		return permissionService;
+	}
+
+	public ResponsibilityService getResponsibilityService() {
+		if ( responsibilityService == null ) {
+			responsibilityService = KimApiServiceLocator.getResponsibilityService();
+		}
+		return responsibilityService;
+	}
+}

Property changes on: work/src/org/kuali/rice/kim/service/impl/IdentityManagementServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java	(revision 32237)
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.List;
+
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+
+import org.kuali.rice.core.impl.jaxb.DataXmlDTO;
+
+/**
+ * Helper class for importing and exporting KIM XML.
+ * 
+ * <p>TODO: Should this be converted into a service instead?
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class KimXmlUtil {
+    // Do not allow outside code to instantiate this class.
+    private KimXmlUtil() {}
+    
+    /**
+     * Parses permissions and/or roles from XML.
+     * 
+     * @param inputStream The input stream to read the XML from.
+     */
+    public static void parseKimXml(InputStream inputStream) {
+        try {
+            JAXBContext jaxbContext = JAXBContext.newInstance(DataXmlDTO.class);
+            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
+            unmarshaller.unmarshal(inputStream);
+        } catch (JAXBException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    
+    /**
+     * Exports one or more sets of KIM objects to XML.
+     * 
+     * @param outputStream The output stream to write the XML to.
+     * @param permissions The KIM permissions to export; set to a null or empty list to prevent exportation of a &lt;permissionData&gt; element.
+     * @param roles The KIM roles to export; set to a null or empty list to prevent exportation of a &lt;roleData&gt; element.
+     */
+    public static void exportKimXml(OutputStream outputStream, List<? extends Object> permissions, List<? extends Object> roles) {
+        PermissionDataXmlDTO permissionData = (permissions != null && !permissions.isEmpty()) ?
+                new PermissionDataXmlDTO(new PermissionsXmlDTO(permissions)) : null;
+        RoleDataXmlDTO roleData = (roles != null && !roles.isEmpty()) ?
+                new RoleDataXmlDTO(new RolesXmlDTO(roles)) : null;
+        try {
+            JAXBContext jaxbContext = JAXBContext.newInstance(DataXmlDTO.class);
+            Marshaller marshaller = jaxbContext.createMarshaller();
+            marshaller.marshal(new DataXmlDTO(permissionData, roleData), outputStream);
+        } catch (JAXBException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/KimXmlUtil.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java	(revision 32237)
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.core.util.jaxb.StringTrimmingAdapter;
+import org.kuali.rice.kim.api.jaxb.NameAndNamespacePairToPermTemplateIdAdapter;
+import org.kuali.rice.kim.api.jaxb.PermissionDetailListAdapter;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This class represents a &lt;permission&gt; XML element.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionType", propOrder={
+        "permissionNameAndNamespace", "permissionTemplateId", "permissionDescription", "active", "permissionDetails"
+})
+public class PermissionXmlDTO implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+
+    @XmlTransient
+    private String permissionId;
+    
+    @XmlElement(name="permissionName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair permissionNameAndNamespace;
+    
+    @XmlElement(name="templateName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairToPermTemplateIdAdapter.class)
+    private String permissionTemplateId;
+    
+    @XmlElement(name="description")
+    @XmlJavaTypeAdapter(StringTrimmingAdapter.class)
+    private String permissionDescription;
+    
+    @XmlElement(name="active")
+    private Boolean active;
+    
+    @XmlElement(name="permissionDetails")
+    @XmlJavaTypeAdapter(PermissionDetailListAdapter.class)
+    private Map<String, String> permissionDetails;
+    
+    public PermissionXmlDTO() {
+        this.active = Boolean.TRUE;
+    }
+    
+    public PermissionXmlDTO(PermissionContract permission) {
+        this.permissionNameAndNamespace = new NameAndNamespacePair(permission.getNamespaceCode(), permission.getName());
+        this.permissionTemplateId = permission.getTemplate().getId();
+        this.permissionDescription = permission.getDescription();
+        this.active = Boolean.valueOf(permission.isActive());
+        this.permissionDetails = (permission.getAttributes() != null) ?
+                new HashMap<String, String>(permission.getAttributes()) : new HashMap<String, String>();
+    }
+    
+    /**
+     * @return the permissionId
+     */
+    public String getPermissionId() {
+        return this.permissionId;
+    }
+
+    /**
+     * @param permissionId the permissionId to set
+     */
+    public void setPermissionId(String permissionId) {
+        this.permissionId = permissionId;
+    }
+
+    /**
+     * @return the permissionNameAndNamespace
+     */
+    public NameAndNamespacePair getPermissionNameAndNamespace() {
+        return this.permissionNameAndNamespace;
+    }
+
+    /**
+     * @param permissionNameAndNamespace the permissionNameAndNamespace to set
+     */
+    public void setPermissionNameAndNamespace(NameAndNamespacePair permissionNameAndNamespace) {
+        this.permissionNameAndNamespace = permissionNameAndNamespace;
+    }
+
+    /**
+     * @return the permissionTemplateId
+     */
+    public String getPermissionTemplateId() {
+        return this.permissionTemplateId;
+    }
+
+    /**
+     * @param permissionTemplateId the permissionTemplateId to set
+     */
+    public void setPermissionTemplateId(String permissionTemplateId) {
+        this.permissionTemplateId = permissionTemplateId;
+    }
+
+    /**
+     * @return the permissionDescription
+     */
+    public String getPermissionDescription() {
+        return this.permissionDescription;
+    }
+
+    /**
+     * @param permissionDescription the permissionDescription to set
+     */
+    public void setPermissionDescription(String permissionDescription) {
+        this.permissionDescription = permissionDescription;
+    }
+
+    /**
+     * @return the active
+     */
+    public Boolean getActive() {
+        return this.active;
+    }
+
+    /**
+     * @param active the active to set
+     */
+    public void setActive(Boolean active) {
+        this.active = active;
+    }
+
+    /**
+     * @return the permissionDetails
+     */
+    public Map<String, String> getPermissionDetails() {
+        return this.permissionDetails;
+    }
+
+    /**
+     * @param permissionDetails the permissionDetails to set
+     */
+    public void setPermissionDetails(Map<String, String> permissionDetails) {
+        this.permissionDetails = permissionDetails;
+    }
+
+    /**
+     * Retrieves the permission's name from the permission-name-and-namespace combo.
+     * 
+     * @return The name of the permission, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getPermissionName() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getName() : null;
+    }
+
+    /**
+     * Retrieves the permission's namespace code from the permission-name-and-namespace combo.
+     * 
+     * @return The namespace code of the permission, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getNamespaceCode() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getNamespaceCode() : null;
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java	(revision 32237)
@@ -0,0 +1,406 @@
+/**
+ * Copyright 2005-2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.joda.time.DateTime;
+import org.kuali.rice.core.api.criteria.QueryByCriteria;
+import org.kuali.rice.core.api.membership.MemberType;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.kim.api.KimConstants.KimUIConstants;
+import org.kuali.rice.kim.api.group.GroupContract;
+import org.kuali.rice.kim.api.identity.principal.PrincipalContract;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.role.Role;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.kim.api.role.RoleMember;
+import org.kuali.rice.kim.api.role.RoleMemberContract;
+import org.kuali.rice.kim.api.role.RoleService;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+import javax.xml.bind.UnmarshalException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Set;
+
+import static org.kuali.rice.core.api.criteria.PredicateFactory.equal;
+
+/**
+ * Helper class containing static methods for aiding in parsing role XML.
+ * 
+ * <p>All non-private methods are package-private so that only the KIM-parsing-related code can make use of them. (TODO: Is that necessary?)
+ * 
+ * <p>TODO: Should this be converted into a service instead?
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class RoleXmlUtil {
+    // Do not allow outside code to instantiate this class.
+    private RoleXmlUtil() {}
+
+    /**
+     * Performs the necessary validation on the new role, then saves it.
+     * 
+     * @param newRole The role to persist.
+     * @return The ID of the persisted role.
+     * @throws IllegalArgumentException if newRole is null.
+     * @throws UnmarshalException if newRole contains invalid data.
+     */
+    static String validateAndPersistNewRole(RoleXmlDTO newRole) throws UnmarshalException {
+        if (newRole == null) {
+            throw new IllegalArgumentException("Cannot persist a null role");
+        }
+        
+        // Validate the role and (if applicable) retrieve the ID from an existing matching role.
+        validateAndPrepareRole(newRole);
+
+        Role.Builder builder = Role.Builder.create();
+        builder.setActive(newRole.getActive());
+        builder.setDescription(newRole.getRoleDescription());
+        builder.setId(newRole.getRoleId());
+        builder.setKimTypeId(newRole.getKimTypeId());
+        builder.setName(newRole.getRoleName());
+        builder.setNamespaceCode(newRole.getNamespaceCode());
+
+        //save the role
+        Role role = KimApiServiceLocator.getRoleService().createRole(builder.build());
+
+        // Set a flag on the role to indicate that it has now been persisted so that the unmarshalling process will not save this role more than once.
+        newRole.setAlreadyPersisted(true);
+        
+        return role.getId();
+    }
+    
+    /**
+     * Performs the necessary validation on the new role member, then saves it.
+     * 
+     * @param newRoleMember The role member to save.
+     * @return The ID of the persisted role member.
+     * @throws IllegalArgumentException if newRoleMember is null.
+     * @throws UnmarshalException if newRoleMember contains invalid data.
+     */
+    static String validateAndPersistNewRoleMember(RoleMemberXmlDTO newRoleMember) throws UnmarshalException {
+        
+        if (newRoleMember == null) {
+            throw new IllegalArgumentException("Cannot persist a null role member");
+        }
+        
+        // Validate role ID and role name/namespace.
+        validateRoleIdAndRoleNameForMember(newRoleMember);
+        
+        // Validate member type, member ID, and member name/namespace.
+        validateMemberIdentity(newRoleMember);
+        
+        // Validate the from/to dates, if defined.
+        if (newRoleMember.getActiveFromDate() != null && newRoleMember.getActiveToDate() != null &&
+                newRoleMember.getActiveFromDate().compareTo(newRoleMember.getActiveToDate()) > 0) {
+            throw new UnmarshalException("Cannot create a role member whose activeFromDate occurs after its activeToDate");
+        }
+        
+        // Define defaults as needed.
+        if (newRoleMember.getQualifications() == null) {
+            newRoleMember.setQualifications(new HashMap<String, String>());
+        }
+
+        RoleMember.Builder builder = RoleMember.Builder.create(newRoleMember.getRoleId(), newRoleMember.getRoleIdAsMember(),
+                newRoleMember.getMemberId(), newRoleMember.getMemberType(),
+                newRoleMember.getActiveFromDate() == null ? null : new DateTime(newRoleMember.getActiveFromDate().getMillis()),
+                newRoleMember.getActiveToDate() == null ? null : new DateTime(newRoleMember.getActiveToDate().getMillis()),
+                newRoleMember.getQualifications());
+
+        // Save the role member.
+        RoleMemberContract newMember = KimApiServiceLocator.getRoleService().createRoleMember(builder.build());
+        
+        return newMember.getRoleMemberId();
+    }
+    
+    /**
+     * Performs the necessary validation on the role permission, then saves it.
+     * 
+     * @param newRolePermission The role permission to save.
+     * @throws IllegalArgumentException if newRolePermission is null
+     * @throws UnmarshalException if newRolePermission contains invalid data.
+     */
+    static void validateAndPersistNewRolePermission(RolePermissionXmlDTO newRolePermission) throws UnmarshalException {
+        if (newRolePermission == null) {
+            throw new IllegalArgumentException("newRolePermission cannot be null");
+        }
+        
+        // Validate the role permission, and prepare its role ID if necessary.
+        validateAndPrepareRolePermission(newRolePermission);
+        
+        // Save the role permission.
+        KimApiServiceLocator.getRoleService().assignPermissionToRole(newRolePermission.getPermissionId(), newRolePermission.getRoleId());
+    }
+    
+    /**
+     * Removes any role members for a given role whose IDs are not listed in a given role member ID set.
+     * 
+     * @param roleId The ID of the role containing the role members.
+     * @param existingRoleMemberIds The IDs of the role members that should not be removed.
+     * @throws IllegalArgumentException if roleId is blank or refers to a non-existent role, or if existingRoleMemberIds is null.
+     */
+    static void removeRoleMembers(String roleId, Set<String> existingRoleMemberIds) {
+        if (StringUtils.isBlank(roleId)) {
+            throw new IllegalArgumentException("roleId cannot be blank");
+        } else if (existingRoleMemberIds == null) {
+            throw new IllegalArgumentException("existingRoleMemberIds cannot be null");
+        }
+        RoleService roleUpdateService = KimApiServiceLocator.getRoleService();
+        RoleContract role = KimApiServiceLocator.getRoleService().getRole(roleId);
+        if (role == null) {
+            throw new IllegalArgumentException("Cannot remove role members for role with ID \"" + roleId + "\" because that role does not exist");
+        }
+        
+        // Remove any role members whose IDs are not in the set.
+        List<RoleMember> roleMembers = KimApiServiceLocator.getRoleService().findRoleMembers(
+                QueryByCriteria.Builder.fromPredicates(equal("roleId", roleId))).getResults();
+        if (roleMembers != null && !roleMembers.isEmpty()) {
+            for (RoleMemberContract roleMember : roleMembers) {
+                if (!existingRoleMemberIds.contains(roleMember.getRoleMemberId())) {
+                    // If the role member needs to be removed, use the member type code to determine which removal method to call.
+                    MemberType memberType = roleMember.getMemberType();
+                    if (MemberType.PRINCIPAL.equals(memberType)) {
+                        roleUpdateService.removePrincipalFromRole(roleMember.getMemberId(), role.getNamespaceCode(), role.getName(),
+                                (roleMember.getAttributes() != null) ? roleMember.getAttributes() : new HashMap<String, String>());
+                    } else if (MemberType.GROUP.equals(memberType)) {
+                        roleUpdateService.removeGroupFromRole(roleMember.getMemberId(), role.getNamespaceCode(), role.getName(),
+                                (roleMember.getAttributes() != null) ? roleMember.getAttributes() :new HashMap<String, String>());
+                    } else if (MemberType.ROLE.equals(memberType)) {
+                        roleUpdateService.removeRoleFromRole(roleMember.getMemberId(), role.getNamespaceCode(), role.getName(),
+                                (roleMember.getAttributes() != null) ? roleMember.getAttributes() : new HashMap<String, String>());
+                    }
+                }
+            }
+        }
+    }
+    
+    /**
+     * Validates a new role's name, namespace, KIM type, and description, and sets the role's ID if the name and namespace match an existing role.
+     */
+    private static void validateAndPrepareRole(RoleXmlDTO newRole) throws UnmarshalException {
+        // Ensure that the role name, role namespace, KIM type, and description have all been specified.
+        if (StringUtils.isBlank(newRole.getRoleName()) || StringUtils.isBlank(newRole.getNamespaceCode())) {
+            throw new UnmarshalException("Cannot create or override a role with a blank name or a blank namespace");
+        } else if (StringUtils.isBlank(newRole.getKimTypeId())) {
+            throw new UnmarshalException("Cannot create or override a role without specikfying a KIM type");
+        } else if (StringUtils.isBlank(newRole.getRoleDescription())) {
+            throw new UnmarshalException("Cannot create or override a role with a blank description");
+        }
+        
+        // Attempt to find an existing matching role, and assign its ID to the validated role if it exists.
+        String matchingId = KimApiServiceLocator.getRoleService().getRoleIdByNameAndNamespaceCode(
+                newRole.getNamespaceCode(), newRole.getRoleName());
+        if (StringUtils.isNotBlank(matchingId)) {
+            newRole.setRoleId(matchingId);
+        }
+    }
+    
+    /**
+     * Validates a new role member's role ID, role name, and role namespace.
+     */
+    private static void validateRoleIdAndRoleNameForMember(RoleMemberXmlDTO newRoleMember) throws UnmarshalException {
+        // If the "roleMember" tag was not a descendant of a "role" tag, derive and validate its role information accordingly.
+        if (newRoleMember instanceof RoleMemberXmlDTO.OutsideOfRole) {
+            RoleMemberXmlDTO.OutsideOfRole standaloneMember = (RoleMemberXmlDTO.OutsideOfRole) newRoleMember;
+            if (standaloneMember.getRoleNameAndNamespace() != null) {
+                // If a name + namespace combo is given, verify that the combo maps to an existing role.
+                String existingId = KimApiServiceLocator.getRoleService().getRoleIdByNameAndNamespaceCode(
+                        standaloneMember.getRoleNamespaceCode(), standaloneMember.getRoleName());
+                if (StringUtils.isBlank(existingId)) {
+                    throw new UnmarshalException("Cannot create role member for role with name \"" + standaloneMember.getRoleName() + "\" and namespace \"" +
+                            standaloneMember.getRoleNamespaceCode() + "\" because such a role does not exist");
+                }
+                
+                // If the role member defines its own role ID, verify that it's the same as the one from the existing role; otherwise, assign the member's role ID.
+                if (StringUtils.isBlank(standaloneMember.getRoleId())) {
+                    standaloneMember.setRoleId(existingId);
+                } else if (!standaloneMember.getRoleId().equals(existingId)) {
+                    throw new UnmarshalException("Cannot create role member for role with ID \"" + standaloneMember.getRoleId() + "\", name \"" +
+                            standaloneMember.getRoleName() + "\", and namespace \"" + standaloneMember.getRoleNamespaceCode() +
+                                    "\" because the existing role with the same name and namespace has an ID of \"" + existingId + "\" instead");
+                }
+            } else if (StringUtils.isBlank(standaloneMember.getRoleId())) {
+                throw new UnmarshalException("Cannot create role member without providing the role ID or role name + namespace that the member belongs to");
+            } else if (KimApiServiceLocator.getRoleService().getRole(standaloneMember.getRoleId()) == null) {
+                throw new UnmarshalException("Cannot create role member for the role with ID \"" + standaloneMember.getRoleId() + "\" because that role does not exist");
+            }
+        }
+        
+        // Ensure that a role ID was explicitly defined or was derived from a name + namespace combo.
+        if (StringUtils.isBlank(newRoleMember.getRoleId())) {
+            throw new UnmarshalException("Cannot create role member without providing the role ID or role name + namespace that the member belongs to");
+        }
+    }
+    
+    /**
+     * Validates a new role member's member type, member ID, member name, and (if applicable) member namespace code.
+     */
+    private static void validateMemberIdentity(RoleMemberXmlDTO newRoleMember) throws UnmarshalException {
+        // Ensure that sufficient and non-conflicting membership info has been set. (The getMemberTypeCode() method performs such validation.)
+        MemberType memberType = newRoleMember.getMemberType();
+        if (memberType == null) {
+            throw new UnmarshalException("Cannot create a role member with no member principal/group/role identification information specified");
+        }
+        
+        // Ensure that a valid member ID was specified, if present.
+        if (StringUtils.isNotBlank(newRoleMember.getMemberId())) {
+            if (MemberType.PRINCIPAL.equals(memberType)) {
+                // If the member is a principal, ensure that the principal exists.
+                if (KimApiServiceLocator.getIdentityService().getPrincipal(newRoleMember.getPrincipalId()) == null) {
+                    throw new UnmarshalException("Cannot create principal role member with principal ID \"" +
+                            newRoleMember.getPrincipalId() + "\" because such a person does not exist");
+                }
+            } else if (MemberType.GROUP.equals(memberType)) {
+                // If the member is a group, ensure that the group exists.
+                if (KimApiServiceLocator.getGroupService().getGroup(newRoleMember.getGroupId()) == null) {
+                    throw new UnmarshalException("Cannot create group role member with group ID \"" +
+                            newRoleMember.getGroupId() + "\" because such a group does not exist");
+                }
+            } else if (MemberType.ROLE.equals(memberType)) {
+                // If the member is another role, ensure that the role exists and that the role is not trying to become a member of itself.
+                if (newRoleMember.getRoleId().equals(newRoleMember.getRoleIdAsMember())) {
+                    throw new UnmarshalException("The role with ID \"" + newRoleMember.getRoleIdAsMember() + "\" cannot be made a member of itself");
+                } else if (KimApiServiceLocator.getRoleService().getRole(newRoleMember.getRoleIdAsMember()) == null) {
+                    throw new UnmarshalException("Cannot use role with ID \"" + newRoleMember.getRoleIdAsMember() +
+                            "\" as a role member because such a role does not exist");
+                }
+            }
+        }
+        
+        // Ensure that a valid member name (and namespace, if applicable) was specified, if present.
+        if (StringUtils.isNotBlank(newRoleMember.getMemberName())) {
+            if (MemberType.PRINCIPAL.equals(memberType)) {
+                //If the member is a principal, ensure that the principal exists and does not conflict with any existing principal ID information.
+                PrincipalContract tempPrincipal = KimApiServiceLocator.getIdentityService().getPrincipalByPrincipalName(newRoleMember.getPrincipalName());
+                if (tempPrincipal == null) {
+                    throw new UnmarshalException("Cannot create principal role member with principal name \"" +
+                            newRoleMember.getPrincipalName() + "\" because such a person does not exist");
+                } else if (StringUtils.isBlank(newRoleMember.getPrincipalId())) {
+                    // If no principal ID was given, assign one from the retrieved principal.
+                    newRoleMember.setPrincipalId(tempPrincipal.getPrincipalId());
+                } else if (!newRoleMember.getPrincipalId().equals(tempPrincipal.getPrincipalId())) {
+                    throw new UnmarshalException("Cannot create principal role member with principal ID \"" + newRoleMember.getPrincipalId() +
+                            "\" and principal name \"" + newRoleMember.getPrincipalName() + "\" because the principal with that name has an ID of \"" +
+                                    tempPrincipal.getPrincipalId() + "\" instead");
+                }
+            } else if (MemberType.GROUP.equals(memberType)) {
+                // If the member is a group, ensure that the group exists and does not conflict with any existing group ID information.
+                NameAndNamespacePair groupNameAndNamespace = newRoleMember.getGroupName();
+                GroupContract tempGroup = KimApiServiceLocator.getGroupService().getGroupByNameAndNamespaceCode(
+                        groupNameAndNamespace.getNamespaceCode(), groupNameAndNamespace.getName());
+                if (tempGroup == null) {
+                    throw new UnmarshalException("Cannot create group role member with namespace \"" + groupNameAndNamespace.getNamespaceCode() +
+                            "\" and name \"" + groupNameAndNamespace.getName() + "\" because such a group does not exist");
+                } else if (StringUtils.isBlank(newRoleMember.getGroupId())) {
+                    // If no group ID was given, assign one from the retrieved group.
+                    newRoleMember.setGroupId(tempGroup.getId());
+                } else if (!newRoleMember.getGroupId().equals(tempGroup.getId())) {
+                    throw new UnmarshalException("Cannot create group role member with ID \"" + newRoleMember.getGroupId() + "\", namespace \"" +
+                            groupNameAndNamespace.getNamespaceCode() + "\", and name \"" + groupNameAndNamespace.getName() +
+                                    "\" because the group with that namespace and name has an ID of \"" + tempGroup.getId() + "\" instead");
+                }
+            } else if (MemberType.ROLE.equals(memberType)) {
+                // If the member is another role, ensure that the role exists, does not conflict with any existing role ID information, and is not the member's role.
+                NameAndNamespacePair roleNameAndNamespace = newRoleMember.getRoleNameAsMember();
+                RoleContract tempRole = KimApiServiceLocator.getRoleService().getRoleByNameAndNamespaceCode(
+                        roleNameAndNamespace.getNamespaceCode(), roleNameAndNamespace.getName());
+                if (tempRole == null) {
+                    throw new UnmarshalException("Cannot use role with namespace \"" + roleNameAndNamespace.getNamespaceCode() +
+                            "\" and name \"" + roleNameAndNamespace.getName() + "\" as a role member because such a role does not exist");
+                } else if (newRoleMember.getRoleId().equals(tempRole.getId())) {
+                    throw new UnmarshalException("The role with namespace \"" + roleNameAndNamespace.getNamespaceCode() +
+                            "\" and name \"" + roleNameAndNamespace.getName() + "\" cannot be made a member of itself");
+                } else if (StringUtils.isBlank(newRoleMember.getRoleId())) {
+                    // If no role ID was given, assign one from the retrieved role.
+                    newRoleMember.setRoleIdAsMember(tempRole.getId());
+                } else if (!newRoleMember.getRoleId().equals(tempRole.getId())) {
+                    throw new RuntimeException("Cannot use role with ID \"" + newRoleMember.getRoleId() + "\", namespace \"" +
+                            roleNameAndNamespace.getNamespaceCode() + "\", and name \"" + roleNameAndNamespace.getName() +
+                                    "\" as a role member because the role with that namespace and name has an ID of \"" +
+                                            tempRole.getId() + "\" instead");
+                }
+            }
+        }
+        
+        // Ensure that a member ID was either explicitly defined or was derived from the member name (and namespace, if applicable).
+        if (StringUtils.isBlank(newRoleMember.getMemberId())) {
+            throw new RuntimeException("Cannot create a role member with no member principal/group/role identification information specified");
+        }
+        
+    }
+    
+    /**
+     * Validates a role permission's role and permission identification information, and assigns its role ID if needed.
+     */
+    private static void validateAndPrepareRolePermission(RolePermissionXmlDTO newRolePermission) throws UnmarshalException {
+        
+        // If this is a standalone role permission, derive and validate its role information accordingly.
+        if (newRolePermission instanceof RolePermissionXmlDTO.OutsideOfRole) {
+            RolePermissionXmlDTO.OutsideOfRole standaloneRolePerm = (RolePermissionXmlDTO.OutsideOfRole) newRolePermission;
+            if (standaloneRolePerm.getRoleNameAndNamespace() != null) {
+                // If a role name + namespace is given, assign or validate the role ID accordingly.
+                String tempRoleId = KimApiServiceLocator.getRoleService().getRoleIdByNameAndNamespaceCode(
+                        standaloneRolePerm.getRoleNamespaceCode(), standaloneRolePerm.getRoleName());
+                if (StringUtils.isBlank(tempRoleId)) {
+                    throw new UnmarshalException("Cannot assign permission to role with namespace \"" + standaloneRolePerm.getRoleNamespaceCode() +
+                            "\" and name \"" + standaloneRolePerm.getRoleName() + "\" because that role does not exist");
+                } else if (StringUtils.isBlank(standaloneRolePerm.getRoleId())) {
+                    // If no role ID was given, assign one from the retrieved role.
+                    standaloneRolePerm.setRoleId(standaloneRolePerm.getRoleId());
+                } else if (!standaloneRolePerm.getRoleId().equals(tempRoleId)) {
+                    throw new UnmarshalException("Cannot assign permission to role with ID \"" + standaloneRolePerm.getRoleId() + "\", namespace \"" +
+                            standaloneRolePerm.getRoleNamespaceCode() + "\", and name \"" + standaloneRolePerm.getRoleName() +
+                                    "\" because the existing role with that name and namespace has an ID of \"" + tempRoleId + "\" instead");
+                }
+            } else if (StringUtils.isBlank(standaloneRolePerm.getRoleId())) {
+                throw new UnmarshalException(
+                        "Cannot assign permission to role without providing the role ID or role name + namespace that the permission is assigned to");
+            } else if (KimApiServiceLocator.getRoleService().getRole(standaloneRolePerm.getRoleId()) == null) {
+                throw new UnmarshalException("Cannot assign permission to role with ID \"" + standaloneRolePerm.getRoleId() +
+                        "\" because that role does not exist");
+            }
+        }
+        
+        // Ensure that a role ID was explicitly defined or was derived from a name + namespace combo.
+        if (StringUtils.isBlank(newRolePermission.getRoleId())) {
+            throw new UnmarshalException("Cannot assign permission to role without providing the role ID or role name + namespace that the permission is assigned to");
+        }
+        
+        // If the permission is being identified by name and namespace, derive or validate its permission ID accordingly.
+        if (newRolePermission.getPermissionNameAndNamespace() != null) {
+            PermissionContract permission = KimApiServiceLocator.getPermissionService().findPermByNamespaceCodeAndName(
+                    newRolePermission.getPermissionNamespaceCode(), newRolePermission.getPermissionName());
+            if (permission == null) {
+                throw new UnmarshalException("Cannot get role assigned to permission with namespace \"" + newRolePermission.getPermissionNamespaceCode() +
+                        "\" and name \"" + newRolePermission.getPermissionName() + "\" because that permission does not exist");
+            } else if (StringUtils.isBlank(newRolePermission.getPermissionId())) {
+                // If no permission ID was given, assign one from the retrieved permission.
+                newRolePermission.setPermissionId(permission.getId());
+            } else if (!newRolePermission.getPermissionId().equals(permission.getId())) {
+                throw new UnmarshalException("Cannot get role assigned to permission with ID \"" + newRolePermission.getPermissionId() + "\", namespace \"" +
+                        newRolePermission.getPermissionNamespaceCode() + "\", and name \"" + newRolePermission.getPermissionName() +
+                                "\" because the existing permission with that name and namespace has an ID of \"" + permission.getId() + "\" instead");
+            }
+        } else if (StringUtils.isBlank(newRolePermission.getPermissionId())) {
+            throw new UnmarshalException("Cannot assign permission to role without specifying the ID or name and namespace of the permission to assign");
+        } else if (KimApiServiceLocator.getPermissionService().getPermission(newRolePermission.getPermissionId()) == null) {
+            throw new UnmarshalException("Cannot get role assigned to permission with ID \"" + newRolePermission.getPermissionId() +
+                    "\" because that permission does not exist");
+        }
+    }
+    
+}
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlUtil.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java	(revision 32237)
@@ -0,0 +1,512 @@
+/**
+ * Copyright 2005-2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.jacorb.idl.Member;
+import org.joda.time.DateTime;
+import org.kuali.rice.core.api.membership.MemberType;
+import org.kuali.rice.core.api.util.jaxb.DateTimeAdapter;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.kim.api.KimConstants.KimUIConstants;
+import org.kuali.rice.kim.api.group.GroupContract;
+import org.kuali.rice.kim.api.identity.principal.PrincipalContract;
+import org.kuali.rice.kim.api.jaxb.QualificationListAdapter;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.kim.api.role.RoleMember;
+import org.kuali.rice.kim.api.role.RoleMemberContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Base class representing an unmarshalled &lt;roleMember&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RoleMemberXmlDTO implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    @XmlElement(name="principalId")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String principalId;
+    
+    @XmlElement(name="principalName")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String principalName;
+    
+    @XmlElement(name="groupId")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String groupId;
+    
+    @XmlElement(name="groupName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair groupName;
+    
+    @XmlElement(name="roleIdAsMember")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String roleIdAsMember;
+    
+    @XmlElement(name="roleNameAsMember")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair roleNameAsMember;
+    
+    @XmlElement(name="activeFromDate")
+    @XmlJavaTypeAdapter(DateTimeAdapter.class)
+    private DateTime activeFromDate;
+    
+    @XmlElement(name="activeToDate")
+    @XmlJavaTypeAdapter(DateTimeAdapter.class)
+    private DateTime activeToDate;
+    
+    @XmlElement(name="qualifications")
+    @XmlJavaTypeAdapter(QualificationListAdapter.class)
+    private Map<String, String> qualifications;
+    
+    @XmlTransient
+    private MemberType memberType;
+    
+    /**
+     * Constructs an empty RoleMemberXmlDTO instance.
+     */
+    public RoleMemberXmlDTO() {}
+    
+    /**
+     * Constructs a RoleMemberXmlDTO instance that is populated with the info from the given role member.
+     * 
+     * @param roleMember The role member that this DTO should populate its data from.
+     * @param populateMemberId If true, the member principal/group/role ID will get populated; otherwise, only
+     * the member principal/group/role name and (if applicable) namespace will get populated.
+     * @throws IllegalArgumentException if roleMember is null, has an invalid member type, or refers to a nonexistent principal/group/role.
+     */
+    public RoleMemberXmlDTO(RoleMember roleMember, boolean populateMemberId) {
+        if (roleMember == null) {
+            throw new IllegalArgumentException("roleMember cannot be null");
+        }
+        this.memberType = roleMember.getMemberType();
+        this.activeFromDate = roleMember.getActiveFromDate();
+        this.activeToDate = roleMember.getActiveToDate();
+        this.qualifications = (roleMember.getAttributes() != null) ? roleMember.getAttributes() : new HashMap<String, String>();
+        
+        if (MemberType.PRINCIPAL.equals(memberType)) {
+            if (populateMemberId) {
+                this.principalId = roleMember.getMemberId();
+            }
+            PrincipalContract principal = KimApiServiceLocator.getIdentityService().getPrincipal(
+                    roleMember.getMemberId());
+            if (principal == null) {
+                throw new IllegalArgumentException("Cannot find principal with ID \"" +  roleMember.getMemberId() + "\"");
+            }
+            this.principalName = principal.getPrincipalName();
+        } else if (MemberType.GROUP.equals(memberType)) {
+            if (populateMemberId) {
+                this.groupId = roleMember.getMemberId();
+            }
+            GroupContract group = KimApiServiceLocator.getGroupService().getGroup(roleMember.getMemberId());
+            if (group == null) {
+                throw new IllegalArgumentException("Cannot find group with ID \"" + roleMember.getMemberId() + "\"");
+            }
+            this.groupName = new NameAndNamespacePair(group.getNamespaceCode(), group.getName());
+        } else if (MemberType.ROLE.equals(memberType)) {
+            if (populateMemberId) {
+                this.roleIdAsMember = roleMember.getMemberId();
+            }
+            RoleContract role = KimApiServiceLocator.getRoleService().getRole(roleMember.getMemberId());
+            if (role == null) {
+                throw new IllegalArgumentException("Cannot find role with ID \"" + roleMember.getMemberId() + "\"");
+            }
+            this.roleNameAsMember = new NameAndNamespacePair(role.getNamespaceCode(), role.getName());
+        } else {
+            throw new IllegalArgumentException("Cannot construct a RoleMemberXmlDTO from a role member with an unrecognized member type code of \"" +
+                    memberType + "\"");
+        }    
+    }
+
+    /**
+     * @return the principalId
+     */
+    public String getPrincipalId() {
+        return this.principalId;
+    }
+
+    /**
+     * @param principalId the principalId to set
+     */
+    public void setPrincipalId(String principalId) {
+        this.principalId = principalId;
+    }
+
+    /**
+     * @return the principalName
+     */
+    public String getPrincipalName() {
+        return this.principalName;
+    }
+
+    /**
+     * @param principalName the principalName to set
+     */
+    public void setPrincipalName(String principalName) {
+        this.principalName = principalName;
+    }
+
+    /**
+     * @return the groupId
+     */
+    public String getGroupId() {
+        return this.groupId;
+    }
+
+    /**
+     * @param groupId the groupId to set
+     */
+    public void setGroupId(String groupId) {
+        this.groupId = groupId;
+    }
+
+    /**
+     * @return the groupName
+     */
+    public NameAndNamespacePair getGroupName() {
+        return this.groupName;
+    }
+
+    /**
+     * @param groupName the groupName to set
+     */
+    public void setGroupName(NameAndNamespacePair groupName) {
+        this.groupName = groupName;
+    }
+
+    /**
+     * @return the roleIdAsMember
+     */
+    public String getRoleIdAsMember() {
+        return this.roleIdAsMember;
+    }
+
+    /**
+     * @param roleIdAsMember the roleIdAsMember to set
+     */
+    public void setRoleIdAsMember(String roleIdAsMember) {
+        this.roleIdAsMember = roleIdAsMember;
+    }
+
+    /**
+     * @return the roleNameAsMember
+     */
+    public NameAndNamespacePair getRoleNameAsMember() {
+        return this.roleNameAsMember;
+    }
+
+    /**
+     * @param roleNameAsMember the roleNameAsMember to set
+     */
+    public void setRoleNameAsMember(NameAndNamespacePair roleNameAsMember) {
+        this.roleNameAsMember = roleNameAsMember;
+    }
+
+    /**
+     * @return the activeFromDate
+     */
+    public DateTime getActiveFromDate() {
+        return this.activeFromDate;
+    }
+
+    /**
+     * @param activeFromDate the activeFromDate to set
+     */
+    public void setActiveFromDate(DateTime activeFromDate) {
+        this.activeFromDate = activeFromDate;
+    }
+
+    /**
+     * @return the activeToDate
+     */
+    public DateTime getActiveToDate() {
+        return this.activeToDate;
+    }
+
+    /**
+     * @param activeToDate the activeToDate to set
+     */
+    public void setActiveToDate(DateTime activeToDate) {
+        this.activeToDate = activeToDate;
+    }
+
+    /**
+     * @return the qualifications
+     */
+    public Map<String, String> getQualifications() {
+        return this.qualifications;
+    }
+
+    /**
+     * @param qualifications the qualifications to set
+     */
+    public void setQualifications(Map<String, String> qualifications) {
+        this.qualifications = qualifications;
+    }
+
+    /**
+     * Retrieves the member type.
+     * 
+     * <p>If the member type is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return the member type, or null if no membership identification information has been set on this member.
+     * @throws IllegalStateException if the role member is populated simultaneously with multiple member ID/name information
+     */
+    public MemberType getMemberType() {
+        if (memberType == null) {
+            boolean foundMemberInfo = false;
+            
+            if (StringUtils.isNotBlank(principalId) || StringUtils.isNotBlank(principalName)) {
+                memberType = MemberType.PRINCIPAL;
+                foundMemberInfo = true;
+            }
+            
+            if (StringUtils.isNotBlank(groupId) || groupName != null) {
+                if (foundMemberInfo) {
+                    memberType = null;
+                    throw new IllegalStateException("Cannot have a role member that is simultaneously populated with member principal, member group, and/or member role information");
+                }
+                memberType = MemberType.GROUP;
+                foundMemberInfo = true;
+            }
+            
+            if (StringUtils.isNotBlank(roleIdAsMember) || roleNameAsMember != null) {
+                if (foundMemberInfo) {
+                    memberType = null;
+                    throw new IllegalStateException("Cannot have a role member that is simultaneously populated with member principal, member group, and/or member role information");
+                }
+                memberType = MemberType.ROLE;
+                foundMemberInfo = true;
+            }
+        }
+        return this.memberType;
+    }
+
+    /**
+     * Retrieves the role member's ID, based on the member type and any populated member principal/group/role IDs.
+     * 
+     * <p>If the member type is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return The member's ID, or null if the member type is null or the associated member ID information is null.
+     */
+    public String getMemberId() {
+        if (MemberType.PRINCIPAL.equals(getMemberType())) {
+            return principalId;
+        } else if (MemberType.GROUP.equals(getMemberType())) {
+            return groupId;
+        } else if (MemberType.ROLE.equals(getMemberType())) {
+            return roleIdAsMember;
+        }
+        return null;
+    }
+    
+    /**
+     * Retrieves the role member's name, based on the member type and any populated member principal/group/role names.
+     * 
+     * <p>If the member type is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return The member's name, or null if the member type is null or the associated member name information is null.
+     */
+    public String getMemberName() {
+        if (MemberType.PRINCIPAL.equals(getMemberType())) {
+            return principalName;
+        } else if (MemberType.GROUP.equals(getMemberType())) {
+            return (groupName != null) ? groupName.getName() : null;
+        } else if (MemberType.ROLE.equals(getMemberType())) {
+            return (roleNameAsMember != null) ? roleNameAsMember.getName() : null;
+        }
+        return null;
+    }
+    
+    /**
+     * Retrieves the role member's namespace code, based on the member type and any populated member principal/group/role names.
+     * 
+     * <p>If the member type is null at the time that this method is invoked, an attempt will be made to set its
+     * value based on any populated member principal/group/role ID/name information.
+     * 
+     * @return The member's namespace code, or null if the member type is null, the associated member name information is null,
+     * or the role member is a principal.
+     */
+    public String getMemberNamespaceCode() {
+        if (MemberType.PRINCIPAL.equals(getMemberType())) {
+            return null;
+        } else if (MemberType.GROUP.equals(getMemberType())) {
+            return (groupName != null) ? groupName.getName() : null;
+        } else if (MemberType.ROLE.equals(getMemberType())) {
+            return (roleNameAsMember != null) ? roleNameAsMember.getName() : null;
+        }
+        return null;
+    }
+    
+    /**
+     * Retrieves the ID of the role that this member belongs to.
+     * Subclasses are responsible for implementing this method so that it does so.
+     * 
+     * @return The role ID of the role that this member belongs to.
+     */
+    public abstract String getRoleId();
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMember&gt; element that is not a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRoleMemberType", propOrder={
+            "roleId", "roleNameAndNamespace", "principalId", "principalName", "groupId", "groupName", "roleIdAsMember",
+                    "roleNameAsMember", "activeFromDate", "activeToDate", "qualifications"
+    })
+    public static class OutsideOfRole extends RoleMemberXmlDTO {
+
+        private static final long serialVersionUID = 1L;
+
+        @XmlElement(name="roleId")
+        @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+        private String roleId;
+
+        @XmlElement(name="roleName")
+        @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+        private NameAndNamespacePair roleNameAndNamespace;
+        
+        public OutsideOfRole() {
+            super();
+        }
+        
+        public OutsideOfRole(RoleMember roleMember, boolean populateMemberId) {
+            super(roleMember, populateMemberId);
+            this.roleId = roleMember.getRoleId();
+            RoleContract tempRole = KimApiServiceLocator.getRoleService().getRole(roleId);
+            if (tempRole == null) {
+                throw new IllegalArgumentException("Cannot find role with ID \"" + roleId + "\"");
+            }
+            this.roleNameAndNamespace = new NameAndNamespacePair(tempRole.getNamespaceCode(), tempRole.getName());
+        }
+        
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return roleId;
+        }
+
+        /**
+         * @param roleId the roleId to set
+         */
+        public void setRoleId(String roleId) {
+            this.roleId = roleId;
+        }
+        
+        /**
+         * @return the roleNameAndNamespace
+         */
+        public NameAndNamespacePair getRoleNameAndNamespace() {
+            return this.roleNameAndNamespace;
+        }
+
+        /**
+         * @param roleNameAndNamespace the roleNameAndNamespace to set
+         */
+        public void setRoleNameAndNamespace(NameAndNamespacePair roleNameAndNamespace) {
+            this.roleNameAndNamespace = roleNameAndNamespace;
+        }
+
+        /**
+         * Retrieves the role name from the role-name-and-namespace combo.
+         * 
+         * @return The name of the role that this member belongs to, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleName() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getName() : null;
+        }
+
+        /**
+         * Retrieves the role namespace code from the role-name-and-namespace combo.
+         * 
+         * @return The namespace code of the role that this member belongs to, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleNamespaceCode() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getNamespaceCode() : null;
+        }
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMember&gt; element that is a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RoleMemberType", propOrder={
+            "principalId", "principalName", "groupId", "groupName", "roleIdAsMember",
+                    "roleNameAsMember", "activeFromDate", "activeToDate", "qualifications"
+    })
+    public static class WithinRole extends RoleMemberXmlDTO {
+
+        private static final long serialVersionUID = 1L;
+        
+        @XmlTransient
+        private String roleId;
+
+        public WithinRole() {
+            super();
+        }
+        
+        public WithinRole(RoleMember roleMember, boolean populateMemberId) {
+            super(roleMember, populateMemberId);
+            this.roleId = roleMember.getRoleId();
+        }
+        
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+            if (parent instanceof RoleMembersXmlDTO.WithinRole) {
+                this.roleId = ((RoleMembersXmlDTO.WithinRole)parent).getRoleId();
+            }
+        }
+        
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return roleId;
+        }
+        
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleMemberXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java	(revision 32237)
@@ -0,0 +1,257 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+
+/**
+ * Base class representing an unmarshalled &lt;rolePermission&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RolePermissionXmlDTO implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="permissionId")
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String permissionId;
+    
+    @XmlElement(name="permissionName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair permissionNameAndNamespace;
+
+    /**
+     * Constructs an empty RolePermissionXmlDTO instance.
+     */
+    public RolePermissionXmlDTO() {}
+    
+    /**
+     * Constructs a RolePermissionXmlDTO that gets populated from the given KIM permission.
+     * 
+     * @param permission The permission that this DTO should obtain its data from.
+     * @param populateIds If true, the permission ID will get populated; otherwise, it will remain null.
+     */
+    public RolePermissionXmlDTO(PermissionContract permission, boolean populateIds) {
+        if (permission == null) {
+            throw new IllegalArgumentException("Cannot construct a role permission with a null permission");
+        }
+        if (populateIds) {
+            this.permissionId = permission.getId();
+        }
+        this.permissionNameAndNamespace = new NameAndNamespacePair(permission.getNamespaceCode(), permission.getName());
+    }
+
+    /**
+     * @return the permissionId
+     */
+    public String getPermissionId() {
+        return this.permissionId;
+    }
+
+    /**
+     * @param permissionId the permissionId to set
+     */
+    public void setPermissionId(String permissionId) {
+        this.permissionId = permissionId;
+    }
+
+    /**
+     * @return the permissionNameAndNamespace
+     */
+    public NameAndNamespacePair getPermissionNameAndNamespace() {
+        return this.permissionNameAndNamespace;
+    }
+
+    /**
+     * @param permissionNameAndNamespace the permissionNameAndNamespace to set
+     */
+    public void setPermissionNameAndNamespace(NameAndNamespacePair permissionNameAndNamespace) {
+        this.permissionNameAndNamespace = permissionNameAndNamespace;
+    }
+
+    /**
+     * Retrieves the permission name from the permission-name-and-namespace combo.
+     * 
+     * @return The name of the permission assigned to the role, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getPermissionName() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getName() : null;
+    }
+
+    /**
+     * Retrieves the permission namespace code from the permission-name-and-namespace combo.
+     * 
+     * @return The namespace code of the permission assigned to the role, or null if the permission-name-and-namespace combo is null.
+     */
+    public String getPermissionNamespaceCode() {
+        return (permissionNameAndNamespace != null) ? permissionNameAndNamespace.getNamespaceCode() : null;
+    }
+    
+    /**
+     * Retrieves the ID of the role that the permission is assigned to.
+     * Subclasses are responsible for implementing this method so that it does so.
+     * 
+     * @return The role ID of the role that the permission is assigned to.
+     */
+    public abstract String getRoleId();
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermission&gt; element that is not a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRolePermissionType", propOrder={
+            "roleId", "roleNameAndNamespace", "permissionId", "permissionNameAndNamespace"
+    })
+    public static class OutsideOfRole extends RolePermissionXmlDTO {
+        
+        private static final long serialVersionUID = 1L;
+
+        @XmlElement(name="roleId")
+        @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+        private String roleId;
+        
+        @XmlElement(name="roleName")
+        @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+        private NameAndNamespacePair roleNameAndNamespace;
+        
+        public OutsideOfRole() {
+            super();
+        }
+        
+        public OutsideOfRole(PermissionContract permission, String roleId, boolean populateIds) {
+            super(permission, populateIds);
+            if (populateIds) {
+                this.roleId = roleId;
+            }
+            RoleContract tempRole = KimApiServiceLocator.getRoleService().getRole(roleId);
+            if (tempRole == null) {
+                throw new IllegalArgumentException("Cannot find role with ID \"" + roleId + "\"");
+            }
+            this.roleNameAndNamespace = new NameAndNamespacePair(tempRole.getNamespaceCode(), tempRole.getName());
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RolePermissionXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return this.roleId;
+        }
+
+        /**
+         * @param roleId the roleId to set
+         */
+        public void setRoleId(String roleId) {
+            this.roleId = roleId;
+        }
+
+        /**
+         * @return the roleNameAndNamespace
+         */
+        public NameAndNamespacePair getRoleNameAndNamespace() {
+            return this.roleNameAndNamespace;
+        }
+
+        /**
+         * @param roleNameAndNamespace the roleNameAndNamespace to set
+         */
+        public void setRoleNameAndNamespace(NameAndNamespacePair roleNameAndNamespace) {
+            this.roleNameAndNamespace = roleNameAndNamespace;
+        }
+        
+        /**
+         * Retrieves the role name from the role-name-and-namespace combo.
+         * 
+         * @return The name of the role that is assigned to the permission, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleName() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getName() : null;
+        }
+
+        /**
+         * Retrieves the role namespace code from the role-name-and-namespace combo.
+         * 
+         * @return The namespace code of the role that is assigned to the permission, or null if the role-name-and-namespace combo is null.
+         */
+        public String getRoleNamespaceCode() {
+            return (roleNameAndNamespace != null) ? roleNameAndNamespace.getNamespaceCode() : null;
+        }
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermission&gt; element that is a descendant of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RolePermissionType", propOrder={
+            "permissionId", "permissionNameAndNamespace"
+    })
+    public static class WithinRole extends RolePermissionXmlDTO {
+        
+        private static final long serialVersionUID = 1L;
+        
+        @XmlTransient
+        private String roleId;
+        
+        public WithinRole() {
+            super();
+        }
+        
+        public WithinRole(PermissionContract permission, boolean populateIds) {
+            super(permission, populateIds);
+        }
+        
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+            if (parent instanceof RolePermissionsXmlDTO) {
+                this.roleId = ((RolePermissionXmlDTO)parent).getRoleId();
+            }
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RolePermissionXmlDTO#getRoleId()
+         */
+        @Override
+        public String getRoleId() {
+            return this.roleId;
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java	(revision 32237)
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.List;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+
+/**
+ * This class represents a &lt;permissions&gt; element. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionsType", propOrder={"permissions"})
+public class PermissionsXmlDTO implements RiceXmlListAdditionListener<PermissionXmlDTO>,
+        RiceXmlListGetterListener<PermissionXmlDTO,Object>, Serializable {
+    
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="permission")
+    private List<PermissionXmlDTO> permissions;
+    
+    public PermissionsXmlDTO() {}
+    
+    public PermissionsXmlDTO(List<? extends Object> permissionsToExport) {
+        this.permissions = new RiceXmlExportList<PermissionXmlDTO,Object>(permissionsToExport, this);
+    }
+    
+    /**
+     * @return the permissions
+     */
+    public List<PermissionXmlDTO> getPermissions() {
+        return this.permissions;
+    }
+
+    /**
+     * @param permissions the permissions to set
+     */
+    public void setPermissions(List<PermissionXmlDTO> permissions) {
+        this.permissions = permissions;
+    }
+
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        permissions = new RiceXmlImportList<PermissionXmlDTO>(this);
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        permissions = null;
+    }
+    
+    public void newItemAdded(PermissionXmlDTO item) {
+        try {
+            PermissionXmlUtil.validateAndPersistNewPermission(item);
+        } catch (UnmarshalException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    void afterMarshal(Marshaller marshaller) {
+        permissions = null;
+    }
+    
+    public PermissionXmlDTO gettingNextItem(Object nextItem, int index) {
+        if (!(nextItem instanceof PermissionContract)) {
+            throw new IllegalStateException("Object for exportation should have been a permission");
+        }
+        return new PermissionXmlDTO((PermissionContract) nextItem);
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionsXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java	(revision 32237)
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+/**
+ * This class represents a &lt;roleData&gt; element.
+ * 
+ * <p>The expected XML structure is as follows:
+ * 
+ * <br>
+ * <br>&lt;roleData&gt;
+ * <br>&nbsp;&nbsp;&lt;roles&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;role&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleName namespaceCode=""&gt;&lt;/roleName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;kimTypeName namespaceCode=""&gt;&lt;/kimTypeName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;&lt;/description&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;active&gt;&lt;/active&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleMembers&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalId&gt;&lt;/principalId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalName&gt;&lt;/principalName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;&lt;/groupId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupName namespaceCode=""&gt;&lt;/groupName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleIdAsMember&gt;&lt;/roleIdAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleNameAsMember namespaceCode=""&gt;&lt;/roleNameAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeFromDate&gt;&lt;/activeFromDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeToDate&gt;&lt;/activeToDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualification key=""&gt;&lt;/qualification&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/roleMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/roleMembers&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rolePermissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rolePermission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionId&gt;&lt;/permissionId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionName namespaceCode=""&gt;&lt;/permissionName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rolePermission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rolePermissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/role&gt;
+ * <br>&nbsp;&nbsp;&lt;/roles&gt;
+ * <br>&nbsp;&nbsp;&lt;roleMembers&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleId&gt;&lt;/roleId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleName namespaceCode=""&gt;&lt;/roleName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalId&gt;&lt;/principalId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;principalName&gt;&lt;/principalName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;&lt;/groupId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupName namespaceCode=""&gt;&lt;/groupName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleIdAsMember&gt;&lt;/roleIdAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleNameAsMember namespaceCode=""&gt;&lt;/roleNameAsMember&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeFromDate&gt;&lt;/activeFromDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;activeToDate&gt;&lt;/activeToDate&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;qualification key=""&gt;&lt;/qualification&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/qualifications&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/roleMember&gt;
+ * <br>&nbsp;&nbsp;&lt;/roleMembers&gt;
+ * <br>&nbsp;&nbsp;&lt;rolePermissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;rolePermission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleId&gt;&lt;/roleId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;roleName namespaceCode=""&gt;&lt;/roleName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionId&gt;&lt;/permissionId&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionName namespaceCode=""&gt;&lt;/permissionName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rolePermission&gt;
+ * <br>&nbsp;&nbsp;&lt;/rolePermissions&gt;
+ * <br>&lt;/roleData&gt;
+ * 
+ * <p>Note the following:
+ * <ul>
+ *   <li>The &lt;roles&gt; element is optional, and can contain zero or more &lt;role&gt; elements.
+ *   <li>The &lt;roleName&gt; element on the &lt;role&gt; element and its "namespaceCode" attribute
+ *   are required, and must be non-blank. The namespace code must map to a valid namespace.
+ *   If the name and namespace combo matches an existing role, then the role in the XML will
+ *   overwrite the existing role.
+ *   <li>The &lt;kimTypeName&gt; and its "namespaceCode" attribute are both required, and the
+ *   name and namespace combo must match an existing KIM type.
+ *   <li>The &lt;description&gt; element is required, and must be non-blank.
+ *   <li>The &lt;active&gt; element is optional, and will be set to true if not specified.
+ *   <li>Both &lt;roleMembers&gt; elements are optional, and can contain zero or more
+ *   &lt;roleMember&gt; elements. If the &lt;roleMembers&gt; element within the &lt;role&gt;
+ *   element is specified, then any role members that are not within that element will be removed
+ *   from the role if the XML is overwriting an existing one. (The &lt;roleMembers&gt; element
+ *   outside of the &lt;role&gt; element can still add or re-add members that are not located
+ *   within the other &lt;roleMembers&gt; element.)
+ *   <li>For both &lt;roleMember&gt; elements:
+ *     <ul>
+ *       <li>Exactly one of these sets of member identification must be specified:
+ *         <ol>
+ *           <li>A &lt;principalId&gt; and/or &lt;principalName&gt; element, where the former
+ *           must contain a valid principal ID and the latter must contain a valid principal name.
+ *           <li>A &lt;groupId&gt; and/or &lt;groupName&gt; element, where the former must contain
+ *           a valid group ID and the latter must contain a valid group name and namespace.
+ *           <li>A &lt;roleIdAsMember&gt; and/or &lt;roleNameAsMember&gt; element, where the former
+ *           must contain a valid role ID and the latter must contain a valid role name and namespace.
+ *         </ol>
+ *       <li>The &lt;activeFromDate&gt; element is optional, and its content must be a date String
+ *       that can be parsed by the DateTimeService.
+ *       <li>The &lt;activeToDate&gt; element is optional, and its content must be a date String
+ *       that can be parsed by the DateTimeService.
+ *       <li>The &lt;qualifications&gt; element is optional, and can contain zero or more
+ *       &lt;qualification&gt; elements.
+ *       <li>The &lt;qualification&gt; element's "key" attribute is required, and must be non-blank.
+ *       Duplicate keys within a &lt;qualifications&gt; element are not permitted.
+ *     </ul>
+ *   <li>For both &lt;rolePermission&gt; elements:
+ *     <ul>
+ *       <li>A &lt;permissionId&gt; and/or &lt;permissionName&gt; element must be specified, where the
+ *       former must contain a valid permission ID and the latter must contain a valid permission
+ *       name and namespace.
+ *     </ul>
+ *   <li>For the &lt;roleMember&gt; and &lt;rolePermission&gt; elements not inside a &lt;role&gt; element:
+ *     <ul>
+ *       <li>A &lt;roleId&gt; and/or &lt;roleName&gt; element must be specified, where the former must
+ *       contain a valid role ID and the latter must contain a valid role name and namespace.
+ *     </ul>
+ *   <li>The ingestion process is currently order-dependent, which should be kept in mind when adding
+ *   roles as members of another role or assigning permissions to roles. (The permission XML always
+ *   gets ingested prior to the role XML.)
+ *   <li>The assignments of permissions to roles can only be added, not removed or deactivated.
+ *   (TODO: Improve the role/permission-updating API to allow for updates and removals.)
+ *   <li>The same roles, role members, and role permissions can be ingested within the same file,
+ *   where subsequent ones will overwrite previous ones. (TODO: Is this acceptable?)
+ *   <li>The IDs of principals, groups, roles, and permissions are not included when exporting the XML.
+ *   <li>Delegations and responsibility actions are currently not supported by the ingestion process.
+ * </ul>
+ * 
+ * TODO: Verify that the above behavior is correct.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="RoleDataType", propOrder={"roles", "roleMembers", "rolePermissions"})
+public class RoleDataXmlDTO implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    @XmlElement(name="roles")
+    private RolesXmlDTO roles;
+    
+    @XmlElement(name="roleMembers")
+    private RoleMembersXmlDTO.OutsideOfRole roleMembers;
+
+    @XmlElement(name="rolePermissions")
+    private RolePermissionsXmlDTO.OutsideOfRole rolePermissions;
+    
+    public RoleDataXmlDTO() {}
+    
+    public RoleDataXmlDTO(RolesXmlDTO roles) {
+        this.roles = roles;
+    }
+
+    /**
+     * @return the roles
+     */
+    public RolesXmlDTO getRoles() {
+        return this.roles;
+    }
+
+    /**
+     * @param roles the roles to set
+     */
+    public void setRoles(RolesXmlDTO roles) {
+        this.roles = roles;
+    }
+
+    /**
+     * @return the roleMembers
+     */
+    public RoleMembersXmlDTO.OutsideOfRole getRoleMembers() {
+        return this.roleMembers;
+    }
+
+    /**
+     * @param roleMembers the roleMembers to set
+     */
+    public void setRoleMembers(RoleMembersXmlDTO.OutsideOfRole roleMembers) {
+        this.roleMembers = roleMembers;
+    }
+
+    /**
+     * @return the rolePermissions
+     */
+    public RolePermissionsXmlDTO.OutsideOfRole getRolePermissions() {
+        return this.rolePermissions;
+    }
+
+    /**
+     * @param rolePermissions the rolePermissions to set
+     */
+    public void setRolePermissions(RolePermissionsXmlDTO.OutsideOfRole rolePermissions) {
+        this.rolePermissions = rolePermissions;
+    }
+        
+}
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleDataXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java	(revision 32237)
@@ -0,0 +1,239 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.api.criteria.QueryByCriteria;
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.role.RoleMember;
+import org.kuali.rice.kim.api.role.RoleMemberContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+import static org.kuali.rice.core.api.criteria.PredicateFactory.equal;
+
+/**
+ * Base class representing an unmarshalled &lt;roleMembers&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RoleMembersXmlDTO<T extends RoleMemberXmlDTO> implements RiceXmlListAdditionListener<T>, Serializable {
+
+    private static final long serialVersionUID = 1L;
+
+    public abstract List<T> getRoleMembers();
+    
+    public abstract void setRoleMembers(List<T> roleMembers);
+    
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRoleMembers(new RiceXmlImportList<T>(this));
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRoleMembers(null);
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMembers&gt; element that is not a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRoleMembersType", propOrder={"roleMembers"})
+    public static class OutsideOfRole extends RoleMembersXmlDTO<RoleMemberXmlDTO.OutsideOfRole> {
+
+        private static final long serialVersionUID = 1L;
+        
+        @XmlElement(name="roleMember")
+        private List<RoleMemberXmlDTO.OutsideOfRole> roleMembers;
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#getRoleMembers()
+         */
+        @Override
+        public List<RoleMemberXmlDTO.OutsideOfRole> getRoleMembers() {
+            return this.roleMembers;
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#setRoleMembers(java.util.List)
+         */
+        @Override
+        public void setRoleMembers(List<RoleMemberXmlDTO.OutsideOfRole> roleMembers) {
+            this.roleMembers = roleMembers;
+        }
+
+        /**
+         * @see org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener#newItemAdded(java.lang.Object)
+         */
+        @Override
+        public void newItemAdded(RoleMemberXmlDTO.OutsideOfRole item) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRoleMember(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;roleMembers&gt; element that is a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RoleMembersType", propOrder={"roleMembers"})
+    public static class WithinRole extends RoleMembersXmlDTO<RoleMemberXmlDTO.WithinRole>
+            implements RiceXmlListGetterListener<RoleMemberXmlDTO.WithinRole,String> {
+
+        private static final long serialVersionUID = 1L;
+        
+        @XmlElement(name="roleMember")
+        private List<RoleMemberXmlDTO.WithinRole> roleMembers;
+
+        @XmlTransient
+        private String roleId;
+        
+        @XmlTransient
+        private Set<String> existingRoleMemberIds;
+        
+        public WithinRole() {}
+        
+        public WithinRole(String roleId) {
+            this.roleId = roleId;
+        }
+        
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#getRoleMembers()
+         */
+        @Override
+        public List<org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO.WithinRole> getRoleMembers() {
+            return this.roleMembers;
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#setRoleMembers(java.util.List)
+         */
+        @Override
+        public void setRoleMembers(List<org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO.WithinRole> roleMembers) {
+            this.roleMembers = roleMembers;
+        }
+        
+        /**
+         * @return the roleId
+         */
+        public String getRoleId() {
+            return this.roleId;
+        }
+
+        /**
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#beforeUnmarshal(javax.xml.bind.Unmarshaller, java.lang.Object)
+         */
+        @Override
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+            if (parent instanceof RoleXmlDTO) {
+                // Obtain the role ID from the enclosing role, and persist the role if it has not been persisted yet.
+                RoleXmlDTO parentRole = (RoleXmlDTO) parent;
+                if (!parentRole.isAlreadyPersisted()) {
+                    RoleXmlUtil.validateAndPersistNewRole(parentRole);
+                }
+                roleId = parentRole.getRoleId();
+            }
+            existingRoleMemberIds = new HashSet<String>();
+            super.beforeUnmarshal(unmarshaller, parent);
+        }
+
+        /**
+         * This overridden method ...
+         * 
+         * @see org.kuali.rice.kim.impl.jaxb.RoleMembersXmlDTO#afterUnmarshal(javax.xml.bind.Unmarshaller, java.lang.Object)
+         */
+        @Override
+        void afterUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+            super.afterUnmarshal(unmarshaller, parent);
+            if (parent instanceof RoleXmlDTO) {
+                ((RoleXmlDTO)parent).setExistingRoleMemberIds(existingRoleMemberIds);
+            }
+            existingRoleMemberIds = null;
+        }
+
+        /**
+         * @see org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener#newItemAdded(java.lang.Object)
+         */
+        @Override
+        public void newItemAdded(org.kuali.rice.kim.impl.jaxb.RoleMemberXmlDTO.WithinRole item) {
+            // Persist the role member and add it to the set of role members that should not be removed from the role.
+            try {
+                existingRoleMemberIds.add(RoleXmlUtil.validateAndPersistNewRoleMember(item));
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+        void beforeMarshal(Marshaller marshaller) {
+            List<RoleMember> tempMembers = KimApiServiceLocator.getRoleService().findRoleMembers(
+                    QueryByCriteria.Builder.fromPredicates(equal("roleId", roleId))).getResults();
+            if (tempMembers != null && !tempMembers.isEmpty()) {
+                List<String> roleMemberIds = new ArrayList<String>();
+                
+                for (RoleMemberContract tempMember : tempMembers) {
+                    if (tempMember.isActive(null)) {
+                        roleMemberIds.add(tempMember.getRoleMemberId());
+                    }
+                }
+                
+                if (!roleMemberIds.isEmpty()) {
+                    setRoleMembers(new RiceXmlExportList<RoleMemberXmlDTO.WithinRole,String>(roleMemberIds, this));
+                }
+            }
+        }
+        
+        void afterMarshal(Marshaller marshaller) {
+            setRoleMembers(null);
+        }
+
+        /**
+         * @see org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener#gettingNextItem(java.lang.Object, int)
+         */
+        @Override
+        public RoleMemberXmlDTO.WithinRole gettingNextItem(String nextItem, int index) {
+            return new RoleMemberXmlDTO.WithinRole(KimApiServiceLocator.getRoleService().findRoleMembers(QueryByCriteria.Builder.fromPredicates(equal("roleMemberId", nextItem))).getResults().get(0), false);
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleMembersXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/package-info.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/package-info.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/package-info.java	(revision 32237)
@@ -0,0 +1,6 @@
+@javax.xml.bind.annotation.XmlSchema(namespace = KimApiConstants.Namespaces.KIM_NAMESPACE_2_0, elementFormDefault = XmlNsForm.QUALIFIED)
+package org.kuali.rice.kim.impl.jaxb;
+
+import javax.xml.bind.annotation.XmlNsForm;
+
+import org.kuali.rice.kim.api.KimApiConstants;
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/package-info.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java	(revision 32237)
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+/**
+ * Base class representing an unmarshalled &lt;rolePermissions&gt; element.
+ * Refer to the static inner classes for more information about the specific contexts.
+ * 
+ * TODO: Alter the role/permission service APIs so that finding all the permissions assigned to a role is possible; the
+ * current lack of such an API method prevents role permissions from being exported.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlTransient
+public abstract class RolePermissionsXmlDTO<T extends RolePermissionXmlDTO> implements RiceXmlListAdditionListener<T>, Serializable {
+    
+    private static final long serialVersionUID = 1L;
+
+    public abstract List<T> getRolePermissions();
+    
+    public abstract void setRolePermissions(List<T> rolePermissions);
+    
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRolePermissions(new RiceXmlImportList<T>(this));
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+        setRolePermissions(null);
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermissions&gt; element that is not a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="StandaloneRolePermissionsType", propOrder={"rolePermissions"})
+    public static class OutsideOfRole extends RolePermissionsXmlDTO<RolePermissionXmlDTO.OutsideOfRole> {
+        
+        private static final long serialVersionUID = 1L;
+        
+        @XmlElement(name="rolePermission")
+        private List<RolePermissionXmlDTO.OutsideOfRole> rolePermissions;
+        
+        public List<RolePermissionXmlDTO.OutsideOfRole> getRolePermissions() {
+            return rolePermissions;
+        }
+
+        public void setRolePermissions(List<RolePermissionXmlDTO.OutsideOfRole> rolePermissions) {
+            this.rolePermissions = rolePermissions;
+        }
+        
+        public void newItemAdded(RolePermissionXmlDTO.OutsideOfRole item) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRolePermission(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+    }
+    
+    // =======================================================================================================
+    
+    /**
+     * This class represents a &lt;rolePermissions&gt; element that is a child of a &lt;role&gt; element.
+     * 
+     * @author Kuali Rice Team (rice.collab@kuali.org)
+     */
+    @XmlAccessorType(XmlAccessType.FIELD)
+    @XmlType(name="RolePermissionsType", propOrder={"rolePermissions"})
+    public static class WithinRole extends RolePermissionsXmlDTO<RolePermissionXmlDTO.WithinRole>
+            implements RiceXmlListGetterListener<RolePermissionXmlDTO.WithinRole,String> {
+        
+        private static final long serialVersionUID = 1L;
+
+        @XmlElement(name="rolePermission")
+        private List<RolePermissionXmlDTO.WithinRole> rolePermissions;
+        
+        @XmlTransient
+        private String roleId;
+        
+        public WithinRole() {}
+        
+        public WithinRole(String roleId) {
+            this.roleId = roleId;
+        }
+        
+        public List<RolePermissionXmlDTO.WithinRole> getRolePermissions() {
+            return rolePermissions;
+        }
+
+        public void setRolePermissions(List<RolePermissionXmlDTO.WithinRole> rolePermissions) {
+            this.rolePermissions = rolePermissions;
+        }
+        
+        public String getRoleId() {
+            return roleId;
+        }
+        
+        @Override
+        void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) throws UnmarshalException {
+            if (parent instanceof RoleXmlDTO) {
+                // Obtain the role ID from the enclosing role, and persist the role if it has not been persisted yet.
+                RoleXmlDTO parentRole = (RoleXmlDTO) parent;
+                if (!parentRole.isAlreadyPersisted()) {
+                    RoleXmlUtil.validateAndPersistNewRole(parentRole);
+                }
+                roleId = parentRole.getRoleId();
+            }
+            super.beforeUnmarshal(unmarshaller, parent);
+        }
+        
+        public void newItemAdded(RolePermissionXmlDTO.WithinRole item) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRolePermission(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+        void beforeMarshal(Marshaller marshaller) {
+            // TODO: Use new API method once it becomes available!!!!
+            List<String> permissionIds = new ArrayList<String>();// KIMServiceLocator.getPermissionService().getRoleIdsForPermission(permissionId);
+            if (permissionIds != null && !permissionIds.isEmpty()) {
+                setRolePermissions(new RiceXmlExportList<RolePermissionXmlDTO.WithinRole,String>(permissionIds, this));
+            }
+        }
+        
+        void afterMarshal(Marshaller marshaller) {
+            setRolePermissions(null);
+        }
+
+        public RolePermissionXmlDTO.WithinRole gettingNextItem(String nextItem, int index) {
+            PermissionContract permission = KimApiServiceLocator.getPermissionService().getPermission(nextItem);
+            if (permission == null) {
+                throw new RuntimeException("Cannot find permission with ID \"" + nextItem + "\"");
+            }
+            return new RolePermissionXmlDTO.WithinRole(permission, false);
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RolePermissionsXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java	(revision 32237)
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import javax.xml.bind.UnmarshalException;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.api.permission.Permission;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+
+/**
+ * Helper class containing static methods for aiding in parsing parsing XML.
+ * 
+ * <p>All non-private methods are package-private so that only the KIM-parsing-related code can make use of them. (TODO: Is that necessary?)
+ * 
+ * <p>TODO: Should this be converted into a service instead?
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class PermissionXmlUtil {
+    // Do not allow outside code to instantiate this class.
+    private PermissionXmlUtil() {}
+    
+    /**
+     * Validates a new permission and then saves it.
+     * 
+     * @param newPermission
+     * @throws IllegalArgumentException if newPermission is null.
+     * @throws UnmarshalException if newPermission contains invalid data.
+     */
+    static void validateAndPersistNewPermission(PermissionXmlDTO newPermission) throws UnmarshalException {
+        if (newPermission == null) {
+            throw new IllegalArgumentException("Cannot persist a null permission");
+        }
+        
+        // Validate the new permission.
+        validatePermission(newPermission);
+        
+        // Save the permission.
+        Permission.Builder builder = Permission.Builder.create(newPermission.getNamespaceCode(), newPermission.getPermissionName());
+        builder.setDescription(newPermission.getPermissionDescription());
+        builder.setActive(newPermission.getActive().booleanValue());
+        builder.setAttributes(newPermission.getPermissionDetails());
+        
+        KimApiServiceLocator.getPermissionService().createPermission(builder.build());
+    }
+
+    /**
+     * Validates a permission to ensure that the required fields have been filled.
+     * 
+     * @throws UnmarshalException if newPermission contains invalid data.
+     */
+    private static void validatePermission(PermissionXmlDTO newPermission) throws UnmarshalException {
+        // Ensure that the permission name, namespace, template, and description have been filled in.
+        if (StringUtils.isBlank(newPermission.getPermissionName()) || StringUtils.isBlank(newPermission.getNamespaceCode())) {
+            throw new UnmarshalException("Cannot create a permission with a blank name or namespace");
+        } else if (StringUtils.isBlank(newPermission.getPermissionTemplateId())) {
+            throw new UnmarshalException("Cannot create a permission without specifying a permission template");
+        } else if (StringUtils.isBlank(newPermission.getPermissionDescription())) {
+            throw new UnmarshalException("Cannot create a permission with a blank description");
+        }
+        
+        // If another permission with that name and namespace exists, use its ID on the new permission.
+        PermissionContract permission = KimApiServiceLocator.getPermissionService().findPermByNamespaceCodeAndName(
+                newPermission.getNamespaceCode(), newPermission.getPermissionName());
+        if (permission != null) {
+            newPermission.setPermissionId(permission.getId());
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionXmlUtil.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java	(revision 32237)
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.Set;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlTransient;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePairValidatingAdapter;
+import org.kuali.rice.core.util.jaxb.StringTrimmingAdapter;
+import org.kuali.rice.kim.api.jaxb.NameAndNamespacePairToKimTypeIdAdapter;
+import org.kuali.rice.kim.api.role.RoleContract;
+
+/**
+ * This class represents a &lt;role&gt; XML element.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="RoleType", propOrder={
+        "roleNameAndNamespace", "kimTypeId", "roleDescription", "active", "roleMembers", "rolePermissions"
+})
+public class RoleXmlDTO implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+
+    @XmlTransient
+    private String roleId;
+    
+    @XmlElement(name="roleName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairValidatingAdapter.class)
+    private NameAndNamespacePair roleNameAndNamespace;
+    
+    @XmlElement(name="kimTypeName")
+    @XmlJavaTypeAdapter(NameAndNamespacePairToKimTypeIdAdapter.class)
+    private String kimTypeId;
+    
+    @XmlElement(name="description")
+    @XmlJavaTypeAdapter(StringTrimmingAdapter.class)
+    private String roleDescription;
+    
+    @XmlElement(name="active")
+    private Boolean active;
+    
+    @XmlElement(name="roleMembers")
+    private RoleMembersXmlDTO.WithinRole roleMembers;
+    
+    @XmlElement(name="rolePermissions")
+    private RolePermissionsXmlDTO.WithinRole rolePermissions;
+
+    @XmlTransient
+    private boolean alreadyPersisted = false;
+    
+    @XmlTransient
+    private Set<String> existingRoleMemberIds;
+    
+    public RoleXmlDTO() {
+        this.active = Boolean.TRUE;
+    }
+    
+    public RoleXmlDTO(RoleContract role, RoleMembersXmlDTO.WithinRole roleMembers, RolePermissionsXmlDTO.WithinRole rolePermissions) {
+        if (role == null) {
+            throw new IllegalArgumentException("role cannot be null");
+        }
+        
+        this.roleNameAndNamespace = new NameAndNamespacePair(role.getNamespaceCode(), role.getName());
+        this.kimTypeId = role.getKimTypeId();
+        this.roleDescription = role.getDescription();
+        this.active = Boolean.valueOf(role.isActive());
+        this.roleMembers = roleMembers;
+        this.rolePermissions = rolePermissions;
+    }
+
+    /**
+     * @return the roleId
+     */
+    public String getRoleId() {
+        return this.roleId;
+    }
+
+    /**
+     * @param roleId the roleId to set
+     */
+    public void setRoleId(String roleId) {
+        this.roleId = roleId;
+    }
+
+    /**
+     * @return the roleNameAndNamespace
+     */
+    public NameAndNamespacePair getRoleNameAndNamespace() {
+        return this.roleNameAndNamespace;
+    }
+
+    /**
+     * @param roleNameAndNamespace the roleNameAndNamespace to set
+     */
+    public void setRoleNameAndNamespace(NameAndNamespacePair roleNameAndNamespace) {
+        this.roleNameAndNamespace = roleNameAndNamespace;
+    }
+
+    /**
+     * @return the kimTypeId
+     */
+    public String getKimTypeId() {
+        return this.kimTypeId;
+    }
+
+    /**
+     * @param kimTypeId the kimTypeId to set
+     */
+    public void setKimTypeId(String kimTypeId) {
+        this.kimTypeId = kimTypeId;
+    }
+
+    /**
+     * @return the roleDescription
+     */
+    public String getRoleDescription() {
+        return this.roleDescription;
+    }
+
+    /**
+     * @param roleDescription the roleDescription to set
+     */
+    public void setRoleDescription(String roleDescription) {
+        this.roleDescription = roleDescription;
+    }
+
+    /**
+     * @return the active
+     */
+    public Boolean getActive() {
+        return this.active;
+    }
+
+    /**
+     * @param active the active to set
+     */
+    public void setActive(Boolean active) {
+        this.active = active;
+    }
+
+    /**
+     * @return the roleMembers
+     */
+    public RoleMembersXmlDTO.WithinRole getRoleMembers() {
+        return this.roleMembers;
+    }
+
+    /**
+     * @param roleMembers the roleMembers to set
+     */
+    public void setRoleMembers(RoleMembersXmlDTO.WithinRole roleMembers) {
+        this.roleMembers = roleMembers;
+    }
+
+    /**
+     * @return the rolePermissions
+     */
+    public RolePermissionsXmlDTO.WithinRole getRolePermissions() {
+        return this.rolePermissions;
+    }
+
+    /**
+     * @param rolePermissions the rolePermissions to set
+     */
+    public void setRolePermissions(RolePermissionsXmlDTO.WithinRole rolePermissions) {
+        this.rolePermissions = rolePermissions;
+    }
+
+    /**
+     * @return the alreadyPersisted
+     */
+    public boolean isAlreadyPersisted() {
+        return this.alreadyPersisted;
+    }
+
+    /**
+     * @param alreadyPersisted the alreadyPersisted to set
+     */
+    public void setAlreadyPersisted(boolean alreadyPersisted) {
+        this.alreadyPersisted = alreadyPersisted;
+    }
+    
+    /**
+     * @return the existingRoleMemberIds
+     */
+    public Set<String> getExistingRoleMemberIds() {
+        return this.existingRoleMemberIds;
+    }
+
+    /**
+     * @param existingRoleMemberIds the existingRoleMemberIds to set
+     */
+    public void setExistingRoleMemberIds(Set<String> existingRoleMemberIds) {
+        this.existingRoleMemberIds = existingRoleMemberIds;
+    }
+
+    /**
+     * Retrieves the role's name from the role-name-and-namespace combo.
+     * 
+     * @return The name of the role, or null if the role-name-and-namespace combo is null.
+     */
+    public String getRoleName() {
+        return (roleNameAndNamespace != null) ? roleNameAndNamespace.getName() : null;
+    }
+
+    /**
+     * Retrieves the role's namespace code from the role-name-and-namespace combo.
+     * 
+     * @return The namespace code of the role, or null if the role-name-and-namespace combo is null.
+     */
+    public String getNamespaceCode() {
+        return (roleNameAndNamespace != null) ? roleNameAndNamespace.getNamespaceCode() : null;
+    }
+}
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RoleXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java	(revision 32237)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+/**
+ * This class represents the &lt;permissionData&gt; element.
+ * 
+ * <p>The expected XML structure is as follows:
+ * 
+ * <br>
+ * <br>&lt;permissionData&gt;
+ * <br>&nbsp;&nbsp;&lt;permissions&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;permission&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionName namespaceCode=""&gt;&lt;/permissionName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;templateName namespaceCode=""&gt;&lt;/templateName&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;description&gt;&lt;/description&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;active&gt;&lt;/active&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionDetails&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;permissionDetail key=""&gt;&lt;/permissionDetail&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/permissionDetails&gt;
+ * <br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/permission&gt;
+ * <br>&nbsp;&nbsp;&lt;/permissions&gt;
+ * <br>&lt;/permissionData&gt;
+ * 
+ * <p>Note the following:
+ * <ul>
+ *   <li>The &lt;permissions&gt; element is optional, and can contain zero or more &lt;permission&gt; elements.
+ *   <li>The &lt;permissionName&gt; element and its "namespaceCode" attribute are both required.
+ *   The namespace code must map to a valid namespace.
+ *   If the name and namespace combo matches an existing permission, then the permission in the XML
+ *   will overwrite the existing permission.
+ *   <li>The &lt;templateName&gt; element and its "namespaceCode" attribute are both required.
+ *   The name and namespace combo on this element must match a valid permission template.
+ *   <li>The &lt;description&gt; element is required, and must be non-blank.
+ *   <li>The &lt;active&gt; element is optional, and will be set to true if not specified.
+ *   <li>The &lt;permissionDetails&gt; element is optional, and can contain zero or more
+ *   &lt;permissionDetail&gt; elements.
+ *   <li>The &lt;permissionDetail&gt; element's "key" attribute is required, and must be non-blank.
+ *   Duplicate keys within a &lt;permissionDetails&gt; element are not permitted.
+ *   <li>The same permission can be ingested multiple times in the same file, where subsequent ones will
+ *   overwrite previous ones. (TODO: Is this acceptable?)
+ * </ul>
+ * 
+ * TODO: Verify that the above behavior is correct.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionDataType", propOrder={"permissions"})
+public class PermissionDataXmlDTO {
+
+    @XmlElement(name="permissions")
+    private PermissionsXmlDTO permissions;
+    
+    public PermissionDataXmlDTO() {}
+    
+    public PermissionDataXmlDTO(PermissionsXmlDTO permissions) {
+        this.permissions = permissions;
+    }
+
+    /**
+     * @return the permissions
+     */
+    public PermissionsXmlDTO getPermissions() {
+        return this.permissions;
+    }
+
+    /**
+     * @param permissions the permissions to set
+     */
+    public void setPermissions(PermissionsXmlDTO permissions) {
+        this.permissions = permissions;
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/PermissionDataXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java	(revision 32237)
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.Serializable;
+import java.util.List;
+import java.util.Set;
+
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.util.jaxb.RiceXmlExportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlImportList;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener;
+import org.kuali.rice.kim.api.role.RoleContract;
+
+/**
+ * This class represents a &lt;roles&gt; element. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="RolesType", propOrder={"roles"})
+public class RolesXmlDTO implements RiceXmlListAdditionListener<RoleXmlDTO>, RiceXmlListGetterListener<RoleXmlDTO,Object>, Serializable {
+    
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="role")
+    private List<RoleXmlDTO> roles;
+    
+    public RolesXmlDTO() {}
+    
+    public RolesXmlDTO(List<? extends Object> rolesToExport) {
+        this.roles = new RiceXmlExportList<RoleXmlDTO,Object>(rolesToExport, this);
+    }
+    
+    public List<RoleXmlDTO> getRoles() {
+        return roles;
+    }
+
+    public void setRoles(List<RoleXmlDTO> roles) {
+        this.roles = roles;
+    }
+
+    void beforeUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        roles = new RiceXmlImportList<RoleXmlDTO>(this);
+    }
+    
+    void afterUnmarshal(Unmarshaller unmarshaller, Object parent) {
+        roles = null;
+    }
+    
+    /**
+     * @see org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener#newItemAdded(java.lang.Object)
+     */
+    public void newItemAdded(RoleXmlDTO item) {
+        // Persist the role if it has not already been persisted yet.
+        if (!item.isAlreadyPersisted()) {
+            try {
+                RoleXmlUtil.validateAndPersistNewRole(item);
+            } catch (UnmarshalException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        
+        // If a "roleMembers" element was present, remove any existing roles that do not match the new ones.
+        Set<String> existingRoleMemberIds = item.getExistingRoleMemberIds();
+        if (existingRoleMemberIds != null) {
+            RoleXmlUtil.removeRoleMembers(item.getRoleId(), existingRoleMemberIds);
+        }
+        item.setExistingRoleMemberIds(null);
+    }
+
+    void afterMarshal(Marshaller marshaller) {
+        roles = null;
+    }
+    
+    /**
+     * @see org.kuali.rice.core.util.jaxb.RiceXmlListGetterListener#gettingNextItem(java.lang.Object, int)
+     */
+    public RoleXmlDTO gettingNextItem(Object nextItem, int index) {
+        if (!(nextItem instanceof RoleContract)) {
+            throw new IllegalStateException("Object for exportation should have been a role");
+        }
+        RoleContract role = ((RoleContract)nextItem);
+        return new RoleXmlDTO(role, new RoleMembersXmlDTO.WithinRole(role.getId()), new RolePermissionsXmlDTO.WithinRole(role.getId()));
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/RolesXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java
===================================================================
--- work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java	(revision 32237)
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.impl.jaxb;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Collections;
+import java.util.List;
+
+import org.kuali.rice.core.framework.impex.xml.XmlLoader;
+import org.kuali.rice.kim.api.permission.PermissionContract;
+import org.kuali.rice.kim.api.role.RoleContract;
+import org.kuali.rice.krad.bo.Exporter;
+import org.kuali.rice.krad.exception.ExportNotSupportedException;
+import org.kuali.rice.krad.util.KRADConstants;
+
+/**
+ * Imports and exports roles and permissions from/to XML via JAXB.
+ * 
+ * <p>TODO: Do we need to restrict XML additions or updates based on which user is performing the ingestion?
+ * 
+ * <p>TODO: It may be best to make this class into a "service" instead.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class KimImporterAndExporter implements XmlLoader, Exporter {
+
+    private final List<String> supportedFormats = Collections.singletonList(KRADConstants.XML_FORMAT);
+    
+    /**
+     * @see org.kuali.rice.core.framework.impex.xml.XmlLoader#loadXml(java.io.InputStream, java.lang.String)
+     */
+    @Override
+    public void loadXml(InputStream inputStream, String principalId) {
+        KimXmlUtil.parseKimXml(inputStream);
+    }
+
+    /**
+     * @see org.kuali.rice.krad.bo.Exporter#export(java.lang.Class, java.util.List, java.lang.String, java.io.OutputStream)
+     */
+    @Override
+    public void export(Class<?> dataObjectClass, List<? extends Object> dataObjects, String exportFormat,
+            OutputStream outputStream) throws IOException, ExportNotSupportedException {
+        if (!supportedFormats.contains(exportFormat)) {
+            throw new ExportNotSupportedException("The KimImporterAndExporter does not support the \"" + exportFormat + "\" export format");
+        }
+        
+        if (PermissionContract.class.isAssignableFrom(dataObjectClass)) {
+            KimXmlUtil.exportKimXml(outputStream, dataObjects, null);
+        } else if (RoleContract.class.isAssignableFrom(dataObjectClass)) {
+            KimXmlUtil.exportKimXml(outputStream, null, dataObjects);
+        } else {
+            throw new ExportNotSupportedException("The KimImporterAndExporter cannot export non-permission and non-role objects");
+        }
+        
+    }
+
+    /**
+     * @see org.kuali.rice.krad.bo.Exporter#getSupportedFormats(java.lang.Class)
+     */
+    @Override
+    public List<String> getSupportedFormats(Class<?> dataObjectClass) {
+        return supportedFormats;
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/impl/jaxb/KimImporterAndExporter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/sesn/DistributedSession.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/DistributedSession.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/DistributedSession.java	(revision 32237)
@@ -0,0 +1,278 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn;
+
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kim.sesn.timeouthandlers.TimeoutHandler;
+import org.springframework.dao.IncorrectResultSizeDataAccessException;
+import org.springframework.jdbc.core.JdbcTemplate;
+
+/**
+ * This class is used to interface with the distributed session database.
+ * 
+ * TODO: add clear principals to clearSesn
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class DistributedSession {
+    public static final String DEFAULT_PREFIX="DST";
+    private static String prefix = DEFAULT_PREFIX;
+    private JdbcTemplate jdbcTemplate;
+    private TimeoutHandler timeoutHandler;
+    private boolean allowInsertOnTouch = false;
+    
+    private static final Log logger = LogFactory.getLog(DistributedSession.class);
+
+    /**
+     * @param timeoutHandler the timeoutHandler to set
+     */
+    public void setTimeoutHandler(TimeoutHandler timeoutHandler) {
+        this.timeoutHandler = timeoutHandler;
+    }
+
+    /**
+     * @param jdbcTemplate the jdbcTemplate to set
+     */
+    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
+        this.jdbcTemplate = jdbcTemplate;
+    }
+    
+    /**
+     * This method determines if the Session Ticket is valid.
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @return true if the session is valid
+     */
+    public boolean isSesnValid(String DST) {
+        logger.debug("isSesnValid(DST)");
+        return isSesnValid (DST, new HashMap<String,Object>());
+    }
+    
+    /**
+     * This method determines if the Session Ticket is valid.
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @param timoutArgs - Additional information on which to base timeouts
+     * @return true if the session is valid
+     */
+    public boolean isSesnValid(String DST, Map<String,Object> timeoutArgs) {
+        logger.debug("isSesnValid(DST, timeoutArgs)");
+        boolean bRet = false;
+        String sql = "select sesnID, lastAccessDt, maxIdleTime from authnsesn where sesnID=?";
+        
+        if (DST != null) {
+            Object[] args = { DST };
+            
+            try {
+                Map<String,Object> fields = jdbcTemplate.queryForMap(sql, args);
+                fields.put("maxIdleTime", this.getMaxIdleTime((Long)fields.get("maxIdleTime"), (Date)fields.get("lastAccessDt")));
+                fields.putAll(timeoutArgs);
+                
+                if (logger.isDebugEnabled()) {
+                    logger.debug("ARGUMENTS number:" + fields.size());
+                    for (Iterator<Map.Entry<String,Object>> i = fields.entrySet().iterator(); i.hasNext(); ) {
+                        Map.Entry<String,Object> entry = (Map.Entry<String,Object>)i.next();
+                        logger.debug("ARGUMENT " + entry.getKey() + ":" + entry.getValue());
+                    }
+                }
+                
+                if(!timeoutHandler.hasTimedOut(fields)) {
+                    logger.debug("Session not timed out");
+                    bRet = true;
+                } else {
+                    logger.debug("Session timed out");
+                }
+            } catch (Exception e) {
+                logger.debug(e);
+            }
+        } 
+        else {
+            logger.debug("Session ID is null");           
+        }
+                
+        return bRet;
+    }
+    
+    
+    /**
+     * This method returns the list of principals currently authenticated
+     * that are associated with the provided Distributed Session Ticket
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @return the List of authenticated principals
+     */
+    public List<String> getAuthenticatedPricipals(String DST) {
+        String sql = "select principalID from authnsesn where sesnID=?";
+        Object args[] = { DST };
+        
+        return jdbcTemplate.queryForList(sql, args, String.class);
+    }
+    
+    /**
+     * This method removes the session
+     * 
+     * @param DST - the Distributed Session Ticket
+     */
+    public void clearSesn(String DST) {
+        String sql = "delete from authnsesn where sesnID='" + DST + "'";
+        
+        jdbcTemplate.execute(sql);
+    }
+    
+    
+    /**
+     * This method takes an authenticated principal and generates a
+     * Distributed Session Ticket and updates the session database
+     * 
+     * @param principalID - the id of the authenticated entity
+     * @return DST - the Distributed Session Ticket
+     */
+    public String createSesn(String principalID) {
+        String DST = this.generateDST();
+        
+        this.touchSesn(DST);
+        this.addPrincipalToSesn(DST, principalID);
+
+        return DST;
+    }
+    
+    /**
+     * This method generates a unique Distributed Session Ticket
+     * 
+     * @return DST - the Distributed Session Ticket
+     */
+    public String generateDST() {
+        return prefix + "-" + SessionIdGenerator.getNewString();
+    }
+    
+    /**
+     * This method updates the session
+     * 
+     * @param DST - the Distributed Session Ticket
+     */
+    public void touchSesn(String DST) {
+        String sql = "select lastAccessDt, maxIdleTime from authnsesn where sesnID=?";
+        String updateSql = "";
+        Object[] args = { DST },
+               updateArgs;
+        Long maxIdleTime;
+        
+        try {
+            if (logger.isDebugEnabled()) {
+                logger.debug("ARGUMENTS number:" + args.length);
+                logger.debug("ARGUMENTS 0:" + args[0]);
+            }
+            Map<String,Object> fields = jdbcTemplate.queryForMap(sql, args);
+            Date lastAccessDt = (Date)fields.get("lastAccessDt");
+            if (logger.isDebugEnabled()) {
+                logger.debug("Last Access:" + lastAccessDt);
+            }
+            maxIdleTime = getMaxIdleTime((Long)fields.get("maxIdleTime"), lastAccessDt);
+            
+            
+            updateSql = "update authnsesn set lastAccessDt=NOW(), maxIdleTime = ? where sesnID=?";
+            updateArgs = new Object[] { maxIdleTime, DST };
+            jdbcTemplate.update(updateSql, updateArgs);
+        } 
+        // catch if no or more than 1 results are returned
+        catch (IncorrectResultSizeDataAccessException ex) {
+            if (this.allowInsertOnTouch) {
+                maxIdleTime = new Long(0);
+                
+                updateSql = "insert into authnsesn (sesnID, insertDt, lastAccessDt, maxIdleTime) values (?, NOW(), NOW(), ?)";
+                updateArgs = new Object[] { DST, maxIdleTime };
+                jdbcTemplate.update(updateSql, updateArgs);
+            }
+        }
+    }
+    
+    
+    /**
+     * This method returns the greater of the stored max idle time and 
+     * time since last access
+     * 
+     * @param oldMaxIdleTime - the previous max idle time
+     * @param lastAccessDt - the timestamp of last access
+     * @return the max idle time
+     */
+    public Long getMaxIdleTime(Long oldMaxIdleTime, Date lastAccessDt) {
+        Long maxIdleTime = oldMaxIdleTime;
+        
+        if (logger.isDebugEnabled()) {
+            logger.debug("Max Idle:" + maxIdleTime);
+        }
+        long curIdleTime = System.currentTimeMillis()-lastAccessDt.getTime();
+        if (logger.isDebugEnabled()) {
+            logger.debug("Curr Idle:" + curIdleTime);
+        }
+        if (curIdleTime > maxIdleTime) {
+            maxIdleTime = new Long(curIdleTime);
+        }
+        
+        return maxIdleTime;
+    }
+    
+    /**
+     * This method appends a principal to an active session
+     * 
+     * @param DST - the Distributed Session Ticket
+     * @param principalID - the id of the authenticated entity
+     */
+    public void addPrincipalToSesn(String DST, String principalID) {
+        // this will fail if the record already exists 
+        try {
+            String updateSql = "insert into authnsesnprincipal (sesnID, principalID) values (?, ?)";
+            
+            jdbcTemplate.update(updateSql, new Object[] { DST, principalID });
+            if (logger.isDebugEnabled()) {
+                logger.debug("Added Principal to Sesn:" + principalID + " " + DST);
+            }
+        }
+        catch (Exception e) {
+            if (logger.isDebugEnabled()) {
+                logger.debug("Principal Probably already exists:" + principalID + " " + DST);
+            }
+        }
+    }
+
+    /**
+     * @return the prefix
+     */
+    public static String getPrefix() {
+        return DistributedSession.prefix;
+    }
+
+    /**
+     * @param prefix the prefix to set
+     */
+    public static void setPrefix(String prefix) {
+        DistributedSession.prefix = prefix;
+    }
+
+    /**
+     * @param allowInsertOnTouch the allowInsertOnTouch to set
+     */
+    public void setAllowInsertOnTouch(boolean allowInsertOnTouch) {
+        this.allowInsertOnTouch = allowInsertOnTouch;
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/sesn/DistributedSession.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/sesn/SessionIdGenerator.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/SessionIdGenerator.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/SessionIdGenerator.java	(revision 32237)
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn;
+
+import java.security.SecureRandom;
+
+/**
+ * This class generates a random string for creating Distributed Session Tickets 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class SessionIdGenerator {
+
+    /** The array of printable characters to be used in our random string. */
+    private static final char[] PRINTABLE_CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345679"
+        .toCharArray();
+
+    private static final SecureRandom randomizer = new SecureRandom();
+
+    public static String getNewString() {
+        final byte[] random = getNewStringAsBytes();
+
+        return convertBytesToString(random);
+    }
+
+
+    private static byte[] getNewStringAsBytes() {
+        final byte[] random = new byte[40];
+
+        randomizer.nextBytes(random);
+        
+        return random;
+    }
+
+    private static String convertBytesToString(final byte[] random) {
+        final char[] output = new char[random.length];
+        for (int i = 0; i < random.length; i++) {
+            final int index = Math.abs(random[i] % PRINTABLE_CHARACTERS.length);
+            output[i] = PRINTABLE_CHARACTERS[index];
+        }
+
+        return new String(output);
+    }
+}

Property changes on: work/src/org/kuali/rice/kim/sesn/SessionIdGenerator.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/TimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/TimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/TimeoutHandler.java	(revision 32237)
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+import java.util.Map;
+
+/**
+ * This interface allows different methods for handling timeouts for Authentication
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public interface TimeoutHandler {
+    
+    /**
+     * Determines the timeout based on the context and initiator
+     *
+     * @param args the args passed depends on the requirements of the TimeoutHandler Implementation
+     *
+     * @return the timeout in seconds.  Returns 0 to disable timeouts.
+     */
+    public int getTimeout(Map<String,Object> args);
+    
+    
+    /**
+     * Determines if the timeout has expired
+     *
+     * @param args the args passed depends on the requirements of the TimeoutHandler Implementation
+     *
+     * @return true if the session has timed out.
+     */
+    public boolean hasTimedOut(Map<String,Object> args);
+
+}

Property changes on: work/src/org/kuali/rice/kim/sesn/timeouthandlers/TimeoutHandler.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/GlobalTimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/GlobalTimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/GlobalTimeoutHandler.java	(revision 32237)
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+/**
+ * This class uses the same timeout for all authentication methods and applications
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class GlobalTimeoutHandler extends AbstractTimeoutHandler {
+    private int timeoutPeriod;
+    
+    private static final Log logger = LogFactory.getLog(GlobalTimeoutHandler.class);
+
+    /**
+     * @return the timeoutPeriod
+     */
+    public int getTimeoutPeriod() {
+        return this.timeoutPeriod;
+    }
+
+    /**
+     * @param timeoutPeriod the timeoutPeriod to set
+     */
+    public void setTimeoutPeriod(int timeoutPeriod) {
+        this.timeoutPeriod = timeoutPeriod;
+    }
+
+    /**
+     * Determines the timeout based on the context and initiator
+     *
+     * @param args the args in this implementation aren't used
+     *
+     * @return the timeout in seconds
+     */
+    public int getTimeout(Map args) {
+        return timeoutPeriod; 
+    }
+    
+    /**
+     * 
+     * Examines results from session to determine if timeout has expired 
+     * 
+     * @see org.kuali.rice.kim.client.timeouthandlers.TimeoutHandler#hasTimedOut(java.lang.Object[])
+     */
+    public boolean hasTimedOut(Map args) {
+        boolean bRet = true;
+        Long maxIdleTime = (Long)args.get("maxIdleTime");
+        
+        if (maxIdleTime <= timeoutPeriod) {
+            logger.debug("Not timed out: " + maxIdleTime + " " + timeoutPeriod);
+            bRet = false;
+        } else {
+            logger.debug("Timed out: " + maxIdleTime + " " + timeoutPeriod);
+        }
+        return bRet;
+    }
+
+}
+

Property changes on: work/src/org/kuali/rice/kim/sesn/timeouthandlers/GlobalTimeoutHandler.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/AbstractTimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/AbstractTimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/AbstractTimeoutHandler.java	(revision 32237)
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+/**
+ * This Abstract Class allows the configuration of timeout fields.
+ * TODO: change how TimoutHandlers choose fields from ndx to name.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public abstract class AbstractTimeoutHandler implements TimeoutHandler{
+
+    private static final int MAX_IDLE_TIME_TIMEOUT_FIELD=1;
+    private static final int LAST_ACCCESS_TIMEOUT_FIELD=2;
+    private static final int DEFAULT_TIMEOUT_FIELD=MAX_IDLE_TIME_TIMEOUT_FIELD; 
+    private int timeoutField=AbstractTimeoutHandler.DEFAULT_TIMEOUT_FIELD;
+    
+    /**
+     * @return the timeoutField
+     */
+    public int getTimeoutField() {
+        return this.timeoutField;
+    }
+    /**
+     * @param timeoutField the timeoutField to set
+     */
+    public void setTimeoutField(int timeoutField) {
+        this.timeoutField = timeoutField;
+    }
+
+}
+

Property changes on: work/src/org/kuali/rice/kim/sesn/timeouthandlers/AbstractTimeoutHandler.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/sesn/timeouthandlers/DisabledTimeoutHandler.java
===================================================================
--- work/src/org/kuali/rice/kim/sesn/timeouthandlers/DisabledTimeoutHandler.java	(revision 0)
+++ work/src/org/kuali/rice/kim/sesn/timeouthandlers/DisabledTimeoutHandler.java	(revision 32237)
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.sesn.timeouthandlers;
+
+import java.util.Map;
+
+/**
+ * This is a description of what this class does - lsymms don't forget to fill this in. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class DisabledTimeoutHandler implements TimeoutHandler{
+    
+    /**
+     * @return false
+     * @see org.kuali.rice.kim.client.timeouthandlers.TimeoutHandler#hasTimedOut(java.lang.Object[])
+     */
+    public boolean hasTimedOut(Map<String,Object> args) {
+        // TODO lsymms - THIS METHOD NEEDS JAVADOCS
+        return false;
+    }
+
+    /**
+     * Determines the timeout based on the context and initiator
+     *
+     * @param args the args in this implementation aren't used
+     *
+     * @return 0 which disables the timeout.
+     */
+    public int getTimeout(Map<String,Object> args) {
+        return 0;
+    }
+}
+

Property changes on: work/src/org/kuali/rice/kim/sesn/timeouthandlers/DisabledTimeoutHandler.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/role/RoleManagementService.java
===================================================================
--- work/src/org/kuali/rice/kim/api/role/RoleManagementService.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/role/RoleManagementService.java	(revision 32237)
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.role;
+
+/**
+ * This service adds caching on top of the RoleService. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public interface RoleManagementService extends RoleService, RoleUpdateService {
+
+	/**
+	 * Flush all of the role-related caches.
+	 */
+	void flushRoleCaches();
+	
+	/**
+	 * Flush all of the role-member-related caches.
+	 */
+	void flushRoleMemberCaches();
+	
+	/**
+	 * Flush all of the delegation-related caches.
+	 */
+	void flushDelegationCaches();
+
+	/**
+	 * Flush all of the delegation-member-related caches.
+	 */
+	void flushDelegationMemberCaches();
+	
+	/**
+	 * Remove all cache entries for the given roleId and principalId combination.
+	 */
+	void removeCacheEntries( String roleId, String principalId );
+}

Property changes on: work/src/org/kuali/rice/kim/api/role/RoleManagementService.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java
===================================================================
--- work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java	(revision 32237)
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.role;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.exception.RiceIllegalArgumentException;
+import org.kuali.rice.core.api.uif.RemotableAttributeError;
+import org.kuali.rice.kim.api.type.KimAttributeField;
+import org.kuali.rice.kim.framework.role.RoleTypeService;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+public abstract class PassThruRoleTypeServiceBase implements RoleTypeService {
+
+	private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(PassThruRoleTypeServiceBase.class);
+	
+	public static final String UNMATCHABLE_QUALIFICATION = "!~!~!~!~!~";
+
+    @Override
+	public abstract Map<String, String> convertQualificationForMemberRoles(String namespaceCode, String roleName, String memberRoleNamespaceCode, String memberRoleName, Map<String, String> qualification);
+    
+    @Override
+	public List<RoleMembership> getMatchingRoleMemberships(Map<String, String> qualification,
+            List<RoleMembership> roleMemberList) {
+
+        if (qualification == null) {
+            throw new RiceIllegalArgumentException("qualification was null");
+        }
+
+        if (roleMemberList == null) {
+            throw new RiceIllegalArgumentException("roleMemberList was null");
+        }
+        return Collections.unmodifiableList(new ArrayList<RoleMembership>(roleMemberList));
+    }
+
+    @Override
+	public boolean doesRoleQualifierMatchQualification(Map<String, String> qualification, Map<String, String> roleQualifier) {
+        if (qualification == null) {
+            throw new RiceIllegalArgumentException("qualification was null");
+        }
+
+        if (roleQualifier == null) {
+            throw new RiceIllegalArgumentException("roleQualifier was null");
+        }
+
+        return true;
+    }
+    
+    @Override
+	public boolean hasApplicationRole(String principalId, List<String> groupIds, String namespaceCode, String roleName, Map<String, String> qualification) {
+        if (StringUtils.isBlank(principalId)) {
+            throw new RiceIllegalArgumentException("principalId was null or blank");
+        }
+
+        if (groupIds == null) {
+            throw new RiceIllegalArgumentException("groupIds was null or blank");
+        }
+
+        if (StringUtils.isBlank(namespaceCode)) {
+            throw new RiceIllegalArgumentException("namespaceCode was null or blank");
+        }
+
+        if (StringUtils.isBlank(roleName)) {
+            throw new RiceIllegalArgumentException("roleName was null or blank");
+        }
+
+        if (qualification == null) {
+            throw new RiceIllegalArgumentException("qualification was null");
+        }
+
+        return false;
+    }
+
+    @Override
+	public boolean isApplicationRoleType() {
+        return false;
+    }
+
+    public List<String> getAcceptedAttributeNames() {
+        return Collections.emptyList();
+    }
+
+    @Override
+	public List<KimAttributeField> getAttributeDefinitions(String kimTypeId) {
+        if (StringUtils.isBlank(kimTypeId)) {
+            throw new RiceIllegalArgumentException("kimTypeId was null or blank");
+        }
+
+        return Collections.emptyList();
+    }
+
+    @Override
+	public String getWorkflowDocumentTypeName() {
+        return null;
+    }
+
+    @Override
+	public List<String> getWorkflowRoutingAttributes(String routeLevel) {
+    	if (StringUtils.isBlank(routeLevel)) {
+            throw new RiceIllegalArgumentException("routeLevel was null or blank");
+        }
+
+        return Collections.emptyList();
+    }
+
+    public boolean supportsAttributes(List<String> attributeNames) {
+        if (attributeNames == null) {
+            throw new RiceIllegalArgumentException("attributeNames was null");
+        }
+
+        return true;
+    }
+
+    public Map<String, String> translateInputAttributes(Map<String, String> inputAttributes) {
+        if (inputAttributes == null) {
+            throw new RiceIllegalArgumentException("inputAttributes was null");
+        }
+
+        return inputAttributes;
+    }
+
+    @Override
+	public List<RemotableAttributeError> validateAttributes(String kimTypeId, Map<String, String> attributes) {
+        if (StringUtils.isBlank(kimTypeId)) {
+            throw new RiceIllegalArgumentException("kimTypeId was null or blank");
+        }
+
+        if (attributes == null) {
+            throw new RiceIllegalArgumentException("attributes was null or blank");
+        }
+
+        return Collections.emptyList();
+    }
+    
+	@Override
+	public List<RemotableAttributeError> validateAttributesAgainstExisting(String kimTypeId, Map<String, String> newAttributes, Map<String, String> oldAttributes){
+		if (StringUtils.isBlank(kimTypeId)) {
+            throw new RiceIllegalArgumentException("kimTypeId was null or blank");
+        }
+
+        if (newAttributes == null) {
+            throw new RiceIllegalArgumentException("newAttributes was null or blank");
+        }
+
+        if (oldAttributes == null) {
+            throw new RiceIllegalArgumentException("oldAttributes was null or blank");
+        }
+
+        return Collections.emptyList();
+	}
+
+	@Override
+	public boolean dynamicRoleMembership(String namespaceCode, String roleName) {
+	    if (StringUtils.isBlank(namespaceCode)) {
+            throw new RiceIllegalArgumentException("namespaceCode was null or blank");
+        }
+
+	    if (StringUtils.isBlank(roleName)) {
+            throw new RiceIllegalArgumentException("roleName was null or blank");
+        }
+
+        return false;
+	}
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/role/PassThruRoleTypeServiceBase.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java
===================================================================
--- work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java	(revision 32237)
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2008-2009 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.services;
+
+import org.kuali.rice.core.api.criteria.QueryByCriteria;
+import org.kuali.rice.kim.api.common.assignee.Assignee;
+import org.kuali.rice.kim.api.group.Group;
+import org.kuali.rice.kim.api.identity.CodedAttribute;
+import org.kuali.rice.kim.api.identity.affiliation.EntityAffiliationType;
+import org.kuali.rice.kim.api.identity.entity.Entity;
+import org.kuali.rice.kim.api.identity.entity.EntityDefault;
+import org.kuali.rice.kim.api.identity.entity.EntityDefaultQueryResults;
+import org.kuali.rice.kim.api.identity.entity.EntityQueryResults;
+import org.kuali.rice.kim.api.identity.external.EntityExternalIdentifierType;
+import org.kuali.rice.kim.api.identity.principal.Principal;
+import org.kuali.rice.kim.api.permission.Permission;
+import org.kuali.rice.kim.api.responsibility.Responsibility;
+import org.kuali.rice.kim.api.responsibility.ResponsibilityAction;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * This is the front end for the KIM module.  Clients of KIM should access this service from
+ * their applications.  If KIM is not running on the same machine (VM) as the application
+ * (as would be the case with a standalone Rice server), then this service should be implemented
+ * locally within the application and access the core KIM services
+ * (Authentication/Authorization/Identity/Group) via the service bus.
+ *
+ *  For efficiency, implementations of this interface should add appropriate caching of
+ *  the information retrieved from the core services for load and performance reasons.
+ *
+ *  Most of the methods on this interface are straight pass-thrus to methods on the four core services.
+ *
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public interface IdentityManagementService {
+
+	// *******************************
+	// IdentityService
+	// *******************************
+
+	Principal getPrincipal( String principalId);
+	Principal getPrincipalByPrincipalName( String principalName);
+
+	Principal getPrincipalByPrincipalNameAndPassword(
+             String principalName,
+             String password
+    );
+
+	EntityDefault getEntityDefaultInfo( String entityId);
+	EntityDefault getEntityDefaultInfoByPrincipalId( String principalId);
+	EntityDefault getEntityDefaultInfoByPrincipalName( String principalName);
+
+    EntityDefaultQueryResults findEntityDefaults(QueryByCriteria queryByCriteria);
+
+	//KimEntityPrivacyPreferencesInfo getEntityPrivacyPreferences(String entityId);
+
+	Entity getEntity( String entityId);
+	Entity getEntityByPrincipalId( String principalId);
+	Entity getEntityByPrincipalName( String principalName);
+
+	EntityQueryResults findEntities(QueryByCriteria queryByCriteria);
+
+	CodedAttribute getAddressType( String code);
+	EntityAffiliationType getAffiliationType( String code);
+	CodedAttribute getCitizenshipStatus( String code);
+	CodedAttribute getEmailType( String code);
+	CodedAttribute getEmploymentStatus( String code);
+	CodedAttribute getEmploymentType( String code);
+	CodedAttribute getEntityNameType( String code);
+	CodedAttribute getEntityType( String code);
+	EntityExternalIdentifierType getExternalIdentifierType( String code);
+	CodedAttribute getPhoneType( String code);
+
+	// *******************************
+	// GroupService
+	// *******************************
+
+	Group getGroup( String groupId);
+
+    Group getGroupByName(
+             String namespaceCode,
+             String groupName
+    );
+
+    List<String> getParentGroupIds( String groupId);
+    List<String> getDirectParentGroupIds( String groupId);
+
+    
+    List<String> getGroupIdsForPrincipal( String principalId);
+
+    
+    List<String> getGroupIdsForPrincipal(
+             String principalId,
+             String namespaceCode
+    );
+
+    
+    List<? extends Group> getGroupsForPrincipal( String principalId);
+
+    
+    List<? extends Group> getGroupsForPrincipal(
+             String principalId,
+             String namespaceCode
+    );
+
+    List<String> getMemberGroupIds( String groupId);
+    List<String> getDirectMemberGroupIds( String groupId);
+
+    
+	boolean isMemberOfGroup(
+             String principalId,
+             String groupId
+    );
+
+    
+	boolean isMemberOfGroup(
+             String principalId,
+             String namespaceCode,
+             String groupName
+    );
+
+	boolean isGroupMemberOfGroup(
+             String potentialMemberGroupId,
+             String potentialParentId
+    );
+
+	List<String> getGroupMemberPrincipalIds( String groupId);
+	List<String> getDirectGroupMemberPrincipalIds( String groupId);
+
+    boolean addGroupToGroup(
+             String childId,
+             String parentId
+    );
+
+    boolean removeGroupFromGroup(
+             String childId,
+             String parentId
+    );
+
+    boolean addPrincipalToGroup(
+             String principalId,
+             String groupId
+    );
+
+    boolean removePrincipalFromGroup(
+             String principalId,
+             String groupId
+    );
+
+    Group createGroup( Group group);
+    void removeAllMembers( String groupId);
+
+    Group updateGroup(
+             String groupId,
+             Group group
+    );
+
+    // --------------------
+    // Authorization Checks
+    // --------------------
+
+    boolean hasPermission(
+             String principalId,
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails
+    );
+
+    boolean isAuthorized(
+             String principalId,
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    boolean hasPermissionByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String permissionTemplateName,
+              Map<String, String> permissionDetails
+    );
+
+    boolean isAuthorizedByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String permissionTemplateName,
+             Map<String, String> permissionDetails,
+             Map<String, String> qualification
+    );
+
+    /**
+     * Returns the matching permission objects for a principal.
+     */
+    List<Permission> getAuthorizedPermissions(
+             String principalId,
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    List<Permission> getAuthorizedPermissionsByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String permissionTemplateName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    List<Assignee> getPermissionAssignees(
+             String namespaceCode,
+             String permissionName,
+              Map<String, String> permissionDetails,
+              Map<String, String> qualification
+    );
+
+    List<Assignee> getPermissionAssigneesForTemplateName(
+             String namespaceCode,
+             String permissionTemplateName,
+             Map<String, String> permissionDetails,
+             Map<String, String> qualification
+    );
+
+    // ----------------------
+    // Responsibility Methods
+    // ----------------------
+
+    /**
+     * Get the responsibility object with the given ID.
+     */
+    Responsibility getResponsibility( String responsibilityId);
+
+ 	/**
+ 	 * Return the responsibility object for the given unique combination of namespace,
+ 	 * component and responsibility name.
+ 	 */
+    Responsibility getResponsibilityByName(
+             String namespaceCode,
+             String responsibilityName
+    );
+
+    /**
+     * Check whether the principal has the given responsibility within the passed qualifier.
+     */
+    boolean hasResponsibility(
+             String principalId,
+             String namespaceCode,
+             String responsibilityName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    /**
+     * Check whether the principal has the given responsibility within the passed qualifier.
+     */
+    boolean hasResponsibilityByTemplateName(
+             String principalId,
+             String namespaceCode,
+             String responsibilityTemplateName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    List<ResponsibilityAction> getResponsibilityActions(
+             String namespaceCode,
+             String responsibilityName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    List<ResponsibilityAction> getResponsibilityActionsByTemplateName(
+             String namespaceCode,
+             String responsibilityTemplateName,
+              Map<String, String> qualification,
+              Map<String, String> responsibilityDetails
+    );
+
+    /**
+     * Returns true if there are any assigned permissions with the given template.
+     */
+    boolean isPermissionDefinedForTemplateName(
+             String namespaceCode,
+             String permissionTemplateName,
+              Map<String, String> permissionDetails
+    );
+
+
+    // ----------------------
+    // Cache Flush Methods
+    // ----------------------
+
+    void flushAllCaches();
+    void flushEntityPrincipalCaches();
+	void flushGroupCaches();
+	void flushPermissionCaches();
+	void flushResponsibilityCaches();
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java	(revision 32237)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import javax.xml.bind.MarshalException;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+import org.kuali.rice.kim.api.type.KimTypeContract;
+
+/**
+ * An XML adapter that converts between a NameAndNamespacePair and a KIM type ID.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class NameAndNamespacePairToKimTypeIdAdapter extends XmlAdapter<NameAndNamespacePair,String> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public String unmarshal(NameAndNamespacePair v) throws Exception {
+        if (v != null) {
+            KimTypeContract kimType = KimApiServiceLocator.getKimTypeInfoService().findKimTypeByNameAndNamespace(
+                    v.getNamespaceCode(), new NormalizedStringAdapter().unmarshal(v.getName()));
+            if (kimType == null) {
+                throw new UnmarshalException("Cannot find KIM Type with namespace \"" + v.getNamespaceCode() + "\" and name \"" + v.getName() + "\"");
+            }
+            return kimType.getId();
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public NameAndNamespacePair marshal(String v) throws Exception {
+        if (v != null) {
+            KimTypeContract kimType = KimApiServiceLocator.getKimTypeInfoService().getKimType(StringUtils.trim(v));
+            if (kimType == null) {
+                throw new MarshalException("Cannot find KIM Type with ID \"" + v + "\"");
+            }
+            return new NameAndNamespacePair(kimType.getNamespaceCode(), kimType.getName());
+        }
+        return null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToKimTypeIdAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java	(revision 32237)
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.kuali.rice.core.api.util.jaxb.MapStringStringAdapter;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An XML element that can have zero or more StringMapEntry elements. This is similar
+ * to the StringMapEntryList, except this element's children are &lt;qualification&gt; elements.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="QualificationListType", propOrder={"qualifications"})
+public class QualificationList implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="qualification")
+    private List<MapStringStringAdapter.StringMapEntry> qualifications;
+    
+    public QualificationList () {
+        qualifications = new ArrayList<MapStringStringAdapter.StringMapEntry>();
+    }
+    
+    public QualificationList(Map<String, String> map) {
+        this();
+        for (Map.Entry<String,String> tempEntry : map.entrySet()) {
+            qualifications.add(new MapStringStringAdapter.StringMapEntry(tempEntry));
+        }
+    }
+
+    /**
+     * @return the qualifications
+     */
+    public List<MapStringStringAdapter.StringMapEntry> getQualifications() {
+        return this.qualifications;
+    }
+
+    /**
+     * @param qualifications the qualifications to set
+     */
+    public void setQualifications(List<MapStringStringAdapter.StringMapEntry> qualifications) {
+        this.qualifications = qualifications;
+    }
+
+    
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/QualificationList.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/package-info.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/package-info.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/package-info.java	(revision 32237)
@@ -0,0 +1,6 @@
+@javax.xml.bind.annotation.XmlSchema(namespace = KimApiConstants.Namespaces.KIM_NAMESPACE_2_0, elementFormDefault = XmlNsForm.QUALIFIED)
+package org.kuali.rice.kim.api.jaxb;
+
+import javax.xml.bind.annotation.XmlNsForm;
+
+import org.kuali.rice.kim.api.KimApiConstants;
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/package-info.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java	(revision 32237)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.util.jaxb.MapStringStringAdapter;
+
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An XML adapter that converts between QualificationList objects and Map<String, String> objects.
+ * Unmarshalled keys and values will automatically be trimmed if non-null.
+ * 
+ * <p>This adapter will throw an exception during unmarshalling if blank or duplicate keys are encountered.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class QualificationListAdapter extends XmlAdapter<QualificationList,Map<String, String>> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public Map<String, String> unmarshal(QualificationList v) throws Exception {
+        if (v != null) {
+            NormalizedStringAdapter normalizedStringAdapter = new NormalizedStringAdapter();
+            Map<String, String> map = new HashMap<String, String>();
+            for (MapStringStringAdapter.StringMapEntry stringMapEntry : v.getQualifications()) {
+                String tempKey = normalizedStringAdapter.unmarshal(stringMapEntry.getKey());
+                if (StringUtils.isBlank(tempKey)) {
+                    throw new UnmarshalException("Cannot create a qualification entry with a blank key");
+                } else if (map.containsKey(tempKey)) {
+                    throw new UnmarshalException("Cannot create more than one qualification entry with a key of \"" + tempKey + "\"");
+                }
+                map.put(tempKey, normalizedStringAdapter.unmarshal(stringMapEntry.getValue()));
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public QualificationList marshal(Map<String, String> v) throws Exception {
+        return (v != null) ? new QualificationList(v) : null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/QualificationListAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java	(revision 32237)
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.kuali.rice.core.api.util.jaxb.MapStringStringAdapter;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlType;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * An XML element that can have zero or more StringMapEntry elements. This is similar
+ * to the StringMapEntryList, except this element's children are &lt;permissionDetail&gt; elements.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="PermissionDetailListType", propOrder={"permissionDetails"})
+public class PermissionDetailList implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="permissionDetail")
+    private List<MapStringStringAdapter.StringMapEntry> permissionDetails;
+    
+    public PermissionDetailList() {
+        this.permissionDetails = new ArrayList<MapStringStringAdapter.StringMapEntry>();
+    }
+    
+    public PermissionDetailList(Map<String, String> map) {
+        this();
+        for (Map.Entry<String,String> tempEntry : map.entrySet()) {
+            permissionDetails.add(new MapStringStringAdapter.StringMapEntry(tempEntry));
+        }
+    }
+
+    /**
+     * @return the permissionDetails
+     */
+    public List<MapStringStringAdapter.StringMapEntry> getPermissionDetails() {
+        return this.permissionDetails;
+    }
+
+    /**
+     * @param permissionDetails the permissionDetails to set
+     */
+    public void setPermissionDetails(List<MapStringStringAdapter.StringMapEntry> permissionDetails) {
+        this.permissionDetails = permissionDetails;
+    }
+    
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailList.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java	(revision 32237)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.util.jaxb.MapStringStringAdapter;
+
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * An XML adapter that converts between PermissionDetailList objects and Map<String, String> objects.
+ * Unmarshalled keys and values will automatically be trimmed if non-null.
+ * 
+ * <p>This adapter will throw an exception during unmarshalling if blank or duplicate keys are encountered.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class PermissionDetailListAdapter extends XmlAdapter<PermissionDetailList,Map<String, String>> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public Map<String, String> unmarshal(PermissionDetailList v) throws Exception {
+        if (v != null) {
+            NormalizedStringAdapter normalizedStringAdapter = new NormalizedStringAdapter();
+            Map<String, String> map = new HashMap<String, String>();
+            for (MapStringStringAdapter.StringMapEntry stringMapEntry : v.getPermissionDetails()) {
+                String tempKey = normalizedStringAdapter.unmarshal(stringMapEntry.getKey());
+                if (StringUtils.isBlank(tempKey)) {
+                    throw new UnmarshalException("Cannot create a permission detail entry with a blank key");
+                } else if (map.containsKey(tempKey)) {
+                    throw new UnmarshalException("Cannot create more than one permission detail entry with a key of \"" + tempKey + "\"");
+                }
+                map.put(tempKey, normalizedStringAdapter.unmarshal(stringMapEntry.getValue()));
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public PermissionDetailList marshal(Map<String, String> v) throws Exception {
+        return (v != null) ? new PermissionDetailList(v) : null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/PermissionDetailListAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java
===================================================================
--- work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java	(revision 32237)
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.api.jaxb;
+
+import javax.xml.bind.MarshalException;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+import org.kuali.rice.core.util.jaxb.NameAndNamespacePair;
+import org.kuali.rice.kim.api.services.KimApiServiceLocator;
+import org.kuali.rice.kim.api.common.template.Template;
+
+/**
+ * An XML adapter that converts between a NameAndNamespacePair and a permission template ID.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class NameAndNamespacePairToPermTemplateIdAdapter extends XmlAdapter<NameAndNamespacePair,String> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public String unmarshal(NameAndNamespacePair v) throws Exception {
+        if (v != null) {
+            Template permissionTemplate = KimApiServiceLocator.getPermissionService().findPermTemplateByNamespaceCodeAndName(
+                    v.getNamespaceCode(), new NormalizedStringAdapter().unmarshal(v.getName()));
+            if (permissionTemplate == null) {
+                throw new UnmarshalException("Cannot find permission template with namespace \"" + v.getNamespaceCode() + "\" and name \"" + v.getName() + "\"");
+            }
+            return permissionTemplate.getId();
+        }
+        return null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public NameAndNamespacePair marshal(String v) throws Exception {
+        if (v != null) {
+            Template permissionTemplate = KimApiServiceLocator.getPermissionService().getPermissionTemplate(v);
+            if (permissionTemplate == null) {
+                throw new MarshalException("Cannot find permission template with ID \"" + v + "\"");
+            }
+            return new NameAndNamespacePair(permissionTemplate.getNamespaceCode(), permissionTemplate.getName());
+        }
+        return null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/api/jaxb/NameAndNamespacePairToPermTemplateIdAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/util/KimCommonUtils.java
===================================================================
--- work/src/org/kuali/rice/kim/util/KimCommonUtils.java	(revision 0)
+++ work/src/org/kuali/rice/kim/util/KimCommonUtils.java	(revision 32237)
@@ -0,0 +1,373 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.util;
+
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.namespace.QName;
+
+import org.apache.commons.beanutils.PropertyUtils;
+import org.apache.commons.lang.StringUtils;
+import org.kuali.kfs.sys.context.SpringContext;
+import org.kuali.rice.core.api.config.property.ConfigurationService;
+import org.kuali.rice.kew.doctype.bo.DocumentType;
+
+/**
+ * This is a description of what this class does - bhargavp don't forget to fill
+ * this in.
+ *
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class KimCommonUtils {
+    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KimCommonUtils.class);
+
+    public static String getClosestParentDocumentTypeName(
+            DocumentType documentType,
+            Set<String> potentialParentDocumentTypeNames) {
+        if ( potentialParentDocumentTypeNames == null || documentType == null ) {
+            return null;
+        }
+        if (potentialParentDocumentTypeNames.contains(documentType.getName())) {
+            return documentType.getName();
+        } else {
+            if ((documentType.getDocTypeParentId() == null)
+                    || documentType.getDocTypeParentId().equals(
+                            documentType.getDocumentTypeId())) {
+                return null;
+            } else {
+                return getClosestParentDocumentTypeName(documentType
+                        .getParentDocType(), potentialParentDocumentTypeNames);
+            }
+        }
+    }
+
+    public static boolean storedValueNotSpecifiedOrInputValueMatches(Map<String,String> storedValues, Map<String,String> inputValues, String attributeName) {
+        return ((storedValues == null) || (inputValues == null)) || !storedValues.containsKey(attributeName) || storedValues.get(attributeName).equals(inputValues.get(attributeName));
+    }
+
+    public static boolean doesPropertyNameMatch(
+            String requestedDetailsPropertyName,
+            String permissionDetailsPropertyName) {
+        if (StringUtils.isBlank(permissionDetailsPropertyName)) {
+            return true;
+        }
+        if ( requestedDetailsPropertyName == null ) {
+            requestedDetailsPropertyName = ""; // prevent NPE
+        }
+        return StringUtils.equals(requestedDetailsPropertyName, permissionDetailsPropertyName)
+                || (requestedDetailsPropertyName.startsWith(permissionDetailsPropertyName+"."));
+    }
+
+//    public static AttributeSet getNamespaceAndComponentSimpleName( Class<? extends Object> clazz) {
+//        AttributeSet attributeSet = new AttributeSet();
+//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimAttributes.COMPONENT_NAME, getComponentSimpleName(clazz));
+//        return attributeSet;
+//    }
+//
+//    public static AttributeSet getNamespaceAndComponentFullName( Class<? extends Object> clazz) {
+//        AttributeSet attributeSet = new AttributeSet();
+//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimAttributes.COMPONENT_NAME, getComponentFullName(clazz));
+//        return attributeSet;
+//    }
+//
+//    public static AttributeSet getNamespaceAndActionClass( Class<? extends Object> clazz) {
+//        AttributeSet attributeSet = new AttributeSet();
+//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimAttributes.ACTION_CLASS, clazz.getName());
+//        return attributeSet;
+//    }
+//
+//    public static String getNamespaceCode(Class<? extends Object> clazz) {
+//        ModuleService moduleService = getKualiModuleService().getResponsibleModuleService(clazz);
+//        if (moduleService == null) {
+//            return KimConstants.KIM_TYPE_DEFAULT_NAMESPACE;
+//        }
+//        return moduleService.getModuleConfiguration().getNamespaceCode();
+//    }
+
+    public static String getComponentSimpleName(Class<? extends Object> clazz) {
+        return clazz.getSimpleName();
+    }
+
+    public static String getComponentFullName(Class<? extends Object> clazz) {
+        return clazz.getName();
+    }
+
+//    public static boolean isAttributeSetEntryEquals( AttributeSet map1, AttributeSet map2, String key ) {
+//        return StringUtils.equals( map1.get( key ), map2.get( key ) );
+//    }
+
+    /**
+     * Resolves the given kim type service name represented as a String to the appropriate QName.
+     * If the value given is empty or null, then it will resolve to the default KimTypeService name.
+     */
+    public static QName resolveKimTypeServiceName(String kimTypeServiceName) {
+        if (StringUtils.isBlank(kimTypeServiceName)) {
+            return resolveKimTypeServiceName(KimConstants.DEFAULT_KIM_TYPE_SERVICE);
+        }
+        return QName.valueOf(kimTypeServiceName);
+    }
+
+//    /**
+//     * @deprecated Please use KIMServiceLocator.getKimTypeService(KimType) instead
+//     */
+//    @Deprecated
+//    public static KimTypeService getKimTypeService(KimType kimType){
+//        return KIMServiceLocator.getKimTypeService(kimType);
+//    }
+//
+//    /**
+//     * @deprecated Please use KIMServiceLocator.getKimTypeService(QName) instead
+//     */
+//    @Deprecated
+//    public static KimTypeService getKimTypeService( String serviceName ) {
+//        return KIMServiceLocator.getKimTypeService(resolveKimTypeServiceName(serviceName));
+//    }
+
+    public static void copyProperties(Object targetToCopyTo, Object sourceToCopyFrom){
+        if(targetToCopyTo!=null && sourceToCopyFrom!=null)
+        try{
+            PropertyUtils.copyProperties(targetToCopyTo, sourceToCopyFrom);
+        } catch(Exception ex){
+            throw new RuntimeException("Failed to copy from source object: "+sourceToCopyFrom.getClass()+" to target object: "+targetToCopyTo,ex);
+        }
+    }
+
+    public static String getKimBasePath(){
+        String kimBaseUrl = SpringContext.getBean(ConfigurationService.class).getPropertyString(KimConstants.KimUIConstants.KIM_URL_KEY);
+        if (!kimBaseUrl.endsWith(KimConstants.KimUIConstants.URL_SEPARATOR)) {
+            kimBaseUrl = kimBaseUrl + KimConstants.KimUIConstants.URL_SEPARATOR;
+        }
+        return kimBaseUrl;
+    }
+
+    public static String getPathWithKimContext(String path, String kimActionName){
+        String kimContext = KimConstants.KimUIConstants.KIM_APPLICATION+KimConstants.KimUIConstants.URL_SEPARATOR;
+        String kimContextParameterized = KimConstants.KimUIConstants.KIM_APPLICATION+KimConstants.KimUIConstants.PARAMETERIZED_URL_SEPARATOR;
+        if(path.contains(kimActionName) && !path.contains(kimContext + kimActionName)
+                && !path.contains(kimContextParameterized + kimActionName))
+            path = path.replace(kimActionName, kimContext+kimActionName);
+        return path;
+    }
+
+    public static String stripEnd(String toStripFrom, String toStrip){
+        String stripped;
+        if(toStripFrom==null) return null;
+        if(toStrip==null) return toStripFrom;
+        if(toStrip.length() > toStripFrom.length()) return toStripFrom;
+        if(toStripFrom.endsWith(toStrip)){
+            StringBuffer buffer = new StringBuffer(toStripFrom);
+            buffer.delete(buffer.length()-toStrip.length(), buffer.length());
+            stripped = buffer.toString();
+        } else stripped = toStripFrom;
+        return stripped;
+    }
+
+//    protected static boolean canOverrideEntityPrivacyPreferences( String principalId ){
+//        return getIdentityManagementService().isAuthorized(
+//                GlobalVariables.getUserSession().getPrincipalId(),
+//                KimConstants.NAMESPACE_CODE,
+//                KimConstants.PermissionNames.OVERRIDE_ENTITY_PRIVACY_PREFERENCES,
+//                null,
+//                new AttributeSet(KimAttributes.PRINCIPAL_ID, principalId) );
+//    }
+//
+//    public static boolean isSuppressName(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressName = false;
+//        if (privacy != null) {
+//            suppressName = privacy.isSuppressName();
+//        }
+//        return suppressName
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressEmail(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressEmail = false;
+//        if (privacy != null) {
+//            suppressEmail = privacy.isSuppressEmail();
+//        }
+//        return suppressEmail
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressAddress(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressAddress = false;
+//        if (privacy != null) {
+//            suppressAddress = privacy.isSuppressAddress();
+//        }
+//        return suppressAddress
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressPhone(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressPhone = false;
+//        if (privacy != null) {
+//            suppressPhone = privacy.isSuppressPhone();
+//        }
+//        return suppressPhone
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static boolean isSuppressPersonal(String entityId) {
+//        KimEntityPrivacyPreferences privacy = null;
+//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        if (entityInfo != null) {
+//            privacy = entityInfo.getPrivacyPreferences();
+//        }
+//        UserSession userSession = GlobalVariables.getUserSession();
+//
+//        boolean suppressPersonal = false;
+//        if (privacy != null) {
+//            suppressPersonal = privacy.isSuppressPersonal();
+//        }
+//        return suppressPersonal
+//                && userSession != null
+//                && !StringUtils.equals(userSession.getPerson().getEntityId(), entityId)
+//                && !canOverrideEntityPrivacyPreferences(entityInfo.getPrincipals().get(0).getPrincipalId());
+//    }
+//
+//    public static String encryptExternalIdentifier(String externalIdentifier, String externalIdentifierType){
+//        Map<String, String> criteria = new HashMap<String, String>();
+//        criteria.put(KimConstants.PrimaryKeyConstants.KIM_TYPE_CODE, externalIdentifierType);
+//        ExternalIdentifierType externalIdentifierTypeObject = (ExternalIdentifierType) KNSServiceLocator.getBusinessObjectService().findByPrimaryKey(ExternalIdentifierTypeImpl.class, criteria);
+//        if( externalIdentifierTypeObject!= null && externalIdentifierTypeObject.isEncryptionRequired()){
+//            if(StringUtils.isNotEmpty(externalIdentifier)){
+//                try{
+//                    return KNSServiceLocator.getEncryptionService().encrypt(externalIdentifier);
+//                }catch (GeneralSecurityException e) {
+//                    LOG.info("Unable to encrypt value : " + e.getMessage() + " or it is already encrypted");
+//                }
+//            }
+//        }
+//        return externalIdentifier;
+//    }
+//
+//    public static String decryptExternalIdentifier(String externalIdentifier, String externalIdentifierType){
+//        Map<String, String> criteria = new HashMap<String, String>();
+//        criteria.put(KimConstants.PrimaryKeyConstants.KIM_TYPE_CODE, externalIdentifierType);
+//        ExternalIdentifierType externalIdentifierTypeObject = (ExternalIdentifierType) KNSServiceLocator.getBusinessObjectService().findByPrimaryKey(ExternalIdentifierTypeImpl.class, criteria);
+//        if( externalIdentifierTypeObject!= null && externalIdentifierTypeObject.isEncryptionRequired()){
+//            if(StringUtils.isNotEmpty(externalIdentifier)){
+//                try{
+//                    return KNSServiceLocator.getEncryptionService().decrypt(externalIdentifier);
+//                }catch (GeneralSecurityException e) {
+//                    LOG.info("Unable to decrypt value : " + e.getMessage() + " or it is already decrypted");
+//                }
+//            }
+//        }
+//        return externalIdentifier;
+//    }
+//
+//    public static IdentityManagementService getIdentityManagementService() {
+//        if ( identityManagementService == null ) {
+//            identityManagementService = KIMServiceLocator.getIdentityManagementService();
+//        }
+//        return identityManagementService;
+//    }
+//
+//
+//    public static GroupImpl copyInfoToGroup(Group info, GroupImpl group) {
+//        group.setActive(info.isActive());
+//        group.setGroupDescription(info.getGroupDescription());
+//        group.setGroupId(info.getGroupId());
+//        group.setGroupName(info.getGroupName());
+//        group.setKimTypeId(info.getKimTypeId());
+//        group.setNamespaceCode(info.getNamespaceCode());
+//
+//        return group;
+//    }
+//
+//    /**
+//     *
+//     * @param infoMap Containing the Info Attribute objects.
+//     * @param groupId for the group of attributes
+//     * @param kimTypeId for the group of attributes
+//     * @return a list of group attributes
+//     */
+//
+//    public static List<GroupAttributeDataImpl> copyInfoAttributesToGroupAttributes(Map<String, String> infoMap, String groupId, String kimTypeId) {
+//        List<GroupAttributeDataImpl> attrList = new ArrayList<GroupAttributeDataImpl>(infoMap.size());
+//        List<KimTypeAttributeInfo> attributeInfoList = KIMServiceLocator.getTypeInfoService().getKimType(kimTypeId).getAttributeDefinitions();
+//
+//        for (String key : infoMap.keySet()) {
+//            KimTypeAttributeInfo typeAttributeInfo = getAttributeInfo(attributeInfoList, key);
+//
+//            if (typeAttributeInfo != null) {
+//                GroupAttributeDataImpl groupAttribute = new GroupAttributeDataImpl();
+//                groupAttribute.setKimAttributeId(typeAttributeInfo.getKimAttributeId());
+//                groupAttribute.setAttributeValue(infoMap.get(typeAttributeInfo.getAttributeName()));
+//                groupAttribute.setGroupId(groupId);
+//                groupAttribute.setKimTypeId(kimTypeId);
+//                attrList.add(groupAttribute);
+//            } else {
+//                throw new IllegalArgumentException("KimAttribute not found: " + key);
+//            }
+//        }
+//        return attrList;
+//    }
+//
+//    private static KimTypeAttributeInfo getAttributeInfo(List<KimTypeAttributeInfo> attributeInfoList, String attributeName) {
+//        KimTypeAttributeInfo kRet = null;
+//        for (KimTypeAttributeInfo attributeInfo : attributeInfoList) {
+//            if (attributeInfo.getAttributeName().equals(attributeName)) {
+//                kRet = attributeInfo;
+//                break;
+//            }
+//        }
+//        return kRet;
+//    }
+
+}

Property changes on: work/src/org/kuali/rice/kim/util/KimCommonUtils.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java
===================================================================
--- work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java	(revision 32237)
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.PBKey;
+import org.apache.ojb.broker.TransactionAbortedException;
+import org.apache.ojb.broker.TransactionInProgressException;
+import org.apache.ojb.broker.TransactionNotInProgressException;
+import org.apache.ojb.broker.core.PersistenceBrokerFactoryIF;
+import org.apache.ojb.broker.core.PersistenceBrokerImpl;
+
+public class KualiPersistenceBrokerImpl extends PersistenceBrokerImpl {
+    private static final Logger LOG = Logger.getLogger(KualiPersistenceBrokerImpl.class);
+
+
+    private boolean fresh = true;
+
+    public KualiPersistenceBrokerImpl(PBKey key, PersistenceBrokerFactoryIF pbf) {
+        super(key, pbf);
+    }
+
+    public boolean isFresh() {
+        return fresh;
+    }
+
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#beginTransaction()
+     */
+    public synchronized void beginTransaction() throws TransactionInProgressException, TransactionAbortedException {
+        LOG.debug("beginning transaction for persistenceBroker " + getClass().getName() + "@" + hashCode());
+
+        super.beginTransaction();
+    }
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#abortTransaction()
+     */
+    public synchronized void abortTransaction() throws TransactionNotInProgressException {
+        LOG.debug("aborting transaction for persistenceBroker " + getClass().getName() + "@" + hashCode());
+
+        super.abortTransaction();
+    }
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#commitTransaction()
+     */
+    public synchronized void commitTransaction() throws TransactionNotInProgressException, TransactionAbortedException {
+        LOG.debug("committing transaction for persistenceBroker " + getClass().getName() + "@" + hashCode());
+
+        super.commitTransaction();
+    }
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerImpl#close()
+     */
+    public boolean close() {
+        LOG.debug("closing persistenceBroker " + getClass().getName() + "@" + hashCode());
+        fresh = false;
+
+        return super.close();
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java
===================================================================
--- work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java	(revision 32237)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.metadata.ConnectionRepository;
+import org.apache.ojb.broker.metadata.DescriptorRepository;
+import org.apache.ojb.broker.metadata.MetadataManager;
+import org.kuali.rice.core.api.util.ClassLoaderUtils;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.core.io.DefaultResourceLoader;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+
+public class OjbMetadataLoader implements InitializingBean {
+    
+    private static final Logger LOG = Logger.getLogger(OjbMetadataLoader.class);
+
+    private List<String> repositoryDescriptors = new ArrayList<String>();
+    private List<String> connectionDescriptors = new ArrayList<String>(); 
+    
+    public List<String> getConnectionDescriptors() {
+        return connectionDescriptors;
+    }
+
+    public void setConnectionDescriptors(List<String> connectionDescriptors) {
+        this.connectionDescriptors = connectionDescriptors;
+    }
+
+    public List<String> getRepositoryDescriptors() {
+        return repositoryDescriptors;
+    }
+
+    public void setRepositoryDescriptors(List<String> repositoryDescriptors) {
+        this.repositoryDescriptors = repositoryDescriptors;
+    }
+
+    public void afterPropertiesSet() throws Exception {
+        
+        MetadataManager mm = MetadataManager.getInstance();
+        DefaultResourceLoader resourceLoader = new DefaultResourceLoader(ClassLoaderUtils.getDefaultClassLoader());
+        
+        for (String repositoryDescriptor : repositoryDescriptors) {
+            InputStream is = resourceLoader.getResource(repositoryDescriptor).getInputStream();
+            DescriptorRepository dr = mm.readDescriptorRepository(is);
+            mm.mergeDescriptorRepository(dr);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("--------------------------------------------------------------------------");
+                LOG.debug("Merging repository descriptor: " + repositoryDescriptor);
+                LOG.debug("--------------------------------------------------------------------------");
+            }
+            try {
+                is.close();
+            } catch (Exception e) {
+                LOG.warn("Failed to close stream to file " + repositoryDescriptor, e);
+            }
+        }
+        
+        for (String connectionDesciptor : connectionDescriptors) {
+            InputStream is = resourceLoader.getResource(connectionDesciptor).getInputStream();
+            ConnectionRepository cr = mm.readConnectionRepository(is);
+            mm.mergeConnectionRepository(cr);
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("--------------------------------------------------------------------------");
+                LOG.debug("Merging connection descriptor: " + connectionDesciptor);
+                LOG.debug("--------------------------------------------------------------------------");
+            }
+            try {
+                is.close();
+            } catch (Exception e) {
+                LOG.warn("Failed to close stream to file " + connectionDesciptor, e);
+            }
+        }
+        
+    }
+
+}

Property changes on: work/src/org/kuali/rice/krad/util/OjbMetadataLoader.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java
===================================================================
--- work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java	(revision 32237)
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
+
+/**
+ * Builds a <code>{@link String}</code> instance using a pattern similar to the varargs printf() variety.
+ * 
+ * 
+ */
+public class PatternedStringBuilder {
+    private String _pattern;
+
+    /**
+     * Constructor that takes a pattern
+     * 
+     * @param pattern
+     */
+    public PatternedStringBuilder(String pattern) {
+        setPattern(pattern);
+    }
+
+    /**
+     * Write accessor method for pattern
+     * 
+     * @param pattern
+     */
+    public void setPattern(String pattern) {
+        _pattern = pattern;
+    }
+
+    /**
+     * Read accessor method for pattern
+     * 
+     * @return String
+     */
+    public String getPattern() {
+        return _pattern;
+    }
+
+    /**
+     * Takes an ellipses of <code>{@link String}</code> parameters and builds a <code>{@link String}</code> instance from them
+     * and the pattern given earlier.
+     * 
+     * @param args
+     * @return String
+     */
+    public String sprintf(Object... args) {
+        ByteArrayOutputStream retval = new ByteArrayOutputStream();
+
+        new PrintStream(retval).printf(getPattern(), args);
+
+        return retval.toString();
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/PatternedStringBuilder.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java
===================================================================
--- work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java	(revision 32237)
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2007 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import java.util.Iterator;
+
+import org.apache.commons.collections.IteratorUtils;
+
+/**
+ * This class provides utility methods to support the operation of transactional services
+ */
+public final class TransactionalServiceUtils {
+	
+	private TransactionalServiceUtils() {
+		throw new UnsupportedOperationException("do not call");
+	}
+    /**
+     * Copys iterators so that they may be used outside of this class.  Often, the DAO may
+     * return iterators that may not be used outside of this class because the transaction/
+     * connection may be automatically closed by Spring.
+     * 
+     * This method copies all of the elements in the OJB backed iterators into list-based iterators
+     * by placing the returned BOs into a list
+     * 
+     * @param iter an OJB backed iterator to copy
+     * @return an Iterator that may be used outside of this class
+     */
+    public static <E> Iterator<E> copyToExternallyUsuableIterator(Iterator<E> iter) {
+        return IteratorUtils.toList(iter).iterator();
+    }
+    
+    /**
+     * Returns the first element and exhausts an iterator
+     * 
+     * @param <E> the type of elements in the iterator
+     * @param iterator the iterator to exhaust
+     * @return the first element of the iterator; null if the iterator's empty
+     */
+    public static <E> E retrieveFirstAndExhaustIterator(Iterator<E> iterator) {
+        E returnVal = null;
+        if (iterator.hasNext()) {
+            returnVal = iterator.next();
+        }
+        exhaustIterator(iterator);
+        return returnVal;
+    }
+    
+    /**
+     * Exhausts (i.e. complete iterates through) an iterator
+     * 
+     * @param iterator
+     */
+    public static void exhaustIterator(Iterator<?> iterator) {
+        while (iterator.hasNext()) {
+            iterator.next();
+        }
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/TransactionalServiceUtils.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java
===================================================================
--- work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java	(revision 32237)
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.PBFactoryException;
+import org.apache.ojb.broker.PBKey;
+import org.apache.ojb.broker.PersistenceBrokerInternal;
+import org.apache.ojb.broker.core.PersistenceBrokerFactoryDefaultImpl;
+import org.apache.ojb.broker.core.PersistenceBrokerHandle;
+
+public class KualiPersistenceBrokerFactoryImpl extends PersistenceBrokerFactoryDefaultImpl {
+    private static final Logger LOG = Logger.getLogger(KualiPersistenceBrokerFactoryImpl.class);
+
+    /**
+     * @see org.apache.ojb.broker.core.PersistenceBrokerFactoryDefaultImpl#createPersistenceBroker(org.apache.ojb.broker.PBKey)
+     */
+    public PersistenceBrokerInternal createPersistenceBroker(PBKey pbKey) throws PBFactoryException {
+        PersistenceBrokerInternal pb = super.createPersistenceBroker(pbKey);
+
+        PersistenceBrokerHandle pbh = (PersistenceBrokerHandle) pb;
+        KualiPersistenceBrokerImpl realBroker = (KualiPersistenceBrokerImpl) pbh.getInnermostDelegate();
+
+        LOG.debug((realBroker.isFresh() ? "created " : "reusing ") + "persistence broker " + pb.getClass().getName() + "@" + pb.hashCode());
+
+        return pb;
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/KualiPersistenceBrokerFactoryImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java
===================================================================
--- work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java	(revision 0)
+++ work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java	(revision 32237)
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.util;
+
+import java.util.Properties;
+
+import org.apache.log4j.Logger;
+import org.apache.ojb.broker.Identity;
+import org.apache.ojb.broker.PersistenceBroker;
+import org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl;
+
+public class KualiObjectCachePerBrokerImpl extends ObjectCachePerBrokerImpl {
+    private static final Logger LOG = Logger.getLogger(KualiObjectCachePerBrokerImpl.class);
+
+
+    private final String brokerId;
+
+    public KualiObjectCachePerBrokerImpl(PersistenceBroker broker, Properties prop) {
+        super(broker, prop);
+        brokerId = broker.getClass().getName() + "@" + broker.hashCode();
+
+        LOG.debug("created objectCache for broker " + brokerId);
+    }
+
+    /**
+     * Clear ObjectCache. I.e. remove all entries for classes and objects.
+     */
+    public void clear() {
+        super.clear();
+
+        LOG.debug("cleared objectCache for broker " + brokerId);
+    }
+
+    /**
+     * @see org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl#cache(org.apache.ojb.broker.Identity, java.lang.Object)
+     */
+    public void cache(Identity oid, Object obj) {
+        super.cache(oid, obj);
+
+        boolean cached = (super.lookup(oid) != null);
+        LOG.debug((cached ? "cached oid " : "unable to cache oid ") + oid + " in objectCache for broker " + brokerId);
+    }
+
+    /**
+     * @see org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl#cacheIfNew(org.apache.ojb.broker.Identity, java.lang.Object)
+     */
+    public boolean cacheIfNew(Identity oid, Object obj) {
+        boolean cachedIfNew = super.cacheIfNew(oid, obj);
+
+        boolean cached = (super.lookup(oid) != null);
+        LOG.debug((cached ? "cached new oid " : "unable to cache new oid ") + oid + " in objectCache for broker " + brokerId);
+
+        return cachedIfNew;
+    }
+
+    /**
+     * @see org.apache.ojb.broker.cache.ObjectCachePerBrokerImpl#lookup(org.apache.ojb.broker.Identity)
+     */
+    public Object lookup(Identity oid) {
+        Object o = super.lookup(oid);
+
+        LOG.debug((o != null ? "found oid " : "cannot find oid ") + oid + " in objectCache for broker " + brokerId);
+
+        return o;
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/util/KualiObjectCachePerBrokerImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/krad/exception/InactiveDocumentTypeAuthorizationException.java
===================================================================
--- work/src/org/kuali/rice/krad/exception/InactiveDocumentTypeAuthorizationException.java	(revision 0)
+++ work/src/org/kuali/rice/krad/exception/InactiveDocumentTypeAuthorizationException.java	(revision 32237)
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2006-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.krad.exception;
+
+import org.kuali.rice.core.api.util.RiceKeyConstants;
+
+import java.util.Collections;
+
+/**
+ * This class represents an exception that is thrown when a given user is not authorized to take a given action on the given
+ * document type.
+ * 
+ * 
+ */
+public class InactiveDocumentTypeAuthorizationException extends DocumentTypeAuthorizationException {
+    private static final long serialVersionUID = 1L;
+
+    public InactiveDocumentTypeAuthorizationException(String action, String documentType) {
+        super("anybody", action, documentType, Collections.<String, Object>emptyMap());
+    }
+
+    /**
+     * @see AuthorizationException#getErrorMessageKey()
+     */
+    public String getErrorMessageKey() {
+        return RiceKeyConstants.AUTHORIZATION_ERROR_INACTIVE_DOCTYPE;
+    }
+}

Property changes on: work/src/org/kuali/rice/krad/exception/InactiveDocumentTypeAuthorizationException.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/impl/parameter/AlwaysSucceedParameterEvaluatorImpl.java
===================================================================
--- work/src/org/kuali/rice/core/impl/parameter/AlwaysSucceedParameterEvaluatorImpl.java	(revision 0)
+++ work/src/org/kuali/rice/core/impl/parameter/AlwaysSucceedParameterEvaluatorImpl.java	(revision 32237)
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2007-2009 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.impl.parameter;
+
+
+import org.kuali.rice.core.api.parameter.ParameterEvaluator;
+
+/**
+ * This implementation of ParameterEvaluator is returned by ParameterServiceImpl when evaluation involves a constraining value and
+ * neither the allow nor deny parameter have restrictions for that value.
+ */
+public class AlwaysSucceedParameterEvaluatorImpl implements ParameterEvaluator {
+    private static final AlwaysSucceedParameterEvaluatorImpl instance = new AlwaysSucceedParameterEvaluatorImpl();
+
+    public static ParameterEvaluator getInstance() {
+        return instance;
+    }
+
+    private AlwaysSucceedParameterEvaluatorImpl() {
+    }
+
+    public boolean constraintIsAllow() {
+        return Boolean.TRUE;
+    }
+
+
+    public boolean evaluateAndAddError(Class businessObjectOrDocumentClass, String constrainedPropertyName, String userEditablePropertyName) {
+        return evaluationSucceeds();
+    }
+
+    public boolean evaluateAndAddError(Class businessObjectOrDocumentClass, String constrainedPropertyName) {
+        return evaluationSucceeds();
+    }
+
+    public boolean evaluationSucceeds() {
+        return Boolean.TRUE;
+    }
+
+    public String getName() {
+        return AlwaysSucceedParameterEvaluatorImpl.class.getName();
+    }
+
+    public String getParameterValuesForMessage() {
+        return AlwaysSucceedParameterEvaluatorImpl.class.getName();
+    }
+
+    public String getValue() {
+        return AlwaysSucceedParameterEvaluatorImpl.class.getName();
+    }
+
+    public void setConstrainedValue(String constrainedValue) {
+    }
+}

Property changes on: work/src/org/kuali/rice/core/impl/parameter/AlwaysSucceedParameterEvaluatorImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorImpl.java
===================================================================
--- work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorImpl.java	(revision 0)
+++ work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorImpl.java	(revision 32237)
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2007-2009 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.impl.parameter;
+
+import org.kuali.rice.core.api.parameter.Parameter;
+import org.kuali.rice.core.api.parameter.ParameterEvaluator;
+import org.kuali.rice.core.api.util.RiceKeyConstants;
+import org.kuali.rice.krad.service.DataDictionaryService;
+import org.kuali.rice.krad.service.KRADServiceLocatorWeb;
+import org.kuali.rice.krad.util.GlobalVariables;
+
+import java.util.List;
+
+public class ParameterEvaluatorImpl implements ParameterEvaluator {
+	private static final long serialVersionUID = -758645169354452022L;
+	private Parameter parameter;
+	private boolean constraintIsAllow;
+	private String constrainedValue;
+	private List<String> values;
+
+	private static DataDictionaryService dataDictionaryService;
+	
+	/**
+	 * If the constraint is allow and the constrainedValue is in the list of
+	 * allowed values specified by the parameter this will return true, and if
+	 * the constraint is deny and the constrainedValue is not in the list of
+	 * denied values specified by the parameter this method will return true.
+	 * 
+	 * @return boolean indicating whether the constrained value adheres to the
+	 *         restriction specified by the combination of the parameter
+	 *         constraint and the parameter value
+	 */
+	public boolean evaluationSucceeds() {
+		if (constraintIsAllow()) {
+			return values.contains(constrainedValue);
+		} else {
+			return !values.contains(constrainedValue);
+		}
+	}
+
+	public boolean evaluateAndAddError(Class<? extends Object> businessObjectOrDocumentClass, String constrainedPropertyName) {
+		return evaluateAndAddError(businessObjectOrDocumentClass, constrainedPropertyName, constrainedPropertyName);
+	}
+
+	/**
+	 * This method uses the evaluationSucceeds method to evaluate the
+	 * constrainedValue. If evaluation does not succeed, it adds an error to
+	 * GlobalVariables.getErrorMap(). The businessObjectOrDocumentClass,
+	 * nameOfConstrainedProperty and userEditablePropertyName are used to
+	 * retrieve the appropriate labels from the DataDictionary.
+	 * 
+	 * @param businessObjectOrDocumentClass
+	 * @return boolean indicating whether evaluation succeeded (see
+	 *         evaluationSucceeds)
+	 */
+	public boolean evaluateAndAddError(Class<? extends Object> businessObjectOrDocumentClass,
+			String constrainedPropertyName, String userEditablePropertyName) {
+		if (!evaluationSucceeds()) {
+			GlobalVariables.getMessageMap().putError(
+					userEditablePropertyName,
+					constraintIsAllow() ? RiceKeyConstants.ERROR_DOCUMENT_INVALID_VALUE_ALLOWED_VALUES_PARAMETER : RiceKeyConstants.ERROR_DOCUMENT_INVALID_VALUE_DENIED_VALUES_PARAMETER,
+					new String[] {
+							getDataDictionaryService().getAttributeLabel( businessObjectOrDocumentClass, constrainedPropertyName),
+							constrainedValue,
+							toStringForMessage(),
+							getParameterValuesForMessage(),
+							getDataDictionaryService().getAttributeLabel( businessObjectOrDocumentClass, userEditablePropertyName) 
+							} );
+			return false;
+		}
+		return true;
+	}
+
+	public boolean constraintIsAllow() {
+		return constraintIsAllow;
+	}
+
+	/**
+	 * This method uses the List toString method and eliminates the [].
+	 * 
+	 * @return user-friendly String representation of Parameter values
+	 */
+	public String getParameterValuesForMessage() {
+		return values.toString().replace("[", "").replace("]", "");
+	}
+
+	public String getValue() {
+		return parameter.getValue();
+	}
+
+	public String toString() {
+		return new StringBuffer("ParameterEvaluator").append("\n\tParameter: ")
+				.append("module=").append(parameter.getNamespaceCode())
+				.append(", component=").append(parameter.getComponentCode())
+				.append(", name=").append(parameter.getName())
+				.append(", value=").append(parameter.getValue())
+				.append("\n\tConstraint Is Allow: ").append(constraintIsAllow)
+				.append("\n\tConstrained Value: ").append(constrainedValue)
+				.append("\n\tValues: ").append(values.toString())
+				.toString();
+	}
+
+	private String toStringForMessage() {
+		return new StringBuffer("parameter: ").append(parameter.getName())
+				.append(", module: ").append(parameter.getNamespaceCode())
+				.append(", component: ").append(parameter.getComponentCode())
+				.toString();
+	}
+
+	public String getModuleAndComponent() {
+		return parameter.getNamespaceCode() + ": " + parameter.getComponentCode();
+	}
+
+	public void setConstrainedValue(String constrainedValue) {
+		this.constrainedValue = constrainedValue;
+	}
+
+	public void setConstraintIsAllow(boolean constraintIsAllow) {
+		this.constraintIsAllow = constraintIsAllow;
+	}
+
+	public void setParameter(Parameter parameter) {
+		this.parameter = parameter;
+	}
+
+	public void setValues(List<String> values) {
+		this.values = values;
+	}
+
+	/**
+	 * @return the dataDictionaryService
+	 */
+	protected DataDictionaryService getDataDictionaryService() {
+		if ( dataDictionaryService == null ) {
+			dataDictionaryService = KRADServiceLocatorWeb.getDataDictionaryService();
+		}
+		return dataDictionaryService;
+	}
+}

Property changes on: work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorServiceImpl.java	(revision 32237)
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2006-2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.kuali.rice.core.impl.parameter;
+
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.parameter.EvaluationOperator;
+import org.kuali.rice.core.api.parameter.Parameter;
+import org.kuali.rice.core.api.parameter.ParameterEvaluator;
+import org.kuali.rice.core.api.parameter.ParameterEvaluatorService;
+import org.kuali.rice.core.framework.parameter.ParameterService;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+public class ParameterEvaluatorServiceImpl implements ParameterEvaluatorService {
+
+    private ParameterService parameterService;
+
+    public void setParameterService(ParameterService parameterService) {
+        this.parameterService = parameterService;
+    }
+
+    /**
+	 * This method will return an instance of the parameterEvaluator bean defined in Spring, initialized with the Parameter
+	 * corresponding to the specified componentClass and parameterName and the values of the Parameter.
+	 *
+	 * @param componentClass
+	 * @param parameterName
+	 * @return ParameterEvaluator instance initialized with the Parameter corresponding to the specified componentClass and
+	 *         parameterName and the values of the Parameter
+	 */
+	@Override
+	public ParameterEvaluator getParameterEvaluator(Class componentClass, String parameterName) {
+	    return getParameterEvaluator(parameterService.getParameter(componentClass, parameterName));
+	}
+
+	/**
+     * This method will return an instance of the parameterEvaluator bean defined in Spring, initialized with the Parameter
+     * corresponding to the specified componentClass and parameterName and the values of the Parameter.
+     *
+     * @param namespaceCode
+     * @param detailTypeCode
+     * @param parameterName
+     * @return ParameterEvaluator instance initialized with the Parameter corresponding to the specified componentClass and
+     *         parameterName and the values of the Parameter
+     */
+    @Override
+	public ParameterEvaluator getParameterEvaluator(String namespaceCode, String detailTypeCode, String parameterName) {
+        return getParameterEvaluator(parameterService.getParameter(namespaceCode, detailTypeCode, parameterName));
+    }
+
+	/**
+	 * This method will return an instance of the parameterEvaluator bean defined in Spring, initialized with the Parameter
+	 * corresponding to the specified componentClass and parameterName, the values of the Parameter, the knowledge of whether the
+	 * values are allowed or denied, and the constrainedValue.
+	 *
+	 * @param componentClass
+	 * @param parameterName
+	 * @return ParameterEvaluator instance initialized with the Parameter corresponding to the specified componentClass and
+	 *         parameterName, the values of the Parameter, the knowledge of whether the values are allowed or denied, and the
+	 *         constrainedValue
+	 */
+	@Override
+	public ParameterEvaluator getParameterEvaluator(Class componentClass, String parameterName, String constrainedValue) {
+	    return getParameterEvaluator(parameterService.getParameter(componentClass, parameterName), constrainedValue);
+	}
+
+	/**
+     * This method will return an instance of the parameterEvaluator bean defined in Spring, initialized with the Parameter
+     * corresponding to the specified componentClass and parameterName and the values of the Parameter.
+     *
+     * @param namespaceCode
+     * @param detailTypeCode
+     * @param parameterName
+     * @return ParameterEvaluator instance initialized with the Parameter corresponding to the specified componentClass and
+     *         parameterName and the values of the Parameter
+     */
+	@Override
+    public ParameterEvaluator getParameterEvaluator(String namespaceCode, String detailTypeCode, String parameterName, String constrainedValue) {
+        return getParameterEvaluator(parameterService.getParameter(namespaceCode, detailTypeCode, parameterName), constrainedValue);
+    }
+
+	/**
+	 * This method will return an instance of the parameterEvaluator bean defined in Spring, initialized with the Parameter
+	 * corresponding to the specified componentClass and parameterName, the values of the Parameter that correspond to the specified
+	 * constrainingValue, the knowledge of whether the values are allowed or denied, and the constrainedValue.
+	 *
+	 * @param componentClass
+	 * @param parameterName
+	 * @return ParameterEvaluator instance initialized with the Parameter corresponding to the specified componentClass and
+	 *         parameterName, the values of the Parameter that correspond to the specified constrainingValue, the knowledge of
+	 *         whether the values are allowed or denied, and the constrainedValue
+	 */
+	@Override
+	public ParameterEvaluator getParameterEvaluator(Class componentClass, String parameterName, String constrainingValue,
+			String constrainedValue) {
+			    return getParameterEvaluator(parameterService.getParameter(componentClass, parameterName), constrainingValue, constrainedValue);
+			}
+
+	/**
+	 * This method will return an instance of the parameterEvaluator bean defined in Spring, initialized with the Parameter
+	 * corresponding to the specified componentClass and allowParameterName or to the specified componentClass and denyParameterName
+	 * (depending on which restricts based on the constraining value) or an instance of AlwaysSucceedParameterEvaluatorImpl if
+	 * neither restricts, the values of the Parameter that correspond to the specified constrainingValue, the knowledge of whether
+	 * the values are allowed or denied, and the constrainedValue.
+	 *
+	 * @param componentClass
+	 * @param allowParameterName
+	 * @param denyParameterName
+	 * @param constrainingValue
+	 * @param constrainedValue
+	 * @return AlwaysSucceedParameterEvaluatorImpl or ParameterEvaluator instance initialized with the Parameter that corresponds to
+	 *         the constrainingValue restriction, the values of the Parameter that correspond to the specified constrainingValue,
+	 *         the knowledge of whether the values are allowed or denied, and the constrainedValue
+	 */
+	@Override
+	public ParameterEvaluator getParameterEvaluator(Class componentClass, String allowParameterName, String denyParameterName,
+			String constrainingValue, String constrainedValue) {
+			    Parameter allowParameter = parameterService.getParameter(componentClass, allowParameterName);
+			    Parameter denyParameter = parameterService.getParameter(componentClass, denyParameterName);
+			    if (!getParameterValues(allowParameter, constrainingValue).isEmpty() && !getParameterValues(denyParameter, constrainingValue).isEmpty()) {
+			        throw new IllegalArgumentException("The getParameterEvaluator(Class componentClass, String allowParameterName, String denyParameterName, String constrainingValue, String constrainedValue) method of ParameterServiceImpl does not facilitate evaluation of combination allow and deny parameters that both have values for the constraining value: " + allowParameterName + " / " + denyParameterName + " / " + constrainingValue);
+			    }
+			    if (getParameterValues(allowParameter, constrainingValue).isEmpty() && getParameterValues(denyParameter, constrainingValue).isEmpty()) {
+			        return AlwaysSucceedParameterEvaluatorImpl.getInstance();
+			    }
+			    return getParameterEvaluator(getParameterValues(denyParameter, constrainingValue).isEmpty() ? allowParameter : denyParameter, constrainingValue, constrainedValue);
+	}
+
+    protected List<String> getParameterValues(Parameter parameter, String constrainingValue) {
+	    List<String> constraintValuePairs = getParameterValues(parameter);
+	    for (String pair : constraintValuePairs) {
+	        if (StringUtils.equals(constrainingValue, StringUtils.substringBefore(pair, "="))) {
+	            return Arrays.asList(StringUtils.substringAfter(pair, "=").split(","));
+	        }
+	    }
+	    return Collections.emptyList();
+	}
+
+    private List<String> getParameterValues(Parameter parameter) {
+	    if (parameter == null || StringUtils.isBlank(parameter.getValue())) {
+	        return Collections.emptyList();
+	    }
+	    return Arrays.asList(parameter.getValue().split(";"));
+	}
+
+    protected ParameterEvaluatorImpl getParameterEvaluator(Parameter parameter) {
+	    ParameterEvaluatorImpl parameterEvaluator = new ParameterEvaluatorImpl();
+	    parameterEvaluator.setParameter(parameter);
+	    parameterEvaluator.setConstraintIsAllow(constraintIsAllow(parameter));
+	    parameterEvaluator.setValues(getParameterValues(parameter));
+	    return parameterEvaluator;
+	}
+
+	protected ParameterEvaluatorImpl getParameterEvaluator(Parameter parameter, String constrainedValue) {
+	    ParameterEvaluatorImpl parameterEvaluator = getParameterEvaluator(parameter);
+	    parameterEvaluator.setConstrainedValue(constrainedValue);
+	    return parameterEvaluator;
+	}
+
+	protected ParameterEvaluatorImpl getParameterEvaluator(Parameter parameter, String constrainingValue,
+			String constrainedValue) {
+	    ParameterEvaluatorImpl parameterEvaluator = getParameterEvaluator(parameter, constrainedValue);
+	    parameterEvaluator.setValues(getParameterValues(parameter, constrainingValue));
+	    return parameterEvaluator;
+	}
+
+    private boolean constraintIsAllow(Parameter parameter) {
+	    return EvaluationOperator.ALLOW.equals(parameter.getEvaluationOperator());
+	}
+}

Property changes on: work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/impl/jaxb/DataXmlDTO.java
===================================================================
--- work/src/org/kuali/rice/core/impl/jaxb/DataXmlDTO.java	(revision 0)
+++ work/src/org/kuali/rice/core/impl/jaxb/DataXmlDTO.java	(revision 32237)
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.impl.jaxb;
+
+import java.util.List;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAnyElement;
+import javax.xml.bind.annotation.XmlElement;
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.XmlType;
+
+import org.kuali.rice.core.api.CoreConstants;
+import org.kuali.rice.core.api.mo.AbstractDataTransferObject;
+import org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener;
+import org.kuali.rice.kim.impl.jaxb.PermissionDataXmlDTO;
+import org.kuali.rice.kim.impl.jaxb.RoleDataXmlDTO;
+import org.w3c.dom.Element;
+
+/**
+ * This class represents the root &lt;data&gt; XML element.
+ * 
+ * <p>Please see the Javadocs for PermissionDataXmlDTO and RoleDataXmlDTO for more information
+ * on their expected structure.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlRootElement(name="data")
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="DataType", propOrder={"permissionData", "roleData", CoreConstants.CommonElements.FUTURE_ELEMENTS})
+public class DataXmlDTO  extends AbstractDataTransferObject implements RiceXmlListAdditionListener<Element> {
+
+    private static final long serialVersionUID = 1L;
+    
+    @XmlElement(name="permissionData")
+    private PermissionDataXmlDTO permissionData;
+    
+    @XmlElement(name="roleData")
+    private RoleDataXmlDTO roleData;
+    
+    @XmlAnyElement
+    private final List<Element> _futureElements = null;
+    
+    public DataXmlDTO() {}
+    
+    public DataXmlDTO(PermissionDataXmlDTO permissionData, RoleDataXmlDTO roleData) {
+        this.permissionData = permissionData;
+        this.roleData = roleData;
+    }
+
+    /**
+     * @return the permissionData
+     */
+    public PermissionDataXmlDTO getPermissionData() {
+        return this.permissionData;
+    }
+
+    /**
+     * @param permissionData the permissionData to set
+     */
+    public void setPermissionData(PermissionDataXmlDTO permissionData) {
+        this.permissionData = permissionData;
+    }
+
+    /**
+     * @return the roleData
+     */
+    public RoleDataXmlDTO getRoleData() {
+        return this.roleData;
+    }
+
+    /**
+     * @param roleData the roleData to set
+     */
+    public void setRoleData(RoleDataXmlDTO roleData) {
+        this.roleData = roleData;
+    }
+
+    /**
+     * @see org.kuali.rice.core.util.jaxb.RiceXmlListAdditionListener#newItemAdded(java.lang.Object)
+     */
+    @Override
+    public void newItemAdded(Element item) {
+        // Do nothing; this class just implements the streaming unmarshalling listener so that it doesn't hold onto all the DOM elements.
+    }
+}

Property changes on: work/src/org/kuali/rice/core/impl/jaxb/DataXmlDTO.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/impl/jaxb/package-info.java
===================================================================
--- work/src/org/kuali/rice/core/impl/jaxb/package-info.java	(revision 0)
+++ work/src/org/kuali/rice/core/impl/jaxb/package-info.java	(revision 32237)
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2006-2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.xml.bind.annotation.XmlSchema(namespace = CoreConstants.Namespaces.CORE_NAMESPACE_2_0, elementFormDefault = XmlNsForm.QUALIFIED)
+package org.kuali.rice.core.impl.jaxb;
+
+import javax.xml.bind.annotation.XmlNsForm;
+
+import org.kuali.rice.core.api.CoreConstants;

Property changes on: work/src/org/kuali/rice/core/impl/jaxb/package-info.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/api/parameter/ParameterEvaluator.java
===================================================================
--- work/src/org/kuali/rice/core/api/parameter/ParameterEvaluator.java	(revision 0)
+++ work/src/org/kuali/rice/core/api/parameter/ParameterEvaluator.java	(revision 32237)
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2007-2009 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.api.parameter;
+
+import java.io.Serializable;
+
+/**
+ * This is a stateful wrapper for Parameters, which provides convenient methods to evaluate a constrained value against a Parameter.
+ */
+public interface ParameterEvaluator extends Serializable {
+    /**
+     * This method determines whether the constrainedValue specified when the ParameterEvaluator was created matches the parameter.
+     * 
+     * @return boolean indicating whether the constrained value adheres to the restriction specified by the combination of the
+     *         parameter constraint and the parameter value
+     */
+    public boolean evaluationSucceeds();
+
+    /**
+     * This method uses the evaluateAndAddError method. It passes the constrainedPropertyName as both the constrainedPropertyName
+     * and the userEditablePropertyName, i.e. it should be used when they are one and the same.
+     * 
+     * @param businessObjectOrDocumentClass
+     * @param constrainedPropertyName
+     * @return boolean indicating whether evaluation succeeded (see evaluationSucceeds)
+     */
+    public boolean evaluateAndAddError(Class<? extends Object> businessObjectOrDocumentClass, String constrainedPropertyName);
+
+    /**
+     * This method uses the evaluationSucceeds method to evaluate the constrainedValue. If evaluation does not succeed, it adds an
+     * error for the user. The businessObjectOrDocumentClass, nameOfConstrainedProperty and userEditablePropertyName are used by
+     * ParameterEvaluatorImpl to retrieve user friendly labels for the error message. The constrainedPropertyName corresponds to the
+     * field that has the value that the parameter is evaluating. The userEditablePropertyName corresponds to the field that has the
+     * value the user needs to correct to resolve the error. For example, the object type may be invalid, but the user needs to
+     * change the object code in order to remedy that.
+     * 
+     * @param businessObjectOrDocumentClass
+     * @param userEditableFieldToHighlight
+     * @param nameOfconstrainedProperty
+     * @return boolean indicating whether evaluation succeeded (see evaluationSucceeds)
+     */
+    public boolean evaluateAndAddError(Class<? extends Object> businessObjectOrDocumentClass, String constrainedPropertyName, String userEditablePropertyName);
+
+    /**
+     * This method determines whether the parameter lists allowed values or denied values.
+     * 
+     * @return boolean indicating whether the parameter lists allowed values
+     */
+    public boolean constraintIsAllow();
+
+    /**
+     * This method creates a pretty String representation of parameter values for the user messages.
+     *
+     * @return user-friendly String representation of Parameter values
+     */
+    public String getParameterValuesForMessage();
+
+    /**
+     * This method returns the value of the correspnding Parameter.
+     * 
+     * @return String value of underlying Parameter
+     */
+    public String getValue();
+}

Property changes on: work/src/org/kuali/rice/core/api/parameter/ParameterEvaluator.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/api/parameter/ParameterEvaluatorService.java
===================================================================
--- work/src/org/kuali/rice/core/api/parameter/ParameterEvaluatorService.java	(revision 0)
+++ work/src/org/kuali/rice/core/api/parameter/ParameterEvaluatorService.java	(revision 32237)
@@ -0,0 +1,65 @@
+package org.kuali.rice.core.api.parameter;
+
+public interface ParameterEvaluatorService {
+        /**
+     * This method will return an instance of a ParameterEvaluator implementation that will wrap a Parameter and provide convenient
+     * evaluation methods.
+     *
+     * @param componentClass
+     * @param parameterName
+     * @return ParameterEvaluator
+     */
+    public ParameterEvaluator getParameterEvaluator(Class<? extends Object> componentClass, String parameterName);
+
+    /**
+     * This method will return an instance of a ParameterEvaluator implementation that will wrap a Parameter and provide convenient
+     * evaluation methods.
+     *
+     * @param namespaceCode
+     * @param detailTypeCode
+     * @param parameterName
+     * @return ParameterEvaluator
+     */
+    public ParameterEvaluator getParameterEvaluator(String namespaceCode, String detailTypeCode, String parameterName);
+
+    /**
+     * This method will return an instance of a ParameterEvaluator implementation that will wrap a Parameter and constrainedValue
+     * and provide convenient evaluation methods.
+     *
+     * @param componentClass
+     * @param parameterName
+     * @return ParameterEvaluator
+     */
+    public ParameterEvaluator getParameterEvaluator(Class<? extends Object> componentClass, String parameterName, String constrainedValue);
+
+    /**
+     * This method will return an instance of a ParameterEvaluator implementation that will wrap a Parameter and constrainedValue
+     * and provide convenient evaluation methods.
+     *
+     * @param namespaceCode
+     * @param detailTypeCode
+     * @param parameterName
+     * @return ParameterEvaluator
+     */
+    public ParameterEvaluator getParameterEvaluator(String namespaceCode, String detailTypeCode, String parameterName, String constrainedValue);
+
+    /**
+     * This method will return an instance of a ParameterEvaluator implementation that will wrap a Parameter, constrainingValue, and
+     * constrainedValue and provide convenient evaluation methods.
+     *
+     * @param componentClass
+     * @param parameterName
+     * @return ParameterEvaluator
+     */
+    public ParameterEvaluator getParameterEvaluator(Class<? extends Object> componentClass, String parameterName, String constrainingValue, String constrainedValue);
+
+    /**
+     * This method will return an instance of a ParameterEvaluator implementation that will wrap an allow Parameter, a deny
+     * Parameter, constrainingValue, and constrainedValue and provide convenient evaluation methods.
+     *
+     * @param componentClass
+     * @param parameterName
+     * @return ParameterEvaluator
+     */
+    public ParameterEvaluator getParameterEvaluator(Class<? extends Object> componentClass, String allowParameterName, String denyParameterName, String constrainingValue, String constrainedValue);
+}

Property changes on: work/src/org/kuali/rice/core/api/parameter/ParameterEvaluatorService.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePairValidatingAdapter.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePairValidatingAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePairValidatingAdapter.java	(revision 32237)
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import javax.xml.bind.MarshalException;
+import javax.xml.bind.UnmarshalException;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.CoreApiServiceLocator;
+
+/**
+ * An XML adapter that simply validates the NameAndNamespacePair to ensure that the name and namespace are non-blank
+ * and that the namespace code maps to a valid namespace in the system. This adapter will also pass the name to
+ * a NormalizedStringAdapter instance for marshalling/unmarshalling.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class NameAndNamespacePairValidatingAdapter extends XmlAdapter<NameAndNamespacePair,NameAndNamespacePair> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public NameAndNamespacePair unmarshal(NameAndNamespacePair v) throws Exception {
+        if (v != null) {
+            
+            if (StringUtils.isBlank(v.getName())) {
+                throw new UnmarshalException("Cannot import a name-and-namespace pair with a blank name");
+            } else if (StringUtils.isBlank(v.getNamespaceCode())) {
+                throw new UnmarshalException("Cannot import a name-and-namespace pair with a blank namespace code");
+            } if (CoreApiServiceLocator.getNamespaceService().getNamespace(v.getNamespaceCode()) == null) {
+                throw new UnmarshalException("Cannot import a name-and-namespace pair with invalid or unknown namespace \"" +
+                        v.getNamespaceCode() + "\"");
+            }
+            
+            v.setName(new NormalizedStringAdapter().unmarshal(v.getName()));
+            v.setNamespaceCode(v.getNamespaceCode());
+        }
+        return v;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public NameAndNamespacePair marshal(NameAndNamespacePair v) throws Exception {
+        if (v != null) {
+            if (StringUtils.isBlank(v.getName())) {
+                throw new MarshalException("Cannot export a name-and-namespace pair with a blank name");
+            } else if (StringUtils.isBlank(v.getNamespaceCode())) {
+                throw new MarshalException("Cannot export a name-and-namespace pair with a blank namespace code");
+            } else if (CoreApiServiceLocator.getNamespaceService().getNamespace(v.getNamespaceCode()) == null) {
+                throw new MarshalException("Cannot export a name-and-namespace pair with invalid or unknown namespace \"" + v.getNamespaceCode() + "\"");
+            }
+            
+            v.setName(new NormalizedStringAdapter().marshal(v.getName()));
+            v.setNamespaceCode(v.getNamespaceCode());
+        }
+        return v;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePairValidatingAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/RiceXmlListGetterListener.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/RiceXmlListGetterListener.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/RiceXmlListGetterListener.java	(revision 32237)
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import java.io.Serializable;
+
+/**
+ * Helper interface for use with the RiceXmlExportList class.
+ * 
+ * <p>If semi-"streaming" of child elements is desired during JAXB marshalling, then the parent element
+ * assigns an instance of RiceXmlExportList to the appropriate list field/property, and gives the
+ * list an implementation of this interface for the list to invoke whenever it needs to create a new
+ * instance of the next child element. This allows the implementation to create and then discard
+ * child elements during marshalling.
+ * 
+ * @param E The type that the list is expected to return.
+ * @param T The type that the list stores internally and passes to the listener for conversion as needed.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public interface RiceXmlListGetterListener<E,T> extends Serializable {
+        /**
+         * A listener method that converts the given item into the one expected by the list. It is invoked
+         * whenever the associated list's "get" method is called.
+         * 
+         * @param nextItem The item to convert.
+         * @param index The index being accessed on the RiceXmlExportList instance.
+         * @return The converted element that the list is expected to return.
+         */
+        public E gettingNextItem(T nextItem, int index);
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/RiceXmlListGetterListener.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/RiceXmlExportList.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/RiceXmlExportList.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/RiceXmlExportList.java	(revision 32237)
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import java.io.Serializable;
+import java.util.AbstractList;
+import java.util.List;
+
+/**
+ * Custom subclass of AbstractList that, whenever the "get" method is called, will pass an
+ * internally-stored list's object to the given listener for conversion into another object matching
+ * the list's type. This allows for the marshalling process to discard generated items after they
+ * have been marshalled.
+ * 
+ * <p>These lists are constructed by passing in another list containing the unconverted items,
+ * as well as a listener that will create items of this list's type upon each invocation of
+ * the "get" method.
+ * 
+ * <p>This is similar to the "streaming" unmarshalling strategy used in the RiceXmlImportList
+ * class, except that this list has been adapted for marshalling instead.
+ * 
+ * @param E The type that the list is expected to return.
+ * @param T The type that the list stores internally and passes to the listener for conversion as needed. 
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class RiceXmlExportList<E,T> extends AbstractList<E> implements Serializable {
+
+    private static final long serialVersionUID = 1L;
+    
+    private final List<? extends T> sourceList;
+    private final RiceXmlListGetterListener<E,T> listGetterListener;
+    
+    /**
+     * Constructs a new export list that will rely on the given listener for converting the provided
+     * list's items into the appropriate type.
+     * 
+     * @param sourceList The list of objects to convert.
+     * @param listGetterListener The listener to use.
+     * @throws IllegalArgumentException if sourceList or listGetterListener are null.
+     */
+    public RiceXmlExportList(List<? extends T> sourceList, RiceXmlListGetterListener<E,T> listGetterListener) {
+        super();
+        if (sourceList == null) {
+            throw new IllegalArgumentException("sourceList cannot be null");
+        } else if (listGetterListener == null) {
+            throw new IllegalArgumentException("listGetterListener cannot be null");
+        }
+        this.sourceList = sourceList;
+        this.listGetterListener = listGetterListener;
+    }
+    
+    /**
+     * Passes the item at the given index of the internal list to the listener, and then returns
+     * the listener's result.
+     * 
+     * @param index The unconverted item's index in the internal list.
+     * @return The item converted by the listener at the given list index.
+     */
+    @Override
+    public E get(int index) {
+        return listGetterListener.gettingNextItem(sourceList.get(index), index);
+    }
+
+    /**
+     * Returns the size of the internal list.
+     * 
+     * @return The size of the internal list.
+     */
+    @Override
+    public int size() {
+        return sourceList.size();
+    }
+
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/RiceXmlExportList.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/RiceXmlListAdditionListener.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/RiceXmlListAdditionListener.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/RiceXmlListAdditionListener.java	(revision 32237)
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import java.io.Serializable;
+
+/**
+ * Helper interface for use with the RiceXmlStreamingList class.
+ * 
+ * <p>If "streaming" of child elements is desired during JAXB unmarshalling, then the parent element
+ * assigns an instance of RiceXmlStreamingList to the appropriate list field/property, and gives the
+ * list an implementation of this interface for the list to invoke whenever it receives a 
+ * newly-unmarshalled child element. This allows the implementation to process the new element and then
+ * discard it.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public interface RiceXmlListAdditionListener<T> extends Serializable {
+    /**
+     * This method is invoked whenever the associated RiceXmlStreamingList instance receives
+     * a newly-unmarshalled child element.
+     * 
+     * @param item The unmarshalled element (or adapter-generated object) to be processed.
+     */
+    public void newItemAdded(T item);
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/RiceXmlListAdditionListener.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/JaxbDateAdapter.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/JaxbDateAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/JaxbDateAdapter.java	(revision 32237)
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2007-2009 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import java.util.Date;
+
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+/**
+ * Marshall/unmarshall java.util.Date
+ * 
+ * @author Kuali Rice Team (kuali-rice@googlegroups.com)
+ *
+ */
+public class JaxbDateAdapter extends XmlAdapter<String, Date> {
+
+	/**
+	 * This overridden method ...
+	 * 
+	 * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+	 */
+	@Override
+	public String marshal(Date date) throws Exception {
+		return (null != date ? Long.toString(date.getTime()) : null);
+	}
+
+	/**
+	 * This overridden method ...
+	 * 
+	 * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+	 */
+	@Override
+	public Date unmarshal(String dateStr) throws Exception {
+		return (null != dateStr ? new Date(Long.parseLong(dateStr)) : null);
+	}
+
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/JaxbDateAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/package-info.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/package-info.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/package-info.java	(revision 32237)
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2006-2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@javax.xml.bind.annotation.XmlSchema(namespace = CoreConstants.Namespaces.CORE_NAMESPACE_2_0, elementFormDefault = XmlNsForm.QUALIFIED)
+package org.kuali.rice.core.util.jaxb;
+import javax.xml.bind.annotation.XmlNsForm;
+
+import org.kuali.rice.core.api.CoreConstants;
\ No newline at end of file

Property changes on: work/src/org/kuali/rice/core/util/jaxb/package-info.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/StringToDateTimeAdapter.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/StringToDateTimeAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/StringToDateTimeAdapter.java	(revision 32237)
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import java.util.Date;
+
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.api.CoreApiServiceLocator;
+
+/**
+ * An XML Adapter that relies on the DateTimeService to marshal and unmarshal datetime values in String form.
+ * Converts Strings to java.util.Date instances and vice versa.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class StringToDateTimeAdapter extends XmlAdapter<String,Date> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public Date unmarshal(String v) throws Exception {
+        return (v != null) ? CoreApiServiceLocator.getDateTimeService().convertToDateTime(StringUtils.trim(v)) : null;
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public String marshal(Date v) throws Exception {
+        return (v != null) ? CoreApiServiceLocator.getDateTimeService().toDateTimeString(v) : null;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/StringToDateTimeAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/RiceXmlImportList.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/RiceXmlImportList.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/RiceXmlImportList.java	(revision 32237)
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import java.io.Serializable;
+import java.util.AbstractList;
+
+/**
+ * Custom subclass of AbstractList that, when adding new items, will pass them on to a listener instead of
+ * storing them internally.
+ * 
+ * <p>This is based off of the JAXB "streaming" unmarshalling strategy, which is briefly mentioned here:
+ * 
+ * <p>http://jaxb.java.net/guide/Dealing_with_large_documents.html
+ * 
+ * <p>and is presented in the example code available here:
+ * 
+ * <p>http://jaxb.java.net/2.2.4/
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public final class RiceXmlImportList<E> extends AbstractList<E> implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+    
+    /** The listener that this list will pass new items to. */
+    private final RiceXmlListAdditionListener<E> listAdditionListener;
+    
+    /**
+     * Constructs a new streaming list that will pass new items to the given listener instead of storing them.
+     * 
+     * @param listAdditionListener The listener to use.
+     * @throws IllegalArgumentException if listAdditionListener is null.
+     */
+    public RiceXmlImportList(RiceXmlListAdditionListener<E> listAdditionListener) {
+        super();
+        if (listAdditionListener == null) {
+            throw new IllegalArgumentException("listAdditionListener cannot be null");
+        }
+        this.listAdditionListener = listAdditionListener;
+    }
+    
+    /**
+     * Instead of adding the item to the list, simply invoke the appropriate listener.
+     * 
+     * <p>This is based off of the "streaming" unmarshalling strategy used in one of the JAXB sample apps.
+     * 
+     * @return false, since the list never gets altered as a result of invoking this method.
+     */
+    @Override
+    public boolean add(E e) {
+        listAdditionListener.newItemAdded(e);
+        return false;
+    }
+    
+    /**
+     * This method always throws an exception, since the list never contains any items.
+     * 
+     * @throws IndexOutOfBoundsException
+     */
+    @Override
+    public E get(int index) {
+        throw new IndexOutOfBoundsException();
+    }
+
+    /**
+     * This method always returns zero, since items are never actually added to the list.
+     * 
+     * @return zero.
+     */
+    @Override
+    public int size() {
+        return 0;
+    }
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/RiceXmlImportList.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePair.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePair.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePair.java	(revision 32237)
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import java.io.Serializable;
+
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlAttribute;
+import javax.xml.bind.annotation.XmlType;
+import javax.xml.bind.annotation.XmlValue;
+import javax.xml.bind.annotation.adapters.NormalizedStringAdapter;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+
+/**
+ * An XML element that stores a name and namespace pair in its simple content and "namespaceCode" attribute.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+@XmlAccessorType(XmlAccessType.FIELD)
+@XmlType(name="NameAndNamespaceType")
+public class NameAndNamespacePair implements Serializable {
+    
+    private static final long serialVersionUID = 1L;
+
+    @XmlAttribute(name="namespaceCode", required=true)
+    @XmlJavaTypeAdapter(NormalizedStringAdapter.class)
+    private String namespaceCode;
+    
+    @XmlValue
+    private String name;
+    
+    public NameAndNamespacePair() {}
+    
+    public NameAndNamespacePair(String namespaceCode, String name) {
+        this.namespaceCode = namespaceCode;
+        this.name = name;
+    }
+    
+    public String getNamespaceCode() {
+        return namespaceCode;
+    }
+
+    public void setNamespaceCode(String namespaceCode) {
+        this.namespaceCode = namespaceCode;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/NameAndNamespacePair.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/core/util/jaxb/StringTrimmingAdapter.java
===================================================================
--- work/src/org/kuali/rice/core/util/jaxb/StringTrimmingAdapter.java	(revision 0)
+++ work/src/org/kuali/rice/core/util/jaxb/StringTrimmingAdapter.java	(revision 32237)
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2011 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.core.util.jaxb;
+
+import javax.xml.bind.annotation.adapters.XmlAdapter;
+
+import org.apache.commons.lang.StringUtils;
+
+/**
+ * An XML adapter that simply performs a null-safe trim on the value to be marshalled or unmarshalled.
+ * 
+ * <p>Only use this adapter when it is necessary for the remaining whitespace-related characters to
+ * remain as-is.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ */
+public class StringTrimmingAdapter extends XmlAdapter<String,String> {
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal(java.lang.Object)
+     */
+    @Override
+    public String unmarshal(String v) throws Exception {
+        return StringUtils.trim(v);
+    }
+
+    /**
+     * @see javax.xml.bind.annotation.adapters.XmlAdapter#marshal(java.lang.Object)
+     */
+    @Override
+    public String marshal(String v) throws Exception {
+        return StringUtils.trim(v);
+    }
+
+}

Property changes on: work/src/org/kuali/rice/core/util/jaxb/StringTrimmingAdapter.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java
===================================================================
--- work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java	(revision 32235)
+++ work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java	(revision 32237)
@@ -24,7 +24,7 @@
 import org.apache.ojb.broker.util.sequence.SequenceManager;
 import org.apache.ojb.broker.util.sequence.SequenceManagerException;
 import org.kuali.kfs.sys.context.PropertyLoadingFactoryBean;
-import org.kuali.rice.core.config.ConfigurationException;
+import org.kuali.rice.core.api.config.ConfigurationException;
 
 
 /**
Index: work/src/org/kuali/rice/kns/service/ConfigurableDateService.java
===================================================================
--- work/src/org/kuali/rice/kns/service/ConfigurableDateService.java	(revision 0)
+++ work/src/org/kuali/rice/kns/service/ConfigurableDateService.java	(revision 32237)
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.service;
+
+import java.util.Date;
+
+import org.kuali.rice.core.api.datetime.DateTimeService;
+
+/**
+ * This is a timeDateService that allows tests to specify the date/time they need to run. Set the currentDate property in this class
+ * before running your code under test and dateTimeService.getCurrentDate() will return the one you specify instead of the current
+ * date.
+ */
+public interface ConfigurableDateService extends DateTimeService {
+    public void setCurrentDate(Date currentDate);
+}

Property changes on: work/src/org/kuali/rice/kns/service/ConfigurableDateService.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java	(revision 0)
+++ work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java	(revision 32237)
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2007-2008 The Kuali Foundation
+ * 
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl2.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.service.impl;
+
+import java.util.Date;
+
+import org.kuali.rice.core.impl.datetime.DateTimeServiceImpl;
+import org.kuali.rice.kns.service.ConfigurableDateService;
+
+public class ConfigurableDateTimeServiceImpl extends DateTimeServiceImpl implements ConfigurableDateService {
+    protected Date currentDate;
+
+    /**
+     * Sets the currentDate attribute value.
+     * 
+     * @param currentDate The currentDate to set.
+     */
+    public void setCurrentDate(Date currentDate) {
+        this.currentDate = currentDate;
+    }
+
+    @Override
+    public Date getCurrentDate() {
+        return currentDate;
+    }
+}

Property changes on: work/src/org/kuali/rice/kns/service/impl/ConfigurableDateTimeServiceImpl.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java
===================================================================
--- work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java	(revision 32235)
+++ work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java	(revision 32237)
@@ -28,7 +28,8 @@
 import javax.servlet.http.HttpServletRequestWrapper;
 
 import org.kuali.rice.kew.util.KEWConstants;
-import org.kuali.rice.kew.web.session.UserSession;
+import org.kuali.rice.krad.UserSession;
+import org.kuali.rice.krad.util.KRADConstants;
 
 /**
  * A login filter which forwards to a login page that allows for the desired
@@ -69,9 +70,9 @@
 	public void destroy() {
 	}
 	public static UserSession getUserSession(HttpServletRequest request) {
-		return (UserSession) request.getSession().getAttribute(KEWConstants.USER_SESSION_KEY);
+		return (UserSession) request.getSession().getAttribute(KRADConstants.USER_SESSION_KEY);
 	}
 	public static boolean isUserSessionEstablished(HttpServletRequest request) {
-		return (request.getSession(false) != null && request.getSession(false).getAttribute(KEWConstants.USER_SESSION_KEY) != null);
+		return (request.getSession(false) != null && request.getSession(false).getAttribute(KRADConstants.USER_SESSION_KEY) != null);
 	}
 }
Index: build/properties/rice.properties
===================================================================
--- build/properties/rice.properties	(revision 32235)
+++ build/properties/rice.properties	(revision 32237)
@@ -24,7 +24,7 @@
 
 # Base Rice version properties
 rice.name=rice
-kfs.rice.version=1.0.3.3
+kfs.rice.version=2.0.0-b1
 rice.output.licenses.suffix=-licenses.zip
 rice.server.war.file.name.prefix=${rice.name}-web-
 rice.server.war.file.name=${rice.server.war.file.name.prefix}${kfs.rice.version}.war
Index: build/properties/build-foundation.properties
===================================================================
--- build/properties/build-foundation.properties	(revision 32235)
+++ build/properties/build-foundation.properties	(revision 32237)
@@ -22,7 +22,7 @@
 rice.sampleapp.module.name=sampleapp
 rice.output.src.suffix=-sources.jar
 rice.output.doc.suffix=-javadoc.jar
-rice.version=1.0.3.3-m2-SNAPSHOT
+rice.version=2.0.0-b1
 rice.war.file.name=${rice.name}-web-${rice.version}.war
 
 # paths used for pulling in rice changes using the KFS Ant script
@@ -30,4 +30,4 @@
 maven.home.directory=${base.directory}/tools/maven
 
 dependencies.project.directory=${projects.directory}/kfs-dependencies
-rice.project.directory=${projects.directory}/rice
+rice.project.directory=${projects.directory}/rice-20
