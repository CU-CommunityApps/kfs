Index: work/src/org/kuali/rice/kim/bo/types/dto/AttributeDefinitionMap.java
===================================================================
--- work/src/org/kuali/rice/kim/bo/types/dto/AttributeDefinitionMap.java	(revision 0)
+++ work/src/org/kuali/rice/kim/bo/types/dto/AttributeDefinitionMap.java	(revision 32263)
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2008-2009 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl2.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.bo.types.dto;
+
+import java.util.Map;
+import java.util.TreeMap;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.krad.datadictionary.AttributeDefinition;
+
+/**
+ * Specialization of HashMap to facilitate web services and simplify API definitions.
+ * 
+ * @author Kuali Rice Team (rice.collab@kuali.org)
+ *
+ */
+public class AttributeDefinitionMap extends TreeMap<String,AttributeDefinition> {
+
+	public AttributeDefinitionMap() {
+		super();
+	}
+	
+	public AttributeDefinitionMap( Map<String,AttributeDefinition> map ) {
+		super( map );
+	}
+	
+	public AttributeDefinition getByAttributeName(String attributeName) {
+		for (AttributeDefinition definition : values()) {
+			if (StringUtils.equals(attributeName, definition.getName())) 
+				return definition;
+		}
+		return null;
+	}
+}

Property changes on: work/src/org/kuali/rice/kim/bo/types/dto/AttributeDefinitionMap.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java	(revision 32242)
+++ work/src/org/kuali/rice/kim/service/impl/RoleManagementServiceImpl.java	(revision 32263)
@@ -1,415 +0,0 @@
-/*
- * Copyright 2007-2008 The Kuali Foundation
- *
- * Licensed under the Educational Community License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.opensource.org/licenses/ecl2.php
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kim.service.impl;
-
-import org.apache.commons.lang.exception.ExceptionUtils;
-import org.apache.log4j.Logger;
-import org.kuali.rice.kim.api.common.delegate.DelegateMember;
-import org.kuali.rice.kim.api.common.delegate.DelegateType;
-import org.kuali.rice.kim.api.role.Role;
-import org.kuali.rice.kim.api.role.RoleManagementService;
-import org.kuali.rice.kim.api.role.RoleMember;
-import org.kuali.rice.kim.api.role.RoleMembership;
-import org.kuali.rice.kim.api.role.RoleResponsibility;
-import org.kuali.rice.kim.api.role.RoleResponsibilityAction;
-import org.kuali.rice.kim.api.role.RoleService;
-import org.kuali.rice.kim.api.role.RoleUpdateService;
-import org.kuali.rice.kim.api.services.KimApiServiceLocator;
-
-import java.sql.Date;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * @author Kuali Rice Team (rice.collab@kuali.org)
- */
-public class RoleManagementServiceImpl implements RoleManagementService {
-    private static final Logger LOG = Logger.getLogger(RoleManagementServiceImpl.class);
-
-    private RoleService roleService;
-    private RoleUpdateService roleUpdateService;
-
-    @Override
-    public void flushRoleCaches() {
-        flushInternalRoleCache();
-        flushInternalRoleMemberCache();
-        flushInternalDelegationCache();
-        flushInternalDelegationMemberCache();
-    }
-
-    @Override
-    public void flushRoleMemberCaches() {
-        flushInternalRoleMemberCache();
-    }
-
-    @Override
-    public void flushDelegationCaches() {
-        flushInternalDelegationCache();
-        flushInternalDelegationMemberCache();
-    }
-
-    @Override
-    public void flushDelegationMemberCaches() {
-        flushInternalDelegationMemberCache();
-    }
-
-    @Override
-    public void removeCacheEntries(String roleId, String principalId) {
-
-    }
-
-    @Override
-    public Collection<String> getRoleMemberPrincipalIds(String namespaceCode, String roleName, Map<String, String> qualification) {
-        return getRoleService().getRoleMemberPrincipalIds(namespaceCode, roleName, qualification);
-    }
-
-    @Override
-    public Role getRole(String roleId) {
-        return getRoleService().getRole(roleId);
-    }
-
-    @Override
-    public Role getRoleByName(String namespaceCode, String roleName) {
-        return getRoleService().getRoleByName(namespaceCode, roleName);
-    }
-
-    @Override
-    public String getRoleIdByName(String namespaceCode, String roleName) {
-        Role role = getRoleByName(namespaceCode, roleName);
-        if (role == null) {
-            return null;
-        }
-        return role.getId();
-    }
-
-    @Override
-    public List<Role> getRoles(List<String> roleIds) {
-        return getRoleService().getRoles(roleIds);
-    }
-
-    @Override
-    public List<RoleMembership> getRoleMembers(List<String> roleIds, Map<String, String> qualification) {
-        return getRoleService().getRoleMembers(roleIds, qualification);
-    }
-
-    @Override
-    public List<Map<String, String>> getRoleQualifiersForPrincipal(String principalId, List<String> roleIds, Map<String, String> qualification) {
-        return getRoleService().getRoleQualifiersForPrincipal(principalId, roleIds, qualification);
-    }
-
-    @Override
-    public List<Map<String, String>> getRoleQualifiersForPrincipal(String principalId, String namespaceCode, String roleName, Map<String, String> qualification) {
-        return getRoleService().getRoleQualifiersForPrincipal(principalId, namespaceCode, roleName, qualification);
-    }
-
-    @Override
-    public boolean isRoleActive(String roleId) {
-        Role role = getRole(roleId);
-        return role != null && role.isActive();
-    }
-
-    @Override
-    public boolean principalHasRole(String principalId, List<String> roleIds, Map<String, String> qualification) {
-        if (LOG.isDebugEnabled()) {
-            logPrincipalHasRoleCheck(principalId, roleIds, qualification);
-        }
-        boolean hasRole =  getRoleService().principalHasRole(principalId, roleIds, qualification);
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("Result: " + hasRole);
-            }
-        return hasRole;
-    }
-
-    @Override
-    public List<String> getPrincipalIdSubListWithRole(
-            List<String> principalIds, String roleNamespaceCode,
-            String roleName, Map<String, String> qualification) {
-        return getRoleService().getPrincipalIdSubListWithRole(principalIds,
-                roleNamespaceCode, roleName, qualification);
-    }
-
-    @Override
-    public List<Map<String, String>> getNestedRoleQualifiersForPrincipal(String principalId, List<String> roleIds, Map<String, String> qualification) {
-        return getRoleService().getNestedRoleQualifiersForPrincipal(principalId, roleIds, qualification);
-    }
-
-    @Override
-    public List<Map<String, String>> getNestedRoleQualifiersForPrincipal(String principalId, String namespaceCode, String roleName, Map<String, String> qualification) {
-        return getRoleService().getNestedRoleQualifiersForPrincipal(principalId, namespaceCode, roleName, qualification);
-    }
-
-    @Override
-    public void assignGroupToRole(String groupId, String namespaceCode, String roleName,
-                                  Map<String, String> qualifications) {
-        getRoleUpdateService().assignGroupToRole(groupId, namespaceCode, roleName, qualifications);
-        Role role = getRoleByName(namespaceCode, roleName);
-        removeCacheEntries(role.getId(), null);
-    }
-
-    @Override
-    public void assignPrincipalToRole(String principalId, String namespaceCode, String roleName,
-                                      Map<String, String> qualifications) {
-        Role role = getRoleByName(namespaceCode, roleName);
-        getRoleUpdateService().assignPrincipalToRole(principalId, namespaceCode, roleName, qualifications);
-        removeCacheEntries(role.getId(), principalId);
-    }
-
-    @Override
-    public void removeGroupFromRole(String groupId, String namespaceCode, String roleName,
-                                    Map<String, String> qualifications) {
-        getRoleUpdateService().removeGroupFromRole(groupId, namespaceCode, roleName, qualifications);
-        Role role = getRoleByName(namespaceCode, roleName);
-        removeCacheEntries(role.getId(), null);
-    }
-
-    @Override
-    public void removePrincipalFromRole(String principalId, String namespaceCode, String roleName,
-                                        Map<String, String> qualifications) {
-        Role role = getRoleByName(namespaceCode, roleName);
-        getRoleUpdateService().removePrincipalFromRole(principalId, namespaceCode, roleName, qualifications);
-        removeCacheEntries(role.getId(), principalId);
-    }
-
-    @Override
-    public List<Role> getRolesSearchResults(
-            Map<String, String> fieldValues) {
-        return getRoleService().getRolesSearchResults(fieldValues);
-    }
-
-    protected void logPrincipalHasRoleCheck(String principalId, List<String> roleIds, Map<String, String> roleQualifiers) {
-        StringBuilder sb = new StringBuilder();
-        sb.append('\n');
-        sb.append("Has Role     : ").append(roleIds).append('\n');
-        if (roleIds != null) {
-            for (String roleId : roleIds) {
-                Role role = getRole(roleId);
-                if (role != null) {
-                    sb.append("        Name : ").append(role.getNamespaceCode()).append('/').append(role.getName());
-                    sb.append(" (").append(roleId).append(')');
-                    sb.append('\n');
-                }
-            }
-        }
-        sb.append("   Principal : ").append(principalId);
-        sb.append('\n');
-        sb.append("     Details :\n");
-        if (roleQualifiers != null) {
-            sb.append(new HashMap<String, String>(roleQualifiers));
-        } else {
-            sb.append("               [null]\n");
-        }
-        if (LOG.isTraceEnabled()) {
-            LOG.trace(sb.append(ExceptionUtils.getStackTrace(new Throwable())));
-        } else {
-            LOG.debug(sb.toString());
-        }
-    }
-
-    @Override
-    public void principalInactivated(String principalId) {
-        getRoleService().principalInactivated(principalId);
-        removeCacheEntries(null, principalId);
-    }
-
-    @Override
-    public void roleInactivated(String roleId) {
-        getRoleService().roleInactivated(roleId);
-        removeCacheEntries(roleId, null);
-    }
-
-    @Override
-    public void groupInactivated(String groupId) {
-        getRoleService().groupInactivated(groupId);
-    }
-
-    @Override
-    public List<RoleMembership> getFirstLevelRoleMembers(List<String> roleIds) {
-        return getRoleService().getFirstLevelRoleMembers(roleIds);
-    }
-
-    @Override
-    public List<RoleMember> findRoleMembers(Map<String, String> fieldValues) {
-        return getRoleService().findRoleMembers(fieldValues);
-    }
-
-    @Override
-    public List<RoleMembership> findRoleMemberships(Map<String, String> fieldValues) {
-        return getRoleService().findRoleMemberships(fieldValues);
-    }
-
-    @Override
-    public void assignRoleToRole(String roleId, String namespaceCode, String roleName,
-                                 Map<String, String> qualifications) {
-        getRoleUpdateService().assignRoleToRole(
-                roleId, namespaceCode, roleName, qualifications);
-        Role role = getRoleByName(namespaceCode, roleName);
-        removeCacheEntries(role.getId(), null);
-    }
-
-    @Override
-    public void saveDelegationMemberForRole(String delegationMemberId, String roleMemberId, String memberId, String memberTypeCode,
-                                            String delegationTypeCode, String roleId, Map<String, String> qualifications,
-                                            Date activeFromDate, Date activeToDate) throws UnsupportedOperationException {
-        getRoleUpdateService().saveDelegationMemberForRole(delegationMemberId, roleMemberId, memberId, memberTypeCode, delegationTypeCode, roleId, qualifications, activeFromDate, activeToDate);
-        Role role = getRole(roleId);
-        removeCacheEntries(role.getId(), null);
-    }
-
-    @Override
-    public RoleMember saveRoleMemberForRole(String roleMemberId, String memberId, String memberTypeCode,
-                                            String roleId, Map<String, String> qualifications, Date activeFromDate, Date activeToDate) throws UnsupportedOperationException {
-        Role role = getRole(roleId);
-        RoleMember roleMember = getRoleUpdateService().saveRoleMemberForRole(roleMemberId, memberId, memberTypeCode, roleId, qualifications, activeFromDate, activeToDate);
-        removeCacheEntries(role.getId(), memberId);
-        return roleMember;
-    }
-
-    @Override
-    public void removeRoleFromRole(String roleId, String namespaceCode, String roleName,
-                                   Map<String, String> qualifications) {
-        getRoleUpdateService().removeRoleFromRole(roleId, namespaceCode, roleName, qualifications);
-        Role role = getRoleByName(namespaceCode, roleName);
-        removeCacheEntries(role.getId(), null);
-    }
-
-    @Override
-    public List<DelegateMember> findDelegateMembers(Map<String, String> fieldValues) {
-        return getRoleService().findDelegateMembers(fieldValues);
-    }
-
-    @Override
-    public List<DelegateMember> getDelegationMembersByDelegationId(String delegationId) {
-        return getRoleService().getDelegationMembersByDelegationId(delegationId);
-    }
-
-    @Override
-    public DelegateMember getDelegationMemberByDelegationAndMemberId(String delegationId, String memberId) {
-        return getRoleService().getDelegationMemberByDelegationAndMemberId(delegationId, memberId);
-    }
-
-    @Override
-    public DelegateMember getDelegationMemberById(String delegationMemberId) {
-        return getRoleService().getDelegationMemberById(delegationMemberId);
-    }
-
-    @Override
-    public List<RoleResponsibilityAction> getRoleMemberResponsibilityActions(String roleMemberId) {
-        return getRoleService().getRoleMemberResponsibilityActions(roleMemberId);
-    }
-
-    @Override
-    public DelegateType getDelegateTypeInfo(String roleId, String delegationTypeCode) {
-        return getRoleService().getDelegateTypeInfo(roleId, delegationTypeCode);
-    }
-
-    @Override
-    public DelegateType getDelegateTypeInfoById(String delegationId) {
-        return getRoleService().getDelegateTypeInfoById(delegationId);
-    }
-
-    @Override
-    public void saveRoleRspActions(String roleResponsibilityActionId, String roleId, String roleResponsibilityId, String roleMemberId,
-                                   String actionTypeCode, String actionPolicyCode, Integer priorityNumber, Boolean forceAction) {
-        getRoleUpdateService().saveRoleRspActions(roleResponsibilityActionId, roleId, roleResponsibilityId, roleMemberId, actionTypeCode, actionPolicyCode, priorityNumber, forceAction);
-        removeCacheEntries(roleId, null);
-    }
-
-    @Override
-    public List<RoleResponsibility> getRoleResponsibilities(String roleId) {
-        return getRoleService().getRoleResponsibilities(roleId);
-    }
-
-    @Override
-    public void applicationRoleMembershipChanged(String roleId) {
-        removeCacheEntries(roleId, null);
-        getRoleService().applicationRoleMembershipChanged(roleId);
-    }
-
-    // Spring and injection methods
-
-    public RoleService getRoleService() {
-        if (roleService == null) {
-            roleService = KimApiServiceLocator.getRoleService();
-        }
-        return roleService;
-    }
-
-    public RoleUpdateService getRoleUpdateService() {
-        try {
-            if (roleUpdateService == null) {
-                roleUpdateService = KimApiServiceLocator.getRoleUpdateService();
-                if (roleUpdateService == null) {
-                    throw new UnsupportedOperationException("null returned for RoleUpdateService, unable to update role data");
-                }
-            }
-        } catch (Exception ex) {
-            throw new UnsupportedOperationException("unable to obtain a RoleUpdateService, unable to update role data", ex);
-        }
-        return roleUpdateService;
-    }
-
-    /**
-     * This overridden method looks up roles based on criteria.  If you want
-     * to return all roles pass in an empty map.
-     */
-    @Override
-    public List<Role> lookupRoles(Map<String, String> searchCriteria) {
-        return getRoleService().lookupRoles(searchCriteria);
-    }
-
-    @Override
-    public void flushInternalRoleCache() {
-        getRoleService().flushInternalRoleCache();
-    }
-
-    @Override
-    public void flushInternalRoleMemberCache() {
-        getRoleService().flushInternalRoleMemberCache();
-    }
-
-    @Override
-    public void flushInternalDelegationCache() {
-        getRoleService().flushInternalDelegationCache();
-    }
-
-    @Override
-    public void flushInternalDelegationMemberCache() {
-        getRoleService().flushInternalDelegationMemberCache();
-    }
-
-    @Override
-    public void assignPermissionToRole(String permissionId, String roleId) throws UnsupportedOperationException {
-        getRoleUpdateService().assignPermissionToRole(permissionId, roleId);
-    }
-
-    @Override
-    public String getNextAvailableRoleId() throws UnsupportedOperationException {
-        return getRoleUpdateService().getNextAvailableRoleId();
-    }
-
-    @Override
-    public void saveRole(String roleId, String roleName, String roleDescription, boolean active, String kimTypeId, String namespaceCode) throws UnsupportedOperationException {
-        getRoleUpdateService().saveRole(roleId, roleName, roleDescription, active, kimTypeId, namespaceCode);
-    }
-
-    @Override
-    public List<String> getMemberParentRoleIds(String memberType,
-                                               String memberId) {
-        return getRoleService().getMemberParentRoleIds(memberType, memberId);
-    }
-}
Index: work/src/org/kuali/rice/kim/api/role/RoleManagementService.java
===================================================================
--- work/src/org/kuali/rice/kim/api/role/RoleManagementService.java	(revision 32242)
+++ work/src/org/kuali/rice/kim/api/role/RoleManagementService.java	(revision 32263)
@@ -1,49 +0,0 @@
-/*
- * Copyright 2007-2008 The Kuali Foundation
- *
- * Licensed under the Educational Community License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.opensource.org/licenses/ecl2.php
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kim.api.role;
-
-/**
- * This service adds caching on top of the RoleService. 
- * 
- * @author Kuali Rice Team (rice.collab@kuali.org)
- */
-public interface RoleManagementService extends RoleService, RoleUpdateService {
-
-	/**
-	 * Flush all of the role-related caches.
-	 */
-	void flushRoleCaches();
-	
-	/**
-	 * Flush all of the role-member-related caches.
-	 */
-	void flushRoleMemberCaches();
-	
-	/**
-	 * Flush all of the delegation-related caches.
-	 */
-	void flushDelegationCaches();
-
-	/**
-	 * Flush all of the delegation-member-related caches.
-	 */
-	void flushDelegationMemberCaches();
-	
-	/**
-	 * Remove all cache entries for the given roleId and principalId combination.
-	 */
-	void removeCacheEntries( String roleId, String principalId );
-}
Index: work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java
===================================================================
--- work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java	(revision 32242)
+++ work/src/org/kuali/rice/kim/api/services/IdentityManagementService.java	(revision 32263)
@@ -68,7 +68,7 @@
 
     EntityDefaultQueryResults findEntityDefaults(QueryByCriteria queryByCriteria);
 
-	//KimEntityPrivacyPreferencesInfo getEntityPrivacyPreferences(String entityId);
+	//EntityPrivacyPreferencesInfo getEntityPrivacyPreferences(String entityId);
 
 	Entity getEntity( String entityId);
 	Entity getEntityByPrincipalId( String principalId);
Index: work/src/org/kuali/rice/kim/util/KimCommonUtils.java
===================================================================
--- work/src/org/kuali/rice/kim/util/KimCommonUtils.java	(revision 32242)
+++ work/src/org/kuali/rice/kim/util/KimCommonUtils.java	(revision 32263)
@@ -25,6 +25,9 @@
 import org.kuali.kfs.sys.context.SpringContext;
 import org.kuali.rice.core.api.config.property.ConfigurationService;
 import org.kuali.rice.kew.doctype.bo.DocumentType;
+import org.kuali.rice.kim.api.KimApiConstants;
+import org.kuali.rice.kim.api.KimConstants;
+import org.kuali.rice.krad.util.KRADUtils;
 
 /**
  * This is a description of what this class does - bhargavp don't forget to fill
@@ -34,7 +37,7 @@
  *
  */
 public class KimCommonUtils {
-    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KimCommonUtils.class);
+    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KRADUtils.class);
 
     public static String getClosestParentDocumentTypeName(
             DocumentType documentType,
@@ -73,31 +76,31 @@
                 || (requestedDetailsPropertyName.startsWith(permissionDetailsPropertyName+"."));
     }
 
-//    public static AttributeSet getNamespaceAndComponentSimpleName( Class<? extends Object> clazz) {
-//        AttributeSet attributeSet = new AttributeSet();
-//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
-//        attributeSet.put(KimAttributes.COMPONENT_NAME, getComponentSimpleName(clazz));
+//    public static Map<String,String> getNamespaceAndComponentSimpleName( Class<? extends Object> clazz) {
+//        Map<String,String> attributeSet = new HashMap<String,String>();
+//        attributeSet.put(KimConstants.AttributeConstants.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimConstants.AttributeConstants.COMPONENT_NAME, getComponentSimpleName(clazz));
 //        return attributeSet;
 //    }
 //
-//    public static AttributeSet getNamespaceAndComponentFullName( Class<? extends Object> clazz) {
-//        AttributeSet attributeSet = new AttributeSet();
-//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
-//        attributeSet.put(KimAttributes.COMPONENT_NAME, getComponentFullName(clazz));
+//    public static Map<String,String> getNamespaceAndComponentFullName( Class<? extends Object> clazz) {
+//        Map<String,String> attributeSet = new HashMap<String,String>();
+//        attributeSet.put(KimConstants.AttributeConstants.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimConstants.AttributeConstants.COMPONENT_NAME, getComponentFullName(clazz));
 //        return attributeSet;
 //    }
 //
-//    public static AttributeSet getNamespaceAndActionClass( Class<? extends Object> clazz) {
-//        AttributeSet attributeSet = new AttributeSet();
-//        attributeSet.put(KimAttributes.NAMESPACE_CODE, getNamespaceCode(clazz));
-//        attributeSet.put(KimAttributes.ACTION_CLASS, clazz.getName());
+//    public static Map<String,String> getNamespaceAndActionClass( Class<? extends Object> clazz) {
+//        Map<String,String> attributeSet = new HashMap<String,String>();
+//        attributeSet.put(KimConstants.AttributeConstants.NAMESPACE_CODE, getNamespaceCode(clazz));
+//        attributeSet.put(KimConstants.AttributeConstants.ACTION_CLASS, clazz.getName());
 //        return attributeSet;
 //    }
 //
 //    public static String getNamespaceCode(Class<? extends Object> clazz) {
 //        ModuleService moduleService = getKualiModuleService().getResponsibleModuleService(clazz);
 //        if (moduleService == null) {
-//            return KimConstants.KIM_TYPE_DEFAULT_NAMESPACE;
+//            return KimApiConstants.KIM_TYPE_DEFAULT_NAMESPACE;
 //        }
 //        return moduleService.getModuleConfiguration().getNamespaceCode();
 //    }
@@ -110,35 +113,35 @@
         return clazz.getName();
     }
 
-//    public static boolean isAttributeSetEntryEquals( AttributeSet map1, AttributeSet map2, String key ) {
+//    public static boolean isAttributeSetEntryEquals( Map<String,String> map1, Map<String,String> map2, String key ) {
 //        return StringUtils.equals( map1.get( key ), map2.get( key ) );
 //    }
 
     /**
      * Resolves the given kim type service name represented as a String to the appropriate QName.
-     * If the value given is empty or null, then it will resolve to the default KimTypeService name.
+     * If the value given is empty or null, then it will resolve to the default KimTypeInfoService name.
      */
-    public static QName resolveKimTypeServiceName(String kimTypeServiceName) {
+    public static QName resolveKimTypeInfoServiceName(String kimTypeServiceName) {
         if (StringUtils.isBlank(kimTypeServiceName)) {
-            return resolveKimTypeServiceName(KimConstants.DEFAULT_KIM_TYPE_SERVICE);
+            return resolveKimTypeInfoServiceName(KimConstants.DEFAULT_KIM_TYPE_SERVICE);
         }
         return QName.valueOf(kimTypeServiceName);
     }
 
 //    /**
-//     * @deprecated Please use KIMServiceLocator.getKimTypeService(KimType) instead
+//     * @deprecated Please use KIMServiceLocator.getKimTypeInfoService(KimType) instead
 //     */
 //    @Deprecated
-//    public static KimTypeService getKimTypeService(KimType kimType){
-//        return KIMServiceLocator.getKimTypeService(kimType);
+//    public static KimTypeInfoService getKimTypeInfoService(KimType kimType){
+//        return KIMServiceLocator.getKimTypeInfoService(kimType);
 //    }
 //
 //    /**
-//     * @deprecated Please use KIMServiceLocator.getKimTypeService(QName) instead
+//     * @deprecated Please use KIMServiceLocator.getKimTypeInfoService(QName) instead
 //     */
 //    @Deprecated
-//    public static KimTypeService getKimTypeService( String serviceName ) {
-//        return KIMServiceLocator.getKimTypeService(resolveKimTypeServiceName(serviceName));
+//    public static KimTypeInfoService getKimTypeInfoService( String serviceName ) {
+//        return KIMServiceLocator.getKimTypeInfoService(resolveKimTypeInfoServiceName(serviceName));
 //    }
 
     public static void copyProperties(Object targetToCopyTo, Object sourceToCopyFrom){
@@ -151,7 +154,7 @@
     }
 
     public static String getKimBasePath(){
-        String kimBaseUrl = SpringContext.getBean(ConfigurationService.class).getPropertyString(KimConstants.KimUIConstants.KIM_URL_KEY);
+        String kimBaseUrl = SpringContext.getBean(ConfigurationService.class).getPropertyValueAsString(KimConstants.KimUIConstants.KIM_URL_KEY);
         if (!kimBaseUrl.endsWith(KimConstants.KimUIConstants.URL_SEPARATOR)) {
             kimBaseUrl = kimBaseUrl + KimConstants.KimUIConstants.URL_SEPARATOR;
         }
@@ -184,14 +187,14 @@
 //        return getIdentityManagementService().isAuthorized(
 //                GlobalVariables.getUserSession().getPrincipalId(),
 //                KimConstants.NAMESPACE_CODE,
-//                KimConstants.PermissionNames.OVERRIDE_ENTITY_PRIVACY_PREFERENCES,
+//                KimApiConstants.PermissionNames.OVERRIDE_ENTITY_PRIVACY_PREFERENCES,
 //                null,
-//                new AttributeSet(KimAttributes.PRINCIPAL_ID, principalId) );
+//                new HashMap<String,String>(KimConstants.AttributeConstants.PRINCIPAL_ID, principalId) );
 //    }
 //
 //    public static boolean isSuppressName(String entityId) {
-//        KimEntityPrivacyPreferences privacy = null;
-//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        EntityPrivacyPreferences privacy = null;
+//        EntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
 //        if (entityInfo != null) {
 //            privacy = entityInfo.getPrivacyPreferences();
 //        }
@@ -208,8 +211,8 @@
 //    }
 //
 //    public static boolean isSuppressEmail(String entityId) {
-//        KimEntityPrivacyPreferences privacy = null;
-//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        EntityPrivacyPreferences privacy = null;
+//        EntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
 //        if (entityInfo != null) {
 //            privacy = entityInfo.getPrivacyPreferences();
 //        }
@@ -226,8 +229,8 @@
 //    }
 //
 //    public static boolean isSuppressAddress(String entityId) {
-//        KimEntityPrivacyPreferences privacy = null;
-//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        EntityPrivacyPreferences privacy = null;
+//        EntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
 //        if (entityInfo != null) {
 //            privacy = entityInfo.getPrivacyPreferences();
 //        }
@@ -244,8 +247,8 @@
 //    }
 //
 //    public static boolean isSuppressPhone(String entityId) {
-//        KimEntityPrivacyPreferences privacy = null;
-//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        EntityPrivacyPreferences privacy = null;
+//        EntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
 //        if (entityInfo != null) {
 //            privacy = entityInfo.getPrivacyPreferences();
 //        }
@@ -262,8 +265,8 @@
 //    }
 //
 //    public static boolean isSuppressPersonal(String entityId) {
-//        KimEntityPrivacyPreferences privacy = null;
-//        KimEntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
+//        EntityPrivacyPreferences privacy = null;
+//        EntityDefaultInfo entityInfo = getIdentityManagementService().getEntityDefaultInfo(entityId);
 //        if (entityInfo != null) {
 //            privacy = entityInfo.getPrivacyPreferences();
 //        }
@@ -286,7 +289,7 @@
 //        if( externalIdentifierTypeObject!= null && externalIdentifierTypeObject.isEncryptionRequired()){
 //            if(StringUtils.isNotEmpty(externalIdentifier)){
 //                try{
-//                    return KNSServiceLocator.getEncryptionService().encrypt(externalIdentifier);
+//                    return SpringContext.getBean(EncryptionService.class).encrypt(externalIdentifier);
 //                }catch (GeneralSecurityException e) {
 //                    LOG.info("Unable to encrypt value : " + e.getMessage() + " or it is already encrypted");
 //                }
@@ -302,7 +305,7 @@
 //        if( externalIdentifierTypeObject!= null && externalIdentifierTypeObject.isEncryptionRequired()){
 //            if(StringUtils.isNotEmpty(externalIdentifier)){
 //                try{
-//                    return KNSServiceLocator.getEncryptionService().decrypt(externalIdentifier);
+//                    return SpringContext.getBean(EncryptionService.class).decrypt(externalIdentifier);
 //                }catch (GeneralSecurityException e) {
 //                    LOG.info("Unable to decrypt value : " + e.getMessage() + " or it is already decrypted");
 //                }
@@ -313,7 +316,7 @@
 //
 //    public static IdentityManagementService getIdentityManagementService() {
 //        if ( identityManagementService == null ) {
-//            identityManagementService = KIMServiceLocator.getIdentityManagementService();
+//            identityManagementService = SpringContext.getBean(IdentityManagementService.class);
 //        }
 //        return identityManagementService;
 //    }
@@ -340,10 +343,10 @@
 //
 //    public static List<GroupAttributeDataImpl> copyInfoAttributesToGroupAttributes(Map<String, String> infoMap, String groupId, String kimTypeId) {
 //        List<GroupAttributeDataImpl> attrList = new ArrayList<GroupAttributeDataImpl>(infoMap.size());
-//        List<KimTypeAttributeInfo> attributeInfoList = KIMServiceLocator.getTypeInfoService().getKimType(kimTypeId).getAttributeDefinitions();
+//        List<KimTypeAttribute> attributeInfoList = SpringContext.getBean(KimTypeInfoService.class).getKimType(kimTypeId).getAttributeDefinitions();
 //
 //        for (String key : infoMap.keySet()) {
-//            KimTypeAttributeInfo typeAttributeInfo = getAttributeInfo(attributeInfoList, key);
+//            KimTypeAttribute typeAttributeInfo = getAttributeInfo(attributeInfoList, key);
 //
 //            if (typeAttributeInfo != null) {
 //                GroupAttributeDataImpl groupAttribute = new GroupAttributeDataImpl();
@@ -359,9 +362,9 @@
 //        return attrList;
 //    }
 //
-//    private static KimTypeAttributeInfo getAttributeInfo(List<KimTypeAttributeInfo> attributeInfoList, String attributeName) {
-//        KimTypeAttributeInfo kRet = null;
-//        for (KimTypeAttributeInfo attributeInfo : attributeInfoList) {
+//    private static KimTypeAttribute getAttributeInfo(List<KimTypeAttribute> attributeInfoList, String attributeName) {
+//        KimTypeAttribute kRet = null;
+//        for (KimTypeAttribute attributeInfo : attributeInfoList) {
 //            if (attributeInfo.getAttributeName().equals(attributeName)) {
 //                kRet = attributeInfo;
 //                break;
Index: work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorImpl.java
===================================================================
--- work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorImpl.java	(revision 32242)
+++ work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorImpl.java	(revision 32263)
@@ -15,15 +15,16 @@
  */
 package org.kuali.rice.core.impl.parameter;
 
+import java.util.List;
+
+import org.kuali.kfs.sys.context.SpringContext;
 import org.kuali.rice.core.api.parameter.Parameter;
 import org.kuali.rice.core.api.parameter.ParameterEvaluator;
 import org.kuali.rice.core.api.util.RiceKeyConstants;
-import org.kuali.rice.krad.service.DataDictionaryService;
-import org.kuali.rice.krad.service.KRADServiceLocatorWeb;
+import org.kuali.rice.kns.service.DataDictionaryService;
+import org.kuali.rice.krad.service.KRADServiceLocator;
 import org.kuali.rice.krad.util.GlobalVariables;
 
-import java.util.List;
-
 public class ParameterEvaluatorImpl implements ParameterEvaluator {
 	private static final long serialVersionUID = -758645169354452022L;
 	private Parameter parameter;
@@ -58,7 +59,7 @@
 	/**
 	 * This method uses the evaluationSucceeds method to evaluate the
 	 * constrainedValue. If evaluation does not succeed, it adds an error to
-	 * GlobalVariables.getErrorMap(). The businessObjectOrDocumentClass,
+	 * GlobalVariables.getMessageMap(). The businessObjectOrDocumentClass,
 	 * nameOfConstrainedProperty and userEditablePropertyName are used to
 	 * retrieve the appropriate labels from the DataDictionary.
 	 * 
@@ -145,7 +146,7 @@
 	 */
 	protected DataDictionaryService getDataDictionaryService() {
 		if ( dataDictionaryService == null ) {
-			dataDictionaryService = KRADServiceLocatorWeb.getDataDictionaryService();
+			dataDictionaryService = SpringContext.getBean(DataDictionaryService.class);
 		}
 		return dataDictionaryService;
 	}
Index: work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorServiceImpl.java
===================================================================
--- work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorServiceImpl.java	(revision 32242)
+++ work/src/org/kuali/rice/core/impl/parameter/ParameterEvaluatorServiceImpl.java	(revision 32263)
@@ -134,17 +134,17 @@
 			String constrainingValue, String constrainedValue) {
 			    Parameter allowParameter = parameterService.getParameter(componentClass, allowParameterName);
 			    Parameter denyParameter = parameterService.getParameter(componentClass, denyParameterName);
-			    if (!getParameterValues(allowParameter, constrainingValue).isEmpty() && !getParameterValues(denyParameter, constrainingValue).isEmpty()) {
+			    if (!getParameterValuesAsString(allowParameter, constrainingValue).isEmpty() && !getParameterValuesAsString(denyParameter, constrainingValue).isEmpty()) {
 			        throw new IllegalArgumentException("The getParameterEvaluator(Class componentClass, String allowParameterName, String denyParameterName, String constrainingValue, String constrainedValue) method of ParameterServiceImpl does not facilitate evaluation of combination allow and deny parameters that both have values for the constraining value: " + allowParameterName + " / " + denyParameterName + " / " + constrainingValue);
 			    }
-			    if (getParameterValues(allowParameter, constrainingValue).isEmpty() && getParameterValues(denyParameter, constrainingValue).isEmpty()) {
+			    if (getParameterValuesAsString(allowParameter, constrainingValue).isEmpty() && getParameterValuesAsString(denyParameter, constrainingValue).isEmpty()) {
 			        return AlwaysSucceedParameterEvaluatorImpl.getInstance();
 			    }
-			    return getParameterEvaluator(getParameterValues(denyParameter, constrainingValue).isEmpty() ? allowParameter : denyParameter, constrainingValue, constrainedValue);
+			    return getParameterEvaluator(getParameterValuesAsString(denyParameter, constrainingValue).isEmpty() ? allowParameter : denyParameter, constrainingValue, constrainedValue);
 	}
 
-    protected List<String> getParameterValues(Parameter parameter, String constrainingValue) {
-	    List<String> constraintValuePairs = getParameterValues(parameter);
+    protected List<String> getParameterValuesAsString(Parameter parameter, String constrainingValue) {
+	    List<String> constraintValuePairs = getParameterValuesAsString(parameter);
 	    for (String pair : constraintValuePairs) {
 	        if (StringUtils.equals(constrainingValue, StringUtils.substringBefore(pair, "="))) {
 	            return Arrays.asList(StringUtils.substringAfter(pair, "=").split(","));
@@ -153,7 +153,7 @@
 	    return Collections.emptyList();
 	}
 
-    private List<String> getParameterValues(Parameter parameter) {
+    private List<String> getParameterValuesAsString(Parameter parameter) {
 	    if (parameter == null || StringUtils.isBlank(parameter.getValue())) {
 	        return Collections.emptyList();
 	    }
@@ -164,7 +164,7 @@
 	    ParameterEvaluatorImpl parameterEvaluator = new ParameterEvaluatorImpl();
 	    parameterEvaluator.setParameter(parameter);
 	    parameterEvaluator.setConstraintIsAllow(constraintIsAllow(parameter));
-	    parameterEvaluator.setValues(getParameterValues(parameter));
+	    parameterEvaluator.setValues(getParameterValuesAsString(parameter));
 	    return parameterEvaluator;
 	}
 
@@ -177,7 +177,7 @@
 	protected ParameterEvaluatorImpl getParameterEvaluator(Parameter parameter, String constrainingValue,
 			String constrainedValue) {
 	    ParameterEvaluatorImpl parameterEvaluator = getParameterEvaluator(parameter, constrainedValue);
-	    parameterEvaluator.setValues(getParameterValues(parameter, constrainingValue));
+	    parameterEvaluator.setValues(getParameterValuesAsString(parameter, constrainingValue));
 	    return parameterEvaluator;
 	}
 
Index: work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java
===================================================================
--- work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java	(revision 32242)
+++ work/src/org/kuali/rice/ojb/ConfigurableSequenceManager.java	(revision 32263)
@@ -49,7 +49,7 @@
             return (SequenceManager) sequenceManagerObject;
         }
         catch (Exception e) {
-            String message = "Unable to configure SequenceManager specified by " + SEQUENCE_MANAGER_CLASS_NAME_PROPERTY + " KualiConfigurationService property";
+            String message = "Unable to configure SequenceManager specified by " + SEQUENCE_MANAGER_CLASS_NAME_PROPERTY + " ConfigurationService property";
             LOG.fatal(message, e);
             throw new RuntimeException(message, e);
         }
Index: work/src/org/kuali/rice/kns/util/ObjectUtils.java
===================================================================
--- work/src/org/kuali/rice/kns/util/ObjectUtils.java	(revision 32242)
+++ work/src/org/kuali/rice/kns/util/ObjectUtils.java	(revision 32263)
@@ -35,17 +35,18 @@
 import org.apache.log4j.Logger;
 import org.apache.ojb.broker.core.proxy.ProxyHelper;
 import org.hibernate.collection.PersistentBag;
-import org.kuali.rice.kns.bo.BusinessObject;
-import org.kuali.rice.kns.bo.ExternalizableBusinessObject;
-import org.kuali.rice.kns.bo.PersistableBusinessObject;
-import org.kuali.rice.kns.bo.PersistableBusinessObjectExtension;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.ModuleService;
-import org.kuali.rice.kns.service.PersistenceStructureService;
-import org.kuali.rice.kns.util.cache.CopiedObject;
-import org.kuali.rice.kns.web.format.CollectionFormatter;
-import org.kuali.rice.kns.web.format.FormatException;
-import org.kuali.rice.kns.web.format.Formatter;
+import org.kuali.kfs.sys.context.SpringContext;
+import org.kuali.rice.core.api.util.cache.CopiedObject;
+import org.kuali.rice.core.web.format.CollectionFormatter;
+import org.kuali.rice.core.web.format.FormatException;
+import org.kuali.rice.core.web.format.Formatter;
+import org.kuali.rice.kns.service.DataDictionaryService;
+import org.kuali.rice.krad.bo.BusinessObject;
+import org.kuali.rice.krad.bo.PersistableBusinessObject;
+import org.kuali.rice.krad.bo.PersistableBusinessObjectExtension;
+import org.kuali.rice.krad.service.KRADServiceLocator;
+import org.kuali.rice.krad.service.PersistenceStructureService;
+import org.kuali.rice.krad.util.KRADConstants;
 
 /**
  * This class contains various Object, Proxy, and serialization utilities.
@@ -173,32 +174,32 @@
      * @throws FormatException
      */
 
-    public static BusinessObject createHybridBusinessObject(Class businessObjectClass, BusinessObject source, Map<String, String> template) throws FormatException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
-        BusinessObject obj = null;
-        try {
-    		ModuleService moduleService = KNSServiceLocator.getKualiModuleService().getResponsibleModuleService(businessObjectClass);
-    		if (moduleService != null && moduleService.isExternalizable(businessObjectClass))
-    			obj = (BusinessObject)moduleService.createNewObjectFromExternalizableClass(businessObjectClass);
-    		else
-    			obj = (BusinessObject) businessObjectClass.newInstance();
-        }
-        catch (Exception e) {
-            throw new RuntimeException("Cannot instantiate " + businessObjectClass.getName(), e);
-        }
+//    public static BusinessObject createHybridBusinessObject(Class businessObjectClass, BusinessObject source, Map<String, String> template) throws FormatException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
+//        BusinessObject obj = null;
+//        try {
+//    		ModuleService moduleService = KRADServiceLocator.getKualiModuleService().getResponsibleModuleService(businessObjectClass);
+//    		if (moduleService != null && moduleService.isExternalizable(businessObjectClass))
+//    			obj = (BusinessObject)moduleService.createNewObjectFromExternalizableClass(businessObjectClass);
+//    		else
+//    			obj = (BusinessObject) businessObjectClass.newInstance();
+//        }
+//        catch (Exception e) {
+//            throw new RuntimeException("Cannot instantiate " + businessObjectClass.getName(), e);
+//        }
+//
+//        createHybridBusinessObject(obj, source, template);
+//
+//        return obj;
+//    }
+//    
+//    public static void createHybridBusinessObject(BusinessObject businessObject, BusinessObject source, Map<String, String> template) throws FormatException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
+//        for (String name : template.keySet()) {
+//            String sourcePropertyName = template.get(name);
+//            setObjectProperty(businessObject, name, easyGetPropertyType(source, sourcePropertyName), getPropertyValue(source, sourcePropertyName));
+//        }
+//    }
 
-        createHybridBusinessObject(obj, source, template);
 
-        return obj;
-    }
-    
-    public static void createHybridBusinessObject(BusinessObject businessObject, BusinessObject source, Map<String, String> template) throws FormatException, IllegalAccessException, InvocationTargetException, NoSuchMethodException {
-        for (String name : template.keySet()) {
-            String sourcePropertyName = template.get(name);
-            setObjectProperty(businessObject, name, easyGetPropertyType(source, sourcePropertyName), getPropertyValue(source, sourcePropertyName));
-        }
-    }
-
-
     /**
      * This method simply uses PojoPropertyUtilsBean logic to get the Class of a Class property.
      * This method does not have any of the logic needed to obtain the Class of an element of a Collection specified in the DataDictionary.
@@ -329,7 +330,7 @@
 	 * @return Formatted property value as String, or empty string if value is null
 	 */
 	public static String getFormattedPropertyValue(BusinessObject businessObject, String propertyName, Formatter formatter) {
-		String propValue = KNSConstants.EMPTY_STRING;
+		String propValue = KRADConstants.EMPTY_STRING;
 
 		Object prop = ObjectUtils.getPropertyValue(businessObject, propertyName);
 		if (formatter == null) {
@@ -369,7 +370,7 @@
 	 * @return formatted value as a String
 	 */
 	public static String formatPropertyValue(Object propertyValue) {
-		Object propValue = KNSConstants.EMPTY_STRING;
+		Object propValue = KRADConstants.EMPTY_STRING;
 
 		Formatter formatter = null;
 		if (propertyValue != null) {
@@ -382,7 +383,7 @@
 			propValue = formatter != null ? formatter.format(propertyValue) : propertyValue;
 		}
 
-		return propValue != null ? String.valueOf(propValue) : KNSConstants.EMPTY_STRING;
+		return propValue != null ? String.valueOf(propValue) : KRADConstants.EMPTY_STRING;
 	}
     
     /**
@@ -487,12 +488,12 @@
 			}
 		}
 
-		Class<? extends Formatter> formatterClass = KNSServiceLocator.getDataDictionaryService().getAttributeFormatter(
+		Class<? extends Formatter> formatterClass = SpringContext.getBean(DataDictionaryService.class).getAttributeFormatter(
 				boClass, boPropertyName);
 		if (formatterClass == null) {
 			try {
 				formatterClass = Formatter.findFormatter(getPropertyType(boClass.newInstance(), boPropertyName,
-						KNSServiceLocator.getPersistenceStructureService()));
+						KRADServiceLocator.getPersistenceStructureService()));
 			} catch (InstantiationException e) {
 				LOG.warn("Unable to find a formater for bo class " + boClass + " and property " + boPropertyName);
 				// just swallow the exception and let formatter be null
@@ -602,7 +603,7 @@
                 if (propertyList instanceof PersistentBag) {
                 	try {
 	                	PersistentBag bag = (PersistentBag) propertyList;
-	                	PersistableBusinessObject pbo = (PersistableBusinessObject) KNSServiceLocator.getEntityManagerFactory().createEntityManager().find(bo.getClass(), bag.getKey());
+	                	PersistableBusinessObject pbo = (PersistableBusinessObject) KRADServiceLocator.getEntityManagerFactory().createEntityManager().find(bo.getClass(), bag.getKey());
 	        			Field field1 = pbo.getClass().getDeclaredField(propertyDescriptor.getName());
 	        			Field field2 = bo.getClass().getDeclaredField(propertyDescriptor.getName());
 	        			field1.setAccessible(true);
@@ -638,7 +639,7 @@
         if (isNotNull(bo)) {
             PropertyDescriptor[] propertyDescriptors = PropertyUtils.getPropertyDescriptors(bo.getClass());
             for (int i = 0; i < propertyDescriptors.length; i++) {
-                if (KNSServiceLocator.getPersistenceStructureService().hasCollection(bo.getClass(), propertyDescriptors[i].getName()) && KNSServiceLocator.getPersistenceStructureService().isCollectionUpdatable(bo.getClass(), propertyDescriptors[i].getName())) {
+                if (KRADServiceLocator.getPersistenceStructureService().hasCollection(bo.getClass(), propertyDescriptors[i].getName()) && KRADServiceLocator.getPersistenceStructureService().isCollectionUpdatable(bo.getClass(), propertyDescriptors[i].getName())) {
                     Collection updateableCollection = (Collection) getPropertyValue(bo, propertyDescriptors[i].getName());
                     if ((updateableCollection != null) && ProxyHelper.isCollectionProxy(updateableCollection)) {
                         materializeObjects(updateableCollection);
@@ -649,138 +650,138 @@
     }
 
 
-    /**
-     * Removes all query characters from a string.
-     * 
-     * @param string
-     * 
-     * @return Cleaned string
-     */
-    public static String clean(String string) {
-        for (int i = 0; i < KNSConstants.QUERY_CHARACTERS.length; i++) {
-            string = StringUtils.replace(string, KNSConstants.QUERY_CHARACTERS[i], KNSConstants.EMPTY_STRING);
-        }
-        return string;
-    }
+//    /**
+//     * Removes all query characters from a string.
+//     * 
+//     * @param string
+//     * 
+//     * @return Cleaned string
+//     */
+//    public static String clean(String string) {
+//        for (int i = 0; i < KRADConstants.QUERY_CHARACTERS.length; i++) {
+//            string = StringUtils.replace(string, KRADConstants.QUERY_CHARACTERS[i], KRADConstants.EMPTY_STRING);
+//        }
+//        return string;
+//    }
+//
+//
+//    /**
+//     * Compares two {@link PersistableBusinessObject} instances for equality of type and key values.
+//     * 
+//     * @param bo1
+//     * @param bo2
+//     *  
+//     * @return boolean indicating whether the two objects are equal.
+//     */
+//    public static boolean equalByKeys(PersistableBusinessObject bo1, PersistableBusinessObject bo2) {
+//        boolean equal = true;
+//
+//        if (bo1 == null && bo2 == null) {
+//            equal = true;
+//        }
+//        else if (bo1 == null || bo2 == null) {
+//            equal = false;
+//        }
+//        else if (!bo1.getClass().getName().equals(bo2.getClass().getName())) {
+//            equal = false;
+//        }
+//        else {
+//            Map bo1Keys = KRADServiceLocator.getPersistenceService().getPrimaryKeyFieldValues(bo1);
+//            Map bo2Keys = KRADServiceLocator.getPersistenceService().getPrimaryKeyFieldValues(bo2);
+//            for (Iterator iter = bo1Keys.keySet().iterator(); iter.hasNext();) {
+//                String keyName = (String) iter.next();
+//                if (bo1Keys.get(keyName) != null && bo2Keys.get(keyName) != null) {
+//                    if (!bo1Keys.get(keyName).toString().equals(bo2Keys.get(keyName).toString())) {
+//                        equal = false;
+//                    }
+//                } else {
+//                    equal = false;
+//                }
+//            }
+//        }  
+//
+//
+//        return equal;
+//    }
 
+//    /**
+//     * Compares a business object with a List of {@link PersistableBusinessObject}s to determine if an object with the same key as the BO exists in the list.
+//     * 
+//     * @param controlList - The list of items to check
+//     * @param bo - The BO whose keys we are looking for in the controlList
+//     * 
+//     * @return boolean
+//     */
+//    public static boolean collectionContainsObjectWithIdentitcalKey(Collection<? extends PersistableBusinessObject> controlList, PersistableBusinessObject bo) {
+//        boolean objectExistsInList = false;
+//
+//        for (Iterator i = controlList.iterator(); i.hasNext();) {
+//            if (equalByKeys((PersistableBusinessObject) i.next(), bo)) {
+//                return true;
+//            }
+//        }
+//
+//        return objectExistsInList;
+//    }
+//
+//    /**
+//     * Compares a business object with a Collection of {@link PersistableBusinessObject}s to count how many have the same key as the BO.
+//     * 
+//     * @param collection - The collection of items to check
+//     * @param bo - The BO whose keys we are looking for in the collection
+//     * 
+//     * @return how many have the same keys
+//     */
+//    public static int countObjectsWithIdentitcalKey(Collection<? extends PersistableBusinessObject> collection, PersistableBusinessObject bo) {
+//        // todo: genericize collectionContainsObjectWithIdentitcalKey() to leverage this method?
+//        int n = 0;
+//        for (PersistableBusinessObject item : collection) {
+//            if (equalByKeys(item, bo)) {
+//                n++;
+//            }
+//        }
+//        return n;
+//    }
+//
+//    /**
+//     * Compares a business object with a List of {@link PersistableBusinessObject}s to determine if an object with the same key as the BO exists in the list. If it
+//     * does, the item is removed from the List. This is functionally similar to List.remove() that operates only on Key values.
+//     * 
+//     * @param controlList - The list of items to check
+//     * @param bo - The BO whose keys we are looking for in the controlList
+//     */
+//
+//    public static void removeObjectWithIdentitcalKey(Collection<? extends PersistableBusinessObject> controlList, PersistableBusinessObject bo) {
+//        for (Iterator<? extends PersistableBusinessObject> i = controlList.iterator(); i.hasNext();) {
+//        	PersistableBusinessObject listBo = i.next();
+//            if (equalByKeys(listBo, bo)) {
+//                i.remove();
+//            }
+//        }
+//    }
+//
+//    /**
+//     * Compares a business object with a List of BOs to determine if an object with the same key as the BO exists in the list. If it
+//     * does, the item is returned.
+//     * 
+//     * @param controlList - The list of items to check
+//     * @param bo - The BO whose keys we are looking for in the controlList
+//     */
+//
+//    public static BusinessObject retrieveObjectWithIdentitcalKey(Collection<? extends PersistableBusinessObject> controlList, PersistableBusinessObject bo) {
+//        BusinessObject returnBo = null;
+//
+//        for (Iterator<? extends PersistableBusinessObject> i = controlList.iterator(); i.hasNext();) {
+//        	PersistableBusinessObject listBo = i.next();
+//            if (equalByKeys(listBo, bo)) {
+//                returnBo = listBo;
+//            }
+//        }
+//
+//        return returnBo;
+//    }
 
     /**
-     * Compares two {@link PersistableBusinessObject} instances for equality of type and key values.
-     * 
-     * @param bo1
-     * @param bo2
-     *  
-     * @return boolean indicating whether the two objects are equal.
-     */
-    public static boolean equalByKeys(PersistableBusinessObject bo1, PersistableBusinessObject bo2) {
-        boolean equal = true;
-
-        if (bo1 == null && bo2 == null) {
-            equal = true;
-        }
-        else if (bo1 == null || bo2 == null) {
-            equal = false;
-        }
-        else if (!bo1.getClass().getName().equals(bo2.getClass().getName())) {
-            equal = false;
-        }
-        else {
-            Map bo1Keys = KNSServiceLocator.getPersistenceService().getPrimaryKeyFieldValues(bo1);
-            Map bo2Keys = KNSServiceLocator.getPersistenceService().getPrimaryKeyFieldValues(bo2);
-            for (Iterator iter = bo1Keys.keySet().iterator(); iter.hasNext();) {
-                String keyName = (String) iter.next();
-                if (bo1Keys.get(keyName) != null && bo2Keys.get(keyName) != null) {
-                    if (!bo1Keys.get(keyName).toString().equals(bo2Keys.get(keyName).toString())) {
-                        equal = false;
-                    }
-                } else {
-                    equal = false;
-                }
-            }
-        }  
-
-
-        return equal;
-    }
-
-    /**
-     * Compares a business object with a List of {@link PersistableBusinessObject}s to determine if an object with the same key as the BO exists in the list.
-     * 
-     * @param controlList - The list of items to check
-     * @param bo - The BO whose keys we are looking for in the controlList
-     * 
-     * @return boolean
-     */
-    public static boolean collectionContainsObjectWithIdentitcalKey(Collection<? extends PersistableBusinessObject> controlList, PersistableBusinessObject bo) {
-        boolean objectExistsInList = false;
-
-        for (Iterator i = controlList.iterator(); i.hasNext();) {
-            if (equalByKeys((PersistableBusinessObject) i.next(), bo)) {
-                return true;
-            }
-        }
-
-        return objectExistsInList;
-    }
-
-    /**
-     * Compares a business object with a Collection of {@link PersistableBusinessObject}s to count how many have the same key as the BO.
-     * 
-     * @param collection - The collection of items to check
-     * @param bo - The BO whose keys we are looking for in the collection
-     * 
-     * @return how many have the same keys
-     */
-    public static int countObjectsWithIdentitcalKey(Collection<? extends PersistableBusinessObject> collection, PersistableBusinessObject bo) {
-        // todo: genericize collectionContainsObjectWithIdentitcalKey() to leverage this method?
-        int n = 0;
-        for (PersistableBusinessObject item : collection) {
-            if (equalByKeys(item, bo)) {
-                n++;
-            }
-        }
-        return n;
-    }
-
-    /**
-     * Compares a business object with a List of {@link PersistableBusinessObject}s to determine if an object with the same key as the BO exists in the list. If it
-     * does, the item is removed from the List. This is functionally similar to List.remove() that operates only on Key values.
-     * 
-     * @param controlList - The list of items to check
-     * @param bo - The BO whose keys we are looking for in the controlList
-     */
-
-    public static void removeObjectWithIdentitcalKey(Collection<? extends PersistableBusinessObject> controlList, PersistableBusinessObject bo) {
-        for (Iterator<? extends PersistableBusinessObject> i = controlList.iterator(); i.hasNext();) {
-        	PersistableBusinessObject listBo = i.next();
-            if (equalByKeys(listBo, bo)) {
-                i.remove();
-            }
-        }
-    }
-
-    /**
-     * Compares a business object with a List of BOs to determine if an object with the same key as the BO exists in the list. If it
-     * does, the item is returned.
-     * 
-     * @param controlList - The list of items to check
-     * @param bo - The BO whose keys we are looking for in the controlList
-     */
-
-    public static BusinessObject retrieveObjectWithIdentitcalKey(Collection<? extends PersistableBusinessObject> controlList, PersistableBusinessObject bo) {
-        BusinessObject returnBo = null;
-
-        for (Iterator<? extends PersistableBusinessObject> i = controlList.iterator(); i.hasNext();) {
-        	PersistableBusinessObject listBo = i.next();
-            if (equalByKeys(listBo, bo)) {
-                returnBo = listBo;
-            }
-        }
-
-        return returnBo;
-    }
-
-    /**
      * Determines if a given string could represent a nested attribute of an object.
      * 
      * @param attributeName
@@ -894,89 +895,89 @@
      * @param depth int Value 0-5 indicating how deep to recurse the materialization. If a zero (0) is passed in, then no work will
      *        be done.
      */
-    public static void materializeSubObjectsToDepth(PersistableBusinessObject bo, int depth) {
-        if (bo == null) {
-            throw new IllegalArgumentException("The bo passed in was null.");
-        }
-        if (depth < 0 || depth > 5) {
-            throw new IllegalArgumentException("The depth passed in was out of bounds.  Only values " + "between 0 and 5, inclusively, are allowed.");
-        }
+//    public static void materializeSubObjectsToDepth(PersistableBusinessObject bo, int depth) {
+//        if (bo == null) {
+//            throw new IllegalArgumentException("The bo passed in was null.");
+//        }
+//        if (depth < 0 || depth > 5) {
+//            throw new IllegalArgumentException("The depth passed in was out of bounds.  Only values " + "between 0 and 5, inclusively, are allowed.");
+//        }
+//
+//        // if depth is zero, then we're done recursing and can just exit
+//        if (depth == 0) {
+//            return;
+//        }
+//
+//        // deal with the possibility that the bo passed in (ie, the parent object) is an un-materialized proxy
+//        if (ProxyHelper.isProxy(bo)) {
+//            if (!ProxyHelper.isMaterialized(bo)) {
+//                throw new IllegalArgumentException("The bo passed in is an un-materialized proxy, and cannot be used.");
+//            }
+//        }
+//
+//        // get the list of reference objects hanging off the parent BO
+//        if ( KRADServiceLocator.getPersistenceStructureService().isPersistable( bo.getClass() ) ) {
+//	        Map<String, Class> references = KRADServiceLocator.getPersistenceStructureService().listReferenceObjectFields(bo);
+//	
+//	        // initialize our in-loop objects
+//	        String referenceName = "";
+//	        Class referenceClass = null;
+//	        Object referenceValue = null;
+//	        Object realReferenceValue = null;
+//	
+//	        // for each reference object on the parent bo
+//	        for (Iterator iter = references.keySet().iterator(); iter.hasNext();) {
+//	            referenceName = (String) iter.next();
+//	            referenceClass = references.get(referenceName);
+//	
+//	            // if its a proxy, replace it with a non-proxy
+//	            referenceValue = getPropertyValue(bo, referenceName);
+//	            if (referenceValue != null) {
+//	                if (ProxyHelper.isProxy(referenceValue)) {
+//	                    realReferenceValue = ProxyHelper.getRealObject(referenceValue);
+//	                    if (realReferenceValue != null) {
+//	                        try {
+//	                            setObjectProperty(bo, referenceName, referenceClass, realReferenceValue);
+//	                        }
+//	                        catch (FormatException e) {
+//	                            throw new RuntimeException("FormatException: could not set the property '" + referenceName + "'.", e);
+//	                        }
+//	                        catch (IllegalAccessException e) {
+//	                            throw new RuntimeException("IllegalAccessException: could not set the property '" + referenceName + "'.", e);
+//	                        }
+//	                        catch (InvocationTargetException e) {
+//	                            throw new RuntimeException("InvocationTargetException: could not set the property '" + referenceName + "'.", e);
+//	                        }
+//	                        catch (NoSuchMethodException e) {
+//	                            throw new RuntimeException("NoSuchMethodException: could not set the property '" + referenceName + "'.", e);
+//	                        }
+//	                    }
+//	                }
+//	
+//	                // recurse down through this reference object
+//	                if (realReferenceValue instanceof PersistableBusinessObject && depth > 1) {
+//	                    materializeSubObjectsToDepth((PersistableBusinessObject) realReferenceValue, depth - 1);
+//	                }
+//	            }
+//	
+//	        }
+//        }
+//    }
+//
+//    /**
+//     * This method attempts to materialize all of the proxied reference objects (ie, sub-objects) hanging off the passed-in BO
+//     * object. It will do it just three levels down. In other words, it will only materialize the objects that are direct members of
+//     * the bo, objects that are direct members of those bos, that one more time, and no further down. An IllegalArgumentException 
+//     * will be thrown if the bo object passed in is itself a non-materialized proxy object. If the bo passed in has no proxied 
+//     * sub-objects, then the object will not be modified, and no errors will be thrown.
+//     * 
+//     * @param bo A valid, populated BusinessObject containing (possibly) proxied sub-objects. This object will be modified in place.
+//     */
+//    public static void materializeAllSubObjects(PersistableBusinessObject bo) {
+//        materializeSubObjectsToDepth(bo, 3);
+//    }
 
-        // if depth is zero, then we're done recursing and can just exit
-        if (depth == 0) {
-            return;
-        }
-
-        // deal with the possibility that the bo passed in (ie, the parent object) is an un-materialized proxy
-        if (ProxyHelper.isProxy(bo)) {
-            if (!ProxyHelper.isMaterialized(bo)) {
-                throw new IllegalArgumentException("The bo passed in is an un-materialized proxy, and cannot be used.");
-            }
-        }
-
-        // get the list of reference objects hanging off the parent BO
-        if ( KNSServiceLocator.getPersistenceStructureService().isPersistable( bo.getClass() ) ) {
-	        Map<String, Class> references = KNSServiceLocator.getPersistenceStructureService().listReferenceObjectFields(bo);
-	
-	        // initialize our in-loop objects
-	        String referenceName = "";
-	        Class referenceClass = null;
-	        Object referenceValue = null;
-	        Object realReferenceValue = null;
-	
-	        // for each reference object on the parent bo
-	        for (Iterator iter = references.keySet().iterator(); iter.hasNext();) {
-	            referenceName = (String) iter.next();
-	            referenceClass = references.get(referenceName);
-	
-	            // if its a proxy, replace it with a non-proxy
-	            referenceValue = getPropertyValue(bo, referenceName);
-	            if (referenceValue != null) {
-	                if (ProxyHelper.isProxy(referenceValue)) {
-	                    realReferenceValue = ProxyHelper.getRealObject(referenceValue);
-	                    if (realReferenceValue != null) {
-	                        try {
-	                            setObjectProperty(bo, referenceName, referenceClass, realReferenceValue);
-	                        }
-	                        catch (FormatException e) {
-	                            throw new RuntimeException("FormatException: could not set the property '" + referenceName + "'.", e);
-	                        }
-	                        catch (IllegalAccessException e) {
-	                            throw new RuntimeException("IllegalAccessException: could not set the property '" + referenceName + "'.", e);
-	                        }
-	                        catch (InvocationTargetException e) {
-	                            throw new RuntimeException("InvocationTargetException: could not set the property '" + referenceName + "'.", e);
-	                        }
-	                        catch (NoSuchMethodException e) {
-	                            throw new RuntimeException("NoSuchMethodException: could not set the property '" + referenceName + "'.", e);
-	                        }
-	                    }
-	                }
-	
-	                // recurse down through this reference object
-	                if (realReferenceValue instanceof PersistableBusinessObject && depth > 1) {
-	                    materializeSubObjectsToDepth((PersistableBusinessObject) realReferenceValue, depth - 1);
-	                }
-	            }
-	
-	        }
-        }
-    }
-
     /**
-     * This method attempts to materialize all of the proxied reference objects (ie, sub-objects) hanging off the passed-in BO
-     * object. It will do it just three levels down. In other words, it will only materialize the objects that are direct members of
-     * the bo, objects that are direct members of those bos, that one more time, and no further down. An IllegalArgumentException 
-     * will be thrown if the bo object passed in is itself a non-materialized proxy object. If the bo passed in has no proxied 
-     * sub-objects, then the object will not be modified, and no errors will be thrown.
-     * 
-     * @param bo A valid, populated BusinessObject containing (possibly) proxied sub-objects. This object will be modified in place.
-     */
-    public static void materializeAllSubObjects(PersistableBusinessObject bo) {
-        materializeSubObjectsToDepth(bo, 3);
-    }
-
-    /**
      * This method safely extracts either simple values OR nested values. For example, if the bo is SubAccount, and the fieldName is
      * a21SubAccount.subAccountTypeCode, this thing makes sure it gets the value off the very end attribute, no matter how deeply
      * nested it is. The code would be slightly simpler if this was done recursively, but this is safer, and consumes a constant
@@ -1057,33 +1058,33 @@
         }
     }
     
-    /**
-     * This method safely creates a object from a class
-     * Convenience method to create new object and throw a runtime exception if it cannot
-     * If the class is an {@link ExternalizableBusinessObject}, this method will determine the interface for the EBO and query the
-	 * appropriate module service to create a new instance.
-     * 
-     * @param boClass
-     * 
-     * @return a newInstance() of clazz
-     */
-    public static Object createNewObjectFromClass(Class clazz) {
-		if (clazz == null) {
-			throw new RuntimeException("BO class was passed in as null");
-		}
-		try {
-			if (ExternalizableBusinessObject.class.isAssignableFrom(clazz)) {
-				Class eboInterface = ExternalizableBusinessObjectUtils.determineExternalizableBusinessObjectSubInterface(clazz);
-				ModuleService moduleService = KNSServiceLocator.getKualiModuleService().getResponsibleModuleService(eboInterface);
-				return moduleService.createNewObjectFromExternalizableClass(eboInterface);
-			}
-			else {
-				return clazz.newInstance();
-			}
-		} catch (Exception e) {
-			throw new RuntimeException("Error occured while trying to create a new instance for class " + clazz,e);
-		}
-    }
+//    /**
+//     * This method safely creates a object from a class
+//     * Convenience method to create new object and throw a runtime exception if it cannot
+//     * If the class is an {@link ExternalizableBusinessObject}, this method will determine the interface for the EBO and query the
+//	 * appropriate module service to create a new instance.
+//     * 
+//     * @param boClass
+//     * 
+//     * @return a newInstance() of clazz
+//     */
+//    public static Object createNewObjectFromClass(Class clazz) {
+//		if (clazz == null) {
+//			throw new RuntimeException("BO class was passed in as null");
+//		}
+//		try {
+//			if (ExternalizableBusinessObject.class.isAssignableFrom(clazz)) {
+//				Class eboInterface = ExternalizableBusinessObjectUtils.determineExternalizableBusinessObjectSubInterface(clazz);
+//				ModuleService moduleService = KRADServiceLocator.getKualiModuleService().getResponsibleModuleService(eboInterface);
+//				return moduleService.createNewObjectFromExternalizableClass(eboInterface);
+//			}
+//			else {
+//				return clazz.newInstance();
+//			}
+//		} catch (Exception e) {
+//			throw new RuntimeException("Error occured while trying to create a new instance for class " + clazz,e);
+//		}
+//    }
 
 	/**
 	 * Return whether or not an attribute is writeable. This method is aware that that Collections may be involved and handles them
Index: work/src/org/kuali/rice/kns/util/NumberUtils.java
===================================================================
--- work/src/org/kuali/rice/kns/util/NumberUtils.java	(revision 32242)
+++ work/src/org/kuali/rice/kns/util/NumberUtils.java	(revision 32263)
@@ -15,6 +15,8 @@
  */
 package org.kuali.rice.kns.util;
 
+import org.kuali.rice.core.api.util.type.KualiDecimal;
+
 /**
  * 
  */
Index: work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java
===================================================================
--- work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java	(revision 32242)
+++ work/src/org/kuali/rice/kns/web/filter/DummyLoginFilter.java	(revision 32263)
@@ -27,7 +27,7 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletRequestWrapper;
 
-import org.kuali.rice.kew.util.KEWConstants;
+import org.kuali.rice.kew.api.KewApiConstants;
 import org.kuali.rice.krad.UserSession;
 import org.kuali.rice.krad.util.KRADConstants;
 
